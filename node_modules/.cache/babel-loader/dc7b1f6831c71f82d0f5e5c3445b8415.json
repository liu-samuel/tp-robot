{"ast":null,"code":"'use strict';\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\n\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\n\n\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n  var isProperty = false;\n\n  try {\n    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {// its okay to eat failure here.\n  } // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n\n\n  if (isProperty) {\n    return;\n  }\n\n  var type;\n\n  try {\n    type = typeof source[methodName];\n  } catch (error) {// NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n  /* eslint no-loop-func:0 */\n\n\n  wrapper[methodName] = function () {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\n\n\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n  var difference = new Set();\n  list1.forEach(function (item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n  return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\n\n\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set ? Array.from(list.values()) : list;\n  return listArray.reduce(function (flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\n\n\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' ? navigator.userAgent : null;\n}\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\n\n\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n\n  if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n    return 'safari';\n  }\n\n  return null;\n}\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\n\n\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n\n  var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n  var match = (userAgent.match(regex) || [])[2];\n\n  if (!match) {\n    return null;\n  }\n\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\n\n\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  return /Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent);\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\n\n\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function () {\n      return currentListener;\n    },\n    set: function (newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\n\n\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function (result) {\n      onSuccess(result);\n    }, function (error) {\n      onFailure(error);\n    });\n  }\n\n  return promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\n\n\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\n\n\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n    target.addEventListener(propertyName.slice(2), function () {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function () {\n      return target[propertyName];\n    }\n  });\n}\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\n\n\nfunction support() {\n  return typeof navigator === 'object' && typeof navigator.mediaDevices === 'object' && typeof navigator.mediaDevices.getUserMedia === 'function' && typeof RTCPeerConnection === 'function';\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;","map":{"version":3,"mappings":"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","names":["defer","deferred","promise","Promise","resolve","reject","delegateMethod","source","wrapper","target","methodName","match","isProperty","propDesc","Object","getOwnPropertyDescriptor","get","error","type","apply","arguments","delegateMethods","difference","list1","list2","Array","isArray","Set","values","forEach","item","has","add","flatMap","list","mapFn","listArray","Map","from","reduce","flattened","mapped","concat","getUserAgent","navigator","userAgent","guessBrowser","test","guessBrowserVersion","prefix","chrome","firefox","safari","regex","RegExp","versions","split","map","Number","major","isNaN","minor","isIOSChrome","interceptEvent","currentListener","defineProperty","set","newListener","removeEventListener","addEventListener","legacyPromise","onSuccess","onFailure","then","result","makeUUID","replace","c","r","Math","random","v","toString","proxyProperties","getOwnPropertyNames","propertyName","proxyProperty","value","writable","slice","dispatchEvent","enumerable","support","mediaDevices","getUserMedia","RTCPeerConnection","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/webrtc/util/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function(resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n\n  var isProperty = false;\n  try {\n    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {\n    // its okay to eat failure here.\n  }\n\n  // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n  if (isProperty) {\n    return;\n  }\n\n  var type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function() {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n\n  var difference = new Set();\n\n  list1.forEach(function(item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n\n  return difference;\n}\n\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set\n    ? Array.from(list.values())\n    : list;\n\n  return listArray.reduce(function(flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'\n    ? navigator.userAgent\n    : null;\n}\n\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n  if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n    return 'safari';\n  }\n  return null;\n}\n\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n  var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n  var match = (userAgent.match(regex) || [])[2];\n\n  if (!match) {\n    return null;\n  }\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  return (/Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent));\n}\n\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function() {\n      return currentListener;\n    },\n    set: function(newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function(result) {\n      onSuccess(result);\n    }, function(error) {\n      onFailure(error);\n    });\n  }\n  return promise;\n}\n\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function(propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n\n    target.addEventListener(propertyName.slice(2), function() {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function() {\n      return target[propertyName];\n    }\n  });\n}\n\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\nfunction support() {\n  return typeof navigator === 'object'\n    && typeof navigator.mediaDevices === 'object'\n    && typeof navigator.mediaDevices.getUserMedia === 'function'\n    && typeof RTCPeerConnection === 'function';\n}\n\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;\n"]},"metadata":{},"sourceType":"script"}