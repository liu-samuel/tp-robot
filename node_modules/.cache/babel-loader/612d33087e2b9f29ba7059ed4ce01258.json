{"ast":null,"code":"'use strict';\n\nvar _a = require('../../util/constants'),\n    ICE_ACTIVITY_CHECK_PERIOD_MS = _a.ICE_ACTIVITY_CHECK_PERIOD_MS,\n    ICE_INACTIVITY_THRESHOLD_MS = _a.ICE_INACTIVITY_THRESHOLD_MS;\n/**\n * Monitors a {@link RTCPeerConnection}'s stats and notifies\n * caller when inactivity is detected.\n */\n\n\nvar IceConnectionMonitor =\n/** @class */\nfunction () {\n  /**\n   * Construct an {@link IceConnectionMonitor}.\n   * @param {RTCPeerConnection} peerConnection\n   * @param {object} [options]\n   */\n  function IceConnectionMonitor(peerConnection, options) {\n    options = Object.assign({\n      activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,\n      inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS\n    }, options);\n    Object.defineProperties(this, {\n      _activityCheckPeriodMs: {\n        value: options.activityCheckPeriodMs\n      },\n      _inactivityThresholdMs: {\n        value: options.inactivityThresholdMs\n      },\n      _lastActivity: {\n        value: null,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _timer: {\n        value: null,\n        writable: true\n      },\n      _onIceConnectionStateChanged: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  IceConnectionMonitor.prototype._getActivePairStat = function (stats) {\n    var statsArray = Array.from(stats.values());\n    var activePairStats = statsArray.find(function (stat) {\n      return stat.type === 'candidate-pair' && stat.nominated;\n    }); // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network\n    // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.\n\n    return activePairStats || {\n      bytesReceived: 0,\n      timestamp: Math.round(new Date().getTime())\n    };\n  };\n  /**\n   * Get ICE connection stats, and extract received and send bytes.\n   * @returns Promise<?RTCIceCandidatePairStats>\n   */\n\n\n  IceConnectionMonitor.prototype._getIceConnectionStats = function () {\n    var _this = this;\n\n    return this._peerConnection.getStats().then(function (stats) {\n      return _this._getActivePairStat(stats);\n    }).catch(function () {\n      return null;\n    });\n  };\n  /**\n   * schedules/un-schedules inactivity callback.\n   */\n\n\n  IceConnectionMonitor.prototype._scheduleInactivityCallback = function (callback) {\n    var _this = this;\n\n    if (callback && this._onIceConnectionStateChanged === null) {\n      // schedule callback\n      this._onIceConnectionStateChanged = function () {\n        if (_this._peerConnection.iceConnectionState === 'disconnected') {\n          // eslint-disable-next-line callback-return\n          callback();\n        }\n      };\n\n      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n    } else if (!callback && this._onIceConnectionStateChanged) {\n      // unschedule callback\n      this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n\n      this._onIceConnectionStateChanged = null;\n    }\n  };\n  /**\n   * Start monitoring the ICE connection.\n   * Monitors bytes received on active ice connection pair,\n   * invokes onIceConnectionInactive when inactivity is detected.\n   * @param {function} onIceConnectionInactive\n   */\n\n\n  IceConnectionMonitor.prototype.start = function (onIceConnectionInactive) {\n    var _this = this;\n\n    this.stop();\n    this._timer = setInterval(function () {\n      _this._getIceConnectionStats().then(function (iceStats) {\n        if (!iceStats) {\n          return;\n        } // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.\n        // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value\n        // includes RTCP traffic and is +ve even when there are no tracks subscribed to.\n\n\n        if (!_this._lastActivity || _this._lastActivity.bytesReceived !== iceStats.bytesReceived) {\n          _this._lastActivity = iceStats; // detected activity, cancel scheduled callback if any.\n\n          _this._scheduleInactivityCallback(null);\n        }\n\n        if (iceStats.timestamp - _this._lastActivity.timestamp >= _this._inactivityThresholdMs) {\n          // detected inactivity.\n          if (_this._peerConnection.iceConnectionState === 'disconnected') {\n            onIceConnectionInactive();\n          } else if (_this._onIceConnectionStateChanged === null) {\n            _this._scheduleInactivityCallback(onIceConnectionInactive);\n          }\n        }\n      });\n    }, this._activityCheckPeriodMs);\n  };\n  /**\n   * Stop monitoring the ICE connection state.\n   * @returns {void}\n   */\n\n\n  IceConnectionMonitor.prototype.stop = function () {\n    this._scheduleInactivityCallback(null);\n\n    if (this._timer !== null) {\n      clearInterval(this._timer);\n      this._timer = null;\n      this._lastActivity = null;\n    }\n  };\n\n  return IceConnectionMonitor;\n}();\n\nmodule.exports = IceConnectionMonitor;","map":{"version":3,"mappings":"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","names":["require","ICE_ACTIVITY_CHECK_PERIOD_MS","ICE_INACTIVITY_THRESHOLD_MS","peerConnection","options","Object","assign","activityCheckPeriodMs","inactivityThresholdMs","defineProperties","_activityCheckPeriodMs","value","_inactivityThresholdMs","_lastActivity","writable","_peerConnection","_timer","_onIceConnectionStateChanged","IceConnectionMonitor","stats","statsArray","Array","from","values","activePairStats","find","type","stat","nominated","bytesReceived","timestamp","Math","round","Date","getTime","getStats","then","_getActivePairStat","catch","callback","_this","iceConnectionState","addEventListener","removeEventListener","onIceConnectionInactive","stop","setInterval","_getIceConnectionStats","iceStats","_scheduleInactivityCallback","clearInterval","module","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/signaling/v2/iceconnectionmonitor.js"],"sourcesContent":["'use strict';\n\nconst { ICE_ACTIVITY_CHECK_PERIOD_MS, ICE_INACTIVITY_THRESHOLD_MS } = require('../../util/constants');\n\n/**\n * Monitors a {@link RTCPeerConnection}'s stats and notifies\n * caller when inactivity is detected.\n */\nclass IceConnectionMonitor {\n  /**\n   * Construct an {@link IceConnectionMonitor}.\n   * @param {RTCPeerConnection} peerConnection\n   * @param {object} [options]\n   */\n  constructor(peerConnection, options) {\n    options = Object.assign({\n      activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,\n      inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS,\n    }, options);\n\n    Object.defineProperties(this, {\n      _activityCheckPeriodMs: {\n        value: options.activityCheckPeriodMs\n      },\n      _inactivityThresholdMs: {\n        value: options.inactivityThresholdMs\n      },\n      _lastActivity: {\n        value: null,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _timer: {\n        value: null,\n        writable: true,\n      },\n      _onIceConnectionStateChanged: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  _getActivePairStat(stats) {\n    const statsArray = Array.from(stats.values());\n    const activePairStats = statsArray.find(stat => stat.type === 'candidate-pair' && stat.nominated);\n    // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network\n    // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.\n    return activePairStats || {\n      bytesReceived: 0,\n      timestamp: Math.round((new Date()).getTime())\n    };\n  }\n\n  /**\n   * Get ICE connection stats, and extract received and send bytes.\n   * @returns Promise<?RTCIceCandidatePairStats>\n   */\n  _getIceConnectionStats() {\n    return this._peerConnection.getStats().then(stats => this._getActivePairStat(stats)).catch(() => {\n      return null;\n    });\n  }\n\n  /**\n   * schedules/un-schedules inactivity callback.\n   */\n  _scheduleInactivityCallback(callback) {\n    if (callback && this._onIceConnectionStateChanged === null) {\n      // schedule callback\n      this._onIceConnectionStateChanged = () => {\n        if (this._peerConnection.iceConnectionState === 'disconnected') {\n          // eslint-disable-next-line callback-return\n          callback();\n        }\n      };\n      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n    } else if (!callback && this._onIceConnectionStateChanged) {\n      // unschedule callback\n      this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n      this._onIceConnectionStateChanged = null;\n    }\n  }\n\n  /**\n   * Start monitoring the ICE connection.\n   * Monitors bytes received on active ice connection pair,\n   * invokes onIceConnectionInactive when inactivity is detected.\n   * @param {function} onIceConnectionInactive\n   */\n  start(onIceConnectionInactive) {\n    this.stop();\n\n    this._timer = setInterval(() => {\n      this._getIceConnectionStats().then(iceStats => {\n        if (!iceStats) {\n          return;\n        }\n\n        // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.\n        // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value\n        // includes RTCP traffic and is +ve even when there are no tracks subscribed to.\n        if (!this._lastActivity || this._lastActivity.bytesReceived !== iceStats.bytesReceived) {\n          this._lastActivity = iceStats;\n          // detected activity, cancel scheduled callback if any.\n          this._scheduleInactivityCallback(null);\n        }\n\n        if (iceStats.timestamp - this._lastActivity.timestamp >= this._inactivityThresholdMs) {\n          // detected inactivity.\n          if (this._peerConnection.iceConnectionState === 'disconnected') {\n            onIceConnectionInactive();\n          } else if (this._onIceConnectionStateChanged === null) {\n            this._scheduleInactivityCallback(onIceConnectionInactive);\n          }\n        }\n      });\n    }, this._activityCheckPeriodMs);\n  }\n\n  /**\n   * Stop monitoring the ICE connection state.\n   * @returns {void}\n   */\n  stop() {\n    this._scheduleInactivityCallback(null);\n    if (this._timer !== null) {\n      clearInterval(this._timer);\n      this._timer = null;\n      this._lastActivity = null;\n    }\n  }\n}\n\nmodule.exports = IceConnectionMonitor;\n"]},"metadata":{},"sourceType":"script"}