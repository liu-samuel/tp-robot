{"ast":null,"code":"'use strict';\n\nvar detectSilence = require('./detectsilence');\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\n\n\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  var retry = 0; // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n\n  var AudioContextFactory = require('./audiocontext');\n\n  var holder = {};\n  var audioContext = AudioContextFactory.getOrCreate(holder);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n\n  function doWorkaround() {\n    return getUserMedia(constraints).then(function (stream) {\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n        log.warn('Encountered an error while detecting silence', err);\n        return true;\n      }) : Promise.resolve(false);\n      return isSilentPromise.then(function (isSilent) {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n\n        log.warn(\"Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #\" + ++retry + \".\");\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(function (stream) {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, function (error) {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;","map":{"version":3,"mappings":"AAAA;;AAEA,IAAMA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA7B;AAEA;;;;;;;;;;;;;;;;;;;;;;AAoBA,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,YAAzB,EAAuCC,WAAvC,EAAoDC,CAApD,EAAuDC,OAAvD,EAA8D;EAC5DD,CAAC,GAAG,OAAOA,CAAP,KAAa,QAAb,GAAwBA,CAAxB,GAA4B,CAAhC;EACA,IAAIE,KAAK,GAAG,CAAZ,CAF4D,CAI5D;EACA;;EACA,IAAMC,mBAAmB,GAAGR,OAAO,CAAC,gBAAD,CAAnC;;EACA,IAAMS,MAAM,GAAG,EAAf;EACA,IAAMC,YAAY,GAAGF,mBAAmB,CAACG,WAApB,CAAgCF,MAAhC,CAArB;EAEA;;;;;EAIA,SAASG,YAAT,GAAqB;IACnB,OAAOT,YAAY,CAACC,WAAD,CAAZ,CAA0BS,IAA1B,CAA+B,kBAAM;MAC1C,IAAMC,eAAe,GAAGV,WAAW,CAACW,KAAZ,GACpBhB,aAAa,CAACW,YAAD,EAAeM,MAAf,EAAuBV,OAAvB,CAAb,CAA6CW,KAA7C,CAAmD,eAAG;QACtDf,GAAG,CAACgB,IAAJ,CAAS,8CAAT,EAAyDC,GAAzD;QACA,OAAO,IAAP;MACD,CAHC,CADoB,GAKpBC,OAAO,CAACC,OAAR,CAAgB,KAAhB,CALJ;MAMA,OAAOP,eAAe,CAACD,IAAhB,CAAqB,oBAAQ;QAClC,IAAI,CAACS,QAAL,EAAe;UACbpB,GAAG,CAACqB,IAAJ,CAAS,wDAAT;UACA,OAAOP,MAAP;QACD,CAHD,MAGO,IAAIX,CAAC,IAAI,CAAT,EAAY;UACjBH,GAAG,CAACgB,IAAJ,CAAS;sEAAT;UAEA,OAAOF,MAAP;QACD;;QACDd,GAAG,CAACgB,IAAJ,CAAS,wHAEd,EAAEX,KAFY,GAEP,GAFF;QAGAS,MAAM,CAACQ,SAAP,GAAmBC,OAAnB,CAA2B,iBAAK;UAAI,YAAK,CAACC,IAAN;QAAY,CAAhD;QACArB,CAAC;QACD,OAAOO,YAAY,EAAnB;MACD,CAfM,CAAP;IAgBD,CAvBM,CAAP;EAwBD;;EAED,OAAOA,YAAY,GAAGC,IAAf,CAAoB,kBAAM;IAC/BL,mBAAmB,CAACmB,OAApB,CAA4BlB,MAA5B;IACA,OAAOO,MAAP;EACD,CAHM,EAGJ,iBAAK;IACNR,mBAAmB,CAACmB,OAApB,CAA4BlB,MAA5B;IACA,MAAMmB,KAAN;EACD,CANM,CAAP;AAOD;;AAEDC,MAAM,CAACC,OAAP,GAAiB7B,UAAjB","names":["detectSilence","require","workaround","log","getUserMedia","constraints","n","timeout","retry","AudioContextFactory","holder","audioContext","getOrCreate","doWorkaround","then","isSilentPromise","audio","stream","catch","warn","err","Promise","resolve","isSilent","info","getTracks","forEach","stop","release","error","module","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/webaudio/workaround180748.js"],"sourcesContent":["'use strict';\n\nconst detectSilence = require('./detectsilence');\n\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  let retry = 0;\n\n  // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n  const AudioContextFactory = require('./audiocontext');\n  const holder = {};\n  const audioContext = AudioContextFactory.getOrCreate(holder);\n\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n  function doWorkaround() {\n    return getUserMedia(constraints).then(stream => {\n      const isSilentPromise = constraints.audio\n        ? detectSilence(audioContext, stream, timeout).catch(err => {\n          log.warn('Encountered an error while detecting silence', err);\n          return true;\n        })\n        : Promise.resolve(false);\n      return isSilentPromise.then(isSilent => {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n        log.warn(`Got a silent audio MediaStreamTrack. Stopping all \\\nMediaStreamTracks and calling getUserMedia again. This is retry \\\n#${++retry}.`);\n        stream.getTracks().forEach(track => track.stop());\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(stream => {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, error => {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;\n"]},"metadata":{},"sourceType":"script"}