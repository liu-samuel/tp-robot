{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nvar guessBrowser = require('../../webrtc/util').guessBrowser;\n\nvar PeerConnectionV2 = require('./peerconnection');\n\nvar MediaTrackSender = require('../../media/track/sender');\n\nvar QueueingEventEmitter = require('../../queueingeventemitter');\n\nvar util = require('../../util');\n\nvar MediaConnectionError = require('../../util/twilio-video-errors').MediaConnectionError;\n\nvar isFirefox = guessBrowser() === 'firefox';\n/**\n * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.\n * @extends QueueingEventEmitter\n * @emits PeerConnectionManager#candidates\n * @emits PeerConnectionManager#connectionStateChanged\n * @emits PeerConnectionManager#description\n * @emits PeerConnectionManager#iceConnectionStateChanged\n * @emits PeerConnectionManager#trackAdded\n */\n\nvar PeerConnectionManager =\n/** @class */\nfunction (_super) {\n  __extends(PeerConnectionManager, _super);\n  /**\n   * Construct {@link PeerConnectionManager}.\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   */\n\n\n  function PeerConnectionManager(encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this) || this;\n\n    options = Object.assign({\n      audioContextFactory: isFirefox ? require('../../webaudio/audiocontext') : null,\n      PeerConnectionV2: PeerConnectionV2\n    }, options);\n    var audioContext = options.audioContextFactory ? options.audioContextFactory.getOrCreate(_this) : null; // NOTE(mroberts): If we're using an AudioContext, we don't need to specify\n    // `offerToReceiveAudio` in RTCOfferOptions.\n\n    var offerOptions = audioContext ? {\n      offerToReceiveVideo: true\n    } : {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n    Object.defineProperties(_this, {\n      _audioContextFactory: {\n        value: options.audioContextFactory\n      },\n      _closedPeerConnectionIds: {\n        value: new Set()\n      },\n      _configuration: {\n        writable: true,\n        value: null\n      },\n      _configurationDeferred: {\n        writable: true,\n        value: util.defer()\n      },\n      _connectionState: {\n        value: 'new',\n        writable: true\n      },\n      _dummyAudioTrackSender: {\n        value: audioContext ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext)) : null\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _iceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _dataTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _lastConnectionState: {\n        value: 'new',\n        writable: true\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _mediaTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _offerOptions: {\n        value: offerOptions\n      },\n      _peerConnections: {\n        value: new Map()\n      },\n      _preferredCodecs: {\n        value: preferredCodecs\n      },\n      _sessionTimeout: {\n        value: null,\n        writable: true\n      },\n      _PeerConnectionV2: {\n        value: options.PeerConnectionV2\n      }\n    });\n    return _this;\n  }\n\n  PeerConnectionManager.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._peerConnections.forEach(function (pc) {\n      return pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast);\n    });\n\n    this._preferredCodecs.video.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n\n  Object.defineProperty(PeerConnectionManager.prototype, \"connectionState\", {\n    /**\n     * A summarized RTCPeerConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function get() {\n      return this._connectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionManager.prototype, \"iceConnectionState\", {\n    /**\n     * A summarized RTCIceConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCIceConnectionState}\n     */\n    get: function get() {\n      return this._iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Close the {@link PeerConnectionV2}s which are no longer relevant.\n   * @param {Array<object>} peerConnectionStates\n   * @returns {this}\n   */\n\n  PeerConnectionManager.prototype._closeAbsentPeerConnections = function (peerConnectionStates) {\n    var peerConnectionIds = new Set(peerConnectionStates.map(function (peerConnectionState) {\n      return peerConnectionState.id;\n    }));\n\n    this._peerConnections.forEach(function (peerConnection) {\n      if (!peerConnectionIds.has(peerConnection.id)) {\n        peerConnection._close();\n      }\n    });\n\n    return this;\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s configuration.\n   * @private\n   * @returns {Promise<object>}\n   */\n\n\n  PeerConnectionManager.prototype._getConfiguration = function () {\n    return this._configurationDeferred.promise;\n  };\n  /**\n   * Get or create a {@link PeerConnectionV2}.\n   * @private\n   * @param {string} id\n   * @param {object} [configuration]\n   * @returns {PeerConnectionV2}\n   */\n\n\n  PeerConnectionManager.prototype._getOrCreate = function (id, configuration) {\n    var _this = this;\n\n    var self = this;\n\n    var peerConnection = this._peerConnections.get(id);\n\n    if (!peerConnection) {\n      var PeerConnectionV2_1 = this._PeerConnectionV2;\n      var options = Object.assign({\n        dummyAudioMediaStreamTrack: this._dummyAudioTrackSender ? this._dummyAudioTrackSender.track : null,\n        offerOptions: this._offerOptions\n      }, this._sessionTimeout ? {\n        sessionTimeout: this._sessionTimeout\n      } : {}, configuration);\n\n      try {\n        peerConnection = new PeerConnectionV2_1(id, this._encodingParameters, this._preferredCodecs, options);\n      } catch (e) {\n        throw new MediaConnectionError();\n      }\n\n      this._peerConnections.set(peerConnection.id, peerConnection);\n\n      peerConnection.on('candidates', this.queue.bind(this, 'candidates'));\n      peerConnection.on('description', this.queue.bind(this, 'description'));\n      peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));\n      peerConnection.on('stateChanged', function stateChanged(state) {\n        if (state === 'closed') {\n          peerConnection.removeListener('stateChanged', stateChanged);\n\n          self._dataTrackSenders.forEach(function (sender) {\n            return peerConnection.removeDataTrackSender(sender);\n          });\n\n          self._mediaTrackSenders.forEach(function (sender) {\n            return peerConnection.removeMediaTrackSender(sender);\n          });\n\n          self._peerConnections.delete(peerConnection.id);\n\n          self._closedPeerConnectionIds.add(peerConnection.id);\n\n          updateConnectionState(self);\n          updateIceConnectionState(self);\n        }\n      });\n      peerConnection.on('connectionStateChanged', function () {\n        return updateConnectionState(_this);\n      });\n      peerConnection.on('iceConnectionStateChanged', function () {\n        return updateIceConnectionState(_this);\n      });\n\n      this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);\n\n      this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);\n\n      updateIceConnectionState(this);\n    }\n\n    return peerConnection;\n  };\n  /**\n   * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.close = function () {\n    this._peerConnections.forEach(function (peerConnection) {\n      peerConnection.close();\n    });\n\n    if (this._dummyAudioTrackSender) {\n      this._dummyAudioTrackSender.stop();\n    }\n\n    if (this._audioContextFactory) {\n      this._audioContextFactory.release(this);\n    }\n\n    updateIceConnectionState(this);\n    return this;\n  };\n  /**\n   * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.\n   * Then, create a new offer with the newly-created {@link PeerConnectionV2}.\n   * @return {Promise<this>}\n   */\n\n\n  PeerConnectionManager.prototype.createAndOffer = function () {\n    var _this = this;\n\n    return this._getConfiguration().then(function (configuration) {\n      var id;\n\n      do {\n        id = util.makeUUID();\n      } while (_this._peerConnections.has(id));\n\n      return _this._getOrCreate(id, configuration);\n    }).then(function (peerConnection) {\n      return peerConnection.offer();\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all\n   * the {@link PeerConnectionV2}s.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n\n\n  PeerConnectionManager.prototype.getTrackReceivers = function () {\n    return util.flatMap(this._peerConnections, function (peerConnection) {\n      return peerConnection.getTrackReceivers();\n    });\n  };\n  /**\n   * Get the states of all {@link PeerConnectionV2}s.\n   * @returns {Array<object>}\n   */\n\n\n  PeerConnectionManager.prototype.getStates = function () {\n    var peerConnectionStates = [];\n\n    this._peerConnections.forEach(function (peerConnection) {\n      var peerConnectionState = peerConnection.getState();\n\n      if (peerConnectionState) {\n        peerConnectionStates.push(peerConnectionState);\n      }\n    });\n\n    return peerConnectionStates;\n  };\n  /**\n   * Set the {@link PeerConnectionManager}'s configuration.\n   * @param {object} configuration\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.setConfiguration = function (configuration) {\n    if (this._configuration) {\n      this._configurationDeferred = util.defer();\n\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setConfiguration(configuration);\n      });\n    }\n\n    this._configuration = configuration;\n\n    this._configurationDeferred.resolve(configuration);\n\n    return this;\n  };\n  /**\n   * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.setIceReconnectTimeout = function (period) {\n    if (this._sessionTimeout === null) {\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setIceReconnectTimeout(period);\n      });\n\n      this._sessionTimeout = period;\n    }\n\n    return this;\n  };\n  /**\n   * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders\n   * @returns {this}\n   */\n\n\n  PeerConnectionManager.prototype.setTrackSenders = function (trackSenders) {\n    var dataTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender.kind === 'data';\n    }));\n    var mediaTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video');\n    }));\n    var changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);\n    this._dataTrackSenders = dataTrackSenders;\n    this._mediaTrackSenders = mediaTrackSenders;\n    applyTrackSenderChanges(this, changes);\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionManager}.\n   * @param {Array<object>} peerConnectionStates\n   * @param {boolean} [synced=false]\n   * @returns {Promise<this>}\n   */\n\n\n  PeerConnectionManager.prototype.update = function (peerConnectionStates, synced) {\n    var _this = this;\n\n    if (synced === void 0) {\n      synced = false;\n    }\n\n    if (synced) {\n      this._closeAbsentPeerConnections(peerConnectionStates);\n    }\n\n    return this._getConfiguration().then(function (configuration) {\n      return Promise.all(peerConnectionStates.map(function (peerConnectionState) {\n        if (_this._closedPeerConnectionIds.has(peerConnectionState.id)) {\n          return null;\n        }\n\n        var peerConnection = _this._getOrCreate(peerConnectionState.id, configuration);\n\n        return peerConnection.update(peerConnectionState);\n      }));\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n\n\n  PeerConnectionManager.prototype.getStats = function () {\n    var peerConnections = Array.from(this._peerConnections.values());\n    return Promise.all(peerConnections.map(function (peerConnection) {\n      return peerConnection.getStats().then(function (response) {\n        return [peerConnection.id, response];\n      });\n    })).then(function (responses) {\n      return new Map(responses);\n    });\n  };\n\n  return PeerConnectionManager;\n}(QueueingEventEmitter);\n/**\n * Create a dummy audio MediaStreamTrack with the given AudioContext.\n * @private\n * @param {AudioContext} audioContext\n * @return {MediaStreamTrack}\n */\n\n\nfunction createDummyAudioMediaStreamTrack(audioContext) {\n  var mediaStreamDestination = audioContext.createMediaStreamDestination();\n  return mediaStreamDestination.stream.getAudioTracks()[0];\n}\n/**\n * @event {PeerConnectionManager#candidates}\n * @param {object} candidates\n */\n\n/**\n * @event {PeerConnectionManager#connectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#description}\n * @param {object} description\n */\n\n/**\n * @event {PeerConnectionManager#iceConnectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#trackAdded}\n * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver\n */\n\n/**\n * Apply {@link TrackSenderChanges}.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {TrackSenderChanges} changes\n * @returns {void}\n */\n\n\nfunction applyTrackSenderChanges(peerConnectionManager, changes) {\n  if (changes.data.add.size || changes.data.remove.size || changes.media.add.size || changes.media.remove.size) {\n    peerConnectionManager._peerConnections.forEach(function (peerConnection) {\n      changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);\n      changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);\n      changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);\n      changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);\n\n      if (changes.media.add.size || changes.media.remove.size || changes.data.add.size && !peerConnection.isApplicationSectionNegotiated) {\n        peerConnection.offer();\n      }\n    });\n  }\n}\n/**\n * @interface DataTrackSenderChanges\n * @property {Set<DataTrackSender>} add\n * @property {Set<DataTrackSender>} remove\n */\n\n/**\n * Get the {@Link DataTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @returns {DataTrackSenderChanges} changes\n */\n\n\nfunction getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {\n  var dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);\n  var dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);\n  return {\n    add: dataTrackSendersToAdd,\n    remove: dataTrackSendersToRemove\n  };\n}\n/**\n * @interface TrackSenderChanges\n * @property {DataTrackSenderChanges} data\n * @property {MediaTrackSenderChanges} media\n */\n\n/**\n * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {TrackSenderChanges} changes\n */\n\n\nfunction getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {\n  return {\n    data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),\n    media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)\n  };\n}\n/**\n * @interface MediaTrackSenderChanges\n * @property {Set<MediaTrackSender>} add\n * @property {Set<MediaTrackSender>} remove\n */\n\n/**\n * Get the {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {MediaTrackSenderChanges} changes\n */\n\n\nfunction getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {\n  var mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);\n  var mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);\n  return {\n    add: mediaTrackSendersToAdd,\n    remove: mediaTrackSendersToRemove\n  };\n}\n/**\n * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a \"rank\".\n */\n\n\nvar toRank = {\n  new: 0,\n  checking: 1,\n  connecting: 2,\n  connected: 3,\n  completed: 4,\n  disconnected: -1,\n  failed: -2,\n  closed: -3\n};\n/**\n * This object maps \"rank\" back to RTCIceConnectionState or RTCPeerConnectionState values.\n */\n\nvar fromRank;\n/**\n * `Object.keys` is not supported in older browsers, so we can't just\n * synchronously call it in this module; we need to defer invoking it until we\n * know we're in a modern environment (i.e., anything that supports WebRTC).\n * @returns {object} fromRank\n */\n\nfunction createFromRank() {\n  return Object.keys(toRank).reduce(function (fromRank, state) {\n    var _a;\n\n    return Object.assign(fromRank, (_a = {}, _a[toRank[state]] = state, _a));\n  }, {});\n}\n/**\n * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.\n * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states\n * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary\n */\n\n\nfunction summarizeIceOrPeerConnectionStates(states) {\n  if (!states.length) {\n    return 'new';\n  }\n\n  fromRank = fromRank || createFromRank();\n  return states.reduce(function (state1, state2) {\n    return fromRank[Math.max(toRank[state1], toRank[state2])];\n  });\n}\n/**\n * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an\n * \"iceConnectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\n\n\nfunction updateIceConnectionState(pcm) {\n  pcm._lastIceConnectionState = pcm.iceConnectionState;\n  pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.iceConnectionState;\n  }));\n\n  if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {\n    pcm.emit('iceConnectionStateChanged');\n  }\n}\n/**\n * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a\n * \"connectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\n\n\nfunction updateConnectionState(pcm) {\n  pcm._lastConnectionState = pcm.connectionState;\n  pcm._connectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.connectionState;\n  }));\n\n  if (pcm.connectionState !== pcm._lastConnectionState) {\n    pcm.emit('connectionStateChanged');\n  }\n}\n\nmodule.exports = PeerConnectionManager;","map":{"version":3,"mappings":"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","names":["require","guessBrowser","PeerConnectionV2","MediaTrackSender","QueueingEventEmitter","util","MediaConnectionError","isFirefox","__extends","encodingParameters","preferredCodecs","options","_super","Object","assign","audioContextFactory","audioContext","getOrCreate","_this","offerOptions","offerToReceiveVideo","offerToReceiveAudio","defineProperties","_audioContextFactory","value","_closedPeerConnectionIds","Set","_configuration","writable","_configurationDeferred","defer","_connectionState","_dummyAudioTrackSender","createDummyAudioMediaStreamTrack","_encodingParameters","_iceConnectionState","_dataTrackSenders","_lastConnectionState","_lastIceConnectionState","_mediaTrackSenders","_offerOptions","_peerConnections","Map","_preferredCodecs","_sessionTimeout","_PeerConnectionV2","PeerConnectionManager","effectiveAdaptiveSimulcast","forEach","setEffectiveAdaptiveSimulcast","video","cs","adaptiveSimulcast","peerConnectionStates","peerConnectionIds","map","id","has","peerConnection","_close","promise","configuration","self","get","PeerConnectionV2_1","dummyAudioMediaStreamTrack","track","sessionTimeout","e","set","on","queue","bind","stateChanged","state","removeListener","removeDataTrackSender","sender","removeMediaTrackSender","delete","add","updateConnectionState","updateIceConnectionState","addDataTrackSender","addMediaTrackSender","close","stop","release","_getConfiguration","then","makeUUID","_getOrCreate","offer","flatMap","getTrackReceivers","peerConnectionState","getState","push","setConfiguration","resolve","period","setIceReconnectTimeout","trackSenders","dataTrackSenders","filter","kind","mediaTrackSenders","trackSender","changes","getTrackSenderChanges","applyTrackSenderChanges","synced","_closeAbsentPeerConnections","Promise","all","update","peerConnections","Array","from","values","getStats","response","responses","mediaStreamDestination","createMediaStreamDestination","stream","getAudioTracks","peerConnectionManager","data","size","remove","media","isApplicationSectionNegotiated","getDataTrackSenderChanges","dataTrackSendersToAdd","difference","dataTrackSendersToRemove","getMediaTrackSenderChanges","mediaTrackSendersToAdd","mediaTrackSendersToRemove","toRank","new","checking","connecting","connected","completed","disconnected","failed","closed","fromRank","createFromRank","keys","reduce","_a","summarizeIceOrPeerConnectionStates","states","length","state1","state2","Math","max","pcm","iceConnectionState","__spreadArray","emit","connectionState","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/signaling/v2/peerconnectionmanager.js"],"sourcesContent":["'use strict';\n\nconst { guessBrowser } = require('../../webrtc/util');\nconst PeerConnectionV2 = require('./peerconnection');\nconst MediaTrackSender = require('../../media/track/sender');\nconst QueueingEventEmitter = require('../../queueingeventemitter');\nconst util = require('../../util');\nconst { MediaConnectionError } = require('../../util/twilio-video-errors');\n\nconst isFirefox = guessBrowser() === 'firefox';\n\n/**\n * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.\n * @extends QueueingEventEmitter\n * @emits PeerConnectionManager#candidates\n * @emits PeerConnectionManager#connectionStateChanged\n * @emits PeerConnectionManager#description\n * @emits PeerConnectionManager#iceConnectionStateChanged\n * @emits PeerConnectionManager#trackAdded\n */\nclass PeerConnectionManager extends QueueingEventEmitter {\n  /**\n   * Construct {@link PeerConnectionManager}.\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   */\n  constructor(encodingParameters, preferredCodecs, options) {\n    super();\n\n    options = Object.assign({\n      audioContextFactory: isFirefox\n        ? require('../../webaudio/audiocontext')\n        : null,\n      PeerConnectionV2\n    }, options);\n\n    const audioContext = options.audioContextFactory\n      ? options.audioContextFactory.getOrCreate(this)\n      : null;\n\n    // NOTE(mroberts): If we're using an AudioContext, we don't need to specify\n    // `offerToReceiveAudio` in RTCOfferOptions.\n    const offerOptions = audioContext\n      ? { offerToReceiveVideo: true }\n      : { offerToReceiveAudio: true, offerToReceiveVideo: true };\n\n    Object.defineProperties(this, {\n      _audioContextFactory: {\n        value: options.audioContextFactory\n      },\n      _closedPeerConnectionIds: {\n        value: new Set()\n      },\n      _configuration: {\n        writable: true,\n        value: null\n      },\n      _configurationDeferred: {\n        writable: true,\n        value: util.defer()\n      },\n      _connectionState: {\n        value: 'new',\n        writable: true\n      },\n      _dummyAudioTrackSender: {\n        value: audioContext\n          ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext))\n          : null\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _iceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _dataTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _lastConnectionState: {\n        value: 'new',\n        writable: true\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _mediaTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _offerOptions: {\n        value: offerOptions\n      },\n      _peerConnections: {\n        value: new Map()\n      },\n      _preferredCodecs: {\n        value: preferredCodecs\n      },\n      _sessionTimeout: {\n        value: null,\n        writable: true\n      },\n      _PeerConnectionV2: {\n        value: options.PeerConnectionV2\n      }\n    });\n  }\n\n  setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast) {\n    this._peerConnections.forEach(pc => pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast));\n    this._preferredCodecs.video.forEach(cs => {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  }\n\n  /**\n   * A summarized RTCPeerConnectionState across all the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @property {RTCPeerConnectionState}\n   */\n  get connectionState() {\n    return this._connectionState;\n  }\n\n  /**\n   * A summarized RTCIceConnectionState across all the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @property {RTCIceConnectionState}\n   */\n  get iceConnectionState() {\n    return this._iceConnectionState;\n  }\n\n  /**\n   * Close the {@link PeerConnectionV2}s which are no longer relevant.\n   * @param {Array<object>} peerConnectionStates\n   * @returns {this}\n   */\n  _closeAbsentPeerConnections(peerConnectionStates) {\n    const peerConnectionIds = new Set(peerConnectionStates.map(peerConnectionState => peerConnectionState.id));\n    this._peerConnections.forEach(peerConnection => {\n      if (!peerConnectionIds.has(peerConnection.id)) {\n        peerConnection._close();\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Get the {@link PeerConnectionManager}'s configuration.\n   * @private\n   * @returns {Promise<object>}\n   */\n  _getConfiguration() {\n    return this._configurationDeferred.promise;\n  }\n\n  /**\n   * Get or create a {@link PeerConnectionV2}.\n   * @private\n   * @param {string} id\n   * @param {object} [configuration]\n   * @returns {PeerConnectionV2}\n   */\n  _getOrCreate(id, configuration) {\n    const self = this;\n    let peerConnection = this._peerConnections.get(id);\n    if (!peerConnection) {\n      const PeerConnectionV2 = this._PeerConnectionV2;\n\n      const options = Object.assign({\n        dummyAudioMediaStreamTrack: this._dummyAudioTrackSender\n          ? this._dummyAudioTrackSender.track\n          : null,\n        offerOptions: this._offerOptions\n      }, this._sessionTimeout ? {\n        sessionTimeout: this._sessionTimeout\n      } : {}, configuration);\n\n      try {\n        peerConnection = new PeerConnectionV2(id, this._encodingParameters, this._preferredCodecs, options);\n      } catch (e) {\n        throw new MediaConnectionError();\n      }\n\n      this._peerConnections.set(peerConnection.id, peerConnection);\n      peerConnection.on('candidates', this.queue.bind(this, 'candidates'));\n      peerConnection.on('description', this.queue.bind(this, 'description'));\n      peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));\n      peerConnection.on('stateChanged', function stateChanged(state) {\n        if (state === 'closed') {\n          peerConnection.removeListener('stateChanged', stateChanged);\n          self._dataTrackSenders.forEach(sender => peerConnection.removeDataTrackSender(sender));\n          self._mediaTrackSenders.forEach(sender => peerConnection.removeMediaTrackSender(sender));\n          self._peerConnections.delete(peerConnection.id);\n          self._closedPeerConnectionIds.add(peerConnection.id);\n          updateConnectionState(self);\n          updateIceConnectionState(self);\n        }\n      });\n      peerConnection.on('connectionStateChanged', () => updateConnectionState(this));\n      peerConnection.on('iceConnectionStateChanged', () => updateIceConnectionState(this));\n\n      this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);\n      this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);\n\n      updateIceConnectionState(this);\n    }\n    return peerConnection;\n  }\n\n  /**\n   * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.\n   * @returns {this}\n   */\n  close() {\n    this._peerConnections.forEach(peerConnection => {\n      peerConnection.close();\n    });\n    if (this._dummyAudioTrackSender) {\n      this._dummyAudioTrackSender.stop();\n    }\n    if (this._audioContextFactory) {\n      this._audioContextFactory.release(this);\n    }\n    updateIceConnectionState(this);\n    return this;\n  }\n\n  /**\n   * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.\n   * Then, create a new offer with the newly-created {@link PeerConnectionV2}.\n   * @return {Promise<this>}\n   */\n  createAndOffer() {\n    return this._getConfiguration().then(configuration => {\n      let id;\n      do {\n        id = util.makeUUID();\n      } while (this._peerConnections.has(id));\n\n      return this._getOrCreate(id, configuration);\n    }).then(peerConnection => {\n      return peerConnection.offer();\n    }).then(() => {\n      return this;\n    });\n  }\n\n  /**\n   * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all\n   * the {@link PeerConnectionV2}s.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  getTrackReceivers() {\n    return util.flatMap(this._peerConnections, peerConnection => peerConnection.getTrackReceivers());\n  }\n\n  /**\n   * Get the states of all {@link PeerConnectionV2}s.\n   * @returns {Array<object>}\n   */\n  getStates() {\n    const peerConnectionStates = [];\n    this._peerConnections.forEach(peerConnection => {\n      const peerConnectionState = peerConnection.getState();\n      if (peerConnectionState) {\n        peerConnectionStates.push(peerConnectionState);\n      }\n    });\n    return peerConnectionStates;\n  }\n\n  /**\n   * Set the {@link PeerConnectionManager}'s configuration.\n   * @param {object} configuration\n   * @returns {this}\n   */\n  setConfiguration(configuration) {\n    if (this._configuration) {\n      this._configurationDeferred = util.defer();\n      this._peerConnections.forEach(peerConnection => {\n        peerConnection.setConfiguration(configuration);\n      });\n    }\n    this._configuration = configuration;\n    this._configurationDeferred.resolve(configuration);\n    return this;\n  }\n\n  /**\n   * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  setIceReconnectTimeout(period) {\n    if (this._sessionTimeout === null) {\n      this._peerConnections.forEach(peerConnection => {\n        peerConnection.setIceReconnectTimeout(period);\n      });\n      this._sessionTimeout = period;\n    }\n    return this;\n  }\n\n  /**\n   * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders\n   * @returns {this}\n   */\n  setTrackSenders(trackSenders) {\n    const dataTrackSenders = new Set(trackSenders.filter(trackSender => trackSender.kind === 'data'));\n\n    const mediaTrackSenders = new Set(trackSenders\n      .filter(trackSender => trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video')));\n\n    const changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);\n    this._dataTrackSenders = dataTrackSenders;\n    this._mediaTrackSenders = mediaTrackSenders;\n    applyTrackSenderChanges(this, changes);\n\n    return this;\n  }\n\n  /**\n   * Update the {@link PeerConnectionManager}.\n   * @param {Array<object>} peerConnectionStates\n   * @param {boolean} [synced=false]\n   * @returns {Promise<this>}\n   */\n  update(peerConnectionStates, synced = false) {\n    if (synced) {\n      this._closeAbsentPeerConnections(peerConnectionStates);\n    }\n    return this._getConfiguration().then(configuration => {\n      return Promise.all(peerConnectionStates.map(peerConnectionState => {\n        if (this._closedPeerConnectionIds.has(peerConnectionState.id)) {\n          return null;\n        }\n        const peerConnection = this._getOrCreate(peerConnectionState.id, configuration);\n        return peerConnection.update(peerConnectionState);\n      }));\n    }).then(() => {\n      return this;\n    });\n  }\n\n  /**\n   * Get the {@link PeerConnectionManager}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n  getStats() {\n    const peerConnections = Array.from(this._peerConnections.values());\n    return Promise.all(peerConnections.map(peerConnection => peerConnection.getStats().then(response => [\n      peerConnection.id,\n      response\n    ]))).then(responses => new Map(responses));\n  }\n}\n\n/**\n * Create a dummy audio MediaStreamTrack with the given AudioContext.\n * @private\n * @param {AudioContext} audioContext\n * @return {MediaStreamTrack}\n */\nfunction createDummyAudioMediaStreamTrack(audioContext) {\n  const mediaStreamDestination = audioContext.createMediaStreamDestination();\n  return mediaStreamDestination.stream.getAudioTracks()[0];\n}\n\n/**\n * @event {PeerConnectionManager#candidates}\n * @param {object} candidates\n */\n\n/**\n * @event {PeerConnectionManager#connectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#description}\n * @param {object} description\n */\n\n/**\n * @event {PeerConnectionManager#iceConnectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#trackAdded}\n * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver\n */\n\n/**\n * Apply {@link TrackSenderChanges}.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {TrackSenderChanges} changes\n * @returns {void}\n */\nfunction applyTrackSenderChanges(peerConnectionManager, changes) {\n  if (changes.data.add.size\n    || changes.data.remove.size\n    || changes.media.add.size\n    || changes.media.remove.size) {\n    peerConnectionManager._peerConnections.forEach(peerConnection => {\n      changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);\n      changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);\n      changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);\n      changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);\n      if (changes.media.add.size\n        || changes.media.remove.size\n        || (changes.data.add.size && !peerConnection.isApplicationSectionNegotiated)) {\n        peerConnection.offer();\n      }\n    });\n  }\n}\n\n/**\n * @interface DataTrackSenderChanges\n * @property {Set<DataTrackSender>} add\n * @property {Set<DataTrackSender>} remove\n */\n\n/**\n * Get the {@Link DataTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @returns {DataTrackSenderChanges} changes\n */\nfunction getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {\n  const dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);\n  const dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);\n  return {\n    add: dataTrackSendersToAdd,\n    remove: dataTrackSendersToRemove\n  };\n}\n\n/**\n * @interface TrackSenderChanges\n * @property {DataTrackSenderChanges} data\n * @property {MediaTrackSenderChanges} media\n */\n\n/**\n * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {TrackSenderChanges} changes\n */\nfunction getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {\n  return {\n    data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),\n    media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)\n  };\n}\n\n/**\n * @interface MediaTrackSenderChanges\n * @property {Set<MediaTrackSender>} add\n * @property {Set<MediaTrackSender>} remove\n */\n\n/**\n * Get the {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {MediaTrackSenderChanges} changes\n */\nfunction getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {\n  const mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);\n  const mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);\n  return {\n    add: mediaTrackSendersToAdd,\n    remove: mediaTrackSendersToRemove\n  };\n}\n\n/**\n * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a \"rank\".\n */\nconst toRank = {\n  new: 0,\n  checking: 1,\n  connecting: 2,\n  connected: 3,\n  completed: 4,\n  disconnected: -1,\n  failed: -2,\n  closed: -3\n};\n\n/**\n * This object maps \"rank\" back to RTCIceConnectionState or RTCPeerConnectionState values.\n */\nlet fromRank;\n\n/**\n * `Object.keys` is not supported in older browsers, so we can't just\n * synchronously call it in this module; we need to defer invoking it until we\n * know we're in a modern environment (i.e., anything that supports WebRTC).\n * @returns {object} fromRank\n */\nfunction createFromRank() {\n  return Object.keys(toRank).reduce((fromRank, state) => {\n    return Object.assign(fromRank, { [toRank[state]]: state });\n  }, {});\n}\n\n/**\n * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.\n * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states\n * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary\n */\nfunction summarizeIceOrPeerConnectionStates(states) {\n  if (!states.length) {\n    return 'new';\n  }\n  fromRank = fromRank || createFromRank();\n  return states.reduce((state1, state2) => {\n    return fromRank[Math.max(toRank[state1], toRank[state2])];\n  });\n}\n\n/**\n * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an\n * \"iceConnectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateIceConnectionState(pcm) {\n  pcm._lastIceConnectionState = pcm.iceConnectionState;\n  pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(\n    [...pcm._peerConnections.values()].map(pcv2 => pcv2.iceConnectionState));\n  if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {\n    pcm.emit('iceConnectionStateChanged');\n  }\n}\n\n/**\n * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a\n * \"connectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateConnectionState(pcm) {\n  pcm._lastConnectionState = pcm.connectionState;\n  pcm._connectionState = summarizeIceOrPeerConnectionStates(\n    [...pcm._peerConnections.values()].map(pcv2 => pcv2.connectionState));\n  if (pcm.connectionState !== pcm._lastConnectionState) {\n    pcm.emit('connectionStateChanged');\n  }\n}\n\nmodule.exports = PeerConnectionManager;\n"]},"metadata":{},"sourceType":"script"}