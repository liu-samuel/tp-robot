{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar _a = require('../'),\n    difference = _a.difference,\n    flatMap = _a.flatMap;\n\nvar setSimulcastInMediaSection = require('./simulcast');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\n\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\n\n\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\n\n\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp(\"a=rtpmap:\" + pt + \" ([^/]+)\");\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\n\n\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp(\"^a=fmtp:\" + pt + \" (.+)$\", 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _a = __read(nvPair.split('='), 2),\n        name = _a[0],\n        value = _a[1];\n\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\n\n\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\n\n\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return \"m=\" + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp(\"m=\" + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp(\"a=\" + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\n\n\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0]; // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n\n  var matches = mLine.match(/([0-9]+)/g); // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n\n  if (!matches) {\n    return [];\n  } // Since only the Payload Types are needed, we discard the <port>.\n\n\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\n\n\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (_a) {\n    var codec = _a.codec;\n    return codec.toLowerCase();\n  });\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\n\n\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\n\n\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\n\n\nfunction setSimulcast(sdp, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n/**\n * Get the matching Payload Types in an m= section for a particular peer codec.\n * @param {Codec} peerCodec\n * @param {PT} peerPt\n * @param {Map<Codec, PT>} codecsToPts\n * @param {string} section\n * @param {string} peerSection\n * @returns {Array<PT>}\n */\n\n\nfunction getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingPts = codecsToPts.get(peerCodec) || [];\n\n  if (matchingPts.length <= 1) {\n    return matchingPts;\n  } // If there are no fmtp attributes for the codec in the peer m= section, then we\n  // cannot get a match in the  m= section. In that case, retain all matching Payload\n  // Types.\n\n\n  var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\n\n  if (!peerFmtpAttrs) {\n    return matchingPts;\n  } // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n\n\n  var matchingPt = matchingPts.find(function (pt) {\n    var fmtpAttrs = getFmtpAttributesForPt(pt, section);\n    return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {\n      return peerFmtpAttrs[attr] === fmtpAttrs[attr];\n    });\n  }); // If none of the matched Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the Payload Type that\n  // matches the peer fmtp attributes.\n\n  return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\n}\n/**\n * Filter codecs in an m= section based on its peer m= section from the other peer.\n * @param {string} section\n * @param {Map<string, string>} peerMidsToMediaSections\n * @param {Array<string>} codecsToRemove\n * @returns {string}\n */\n\n\nfunction filterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\n  // Do nothing if the m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(section)) {\n    return section;\n  } // Do nothing if the m= section does not have an equivalent remote m= section.\n\n\n  var mid = getMidForMediaSection(section);\n  var peerSection = mid && peerMidsToMediaSections.get(mid);\n\n  if (!peerSection) {\n    return section;\n  } // Construct a Map of the peer Payload Types to their codec names.\n\n\n  var peerPtToCodecs = createPtToCodecName(peerSection); // Construct a Map of the codec names to their Payload Types.\n\n  var codecsToPts = createCodecMapForMediaSection(section); // Maintain a list of non-rtx Payload Types to retain.\n\n  var pts = flatMap(Array.from(peerPtToCodecs), function (_a) {\n    var _b = __read(_a, 2),\n        peerPt = _b[0],\n        peerCodec = _b[1];\n\n    return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec) ? getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) : [];\n  }); // For each Payload Type that will be retained, retain their corresponding rtx\n  // Payload Type if present.\n\n  var rtxPts = codecsToPts.get('rtx') || []; // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n\n  pts = pts.concat(rtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\n    return fmtpAttrs && pts.includes(fmtpAttrs.apt);\n  })); // Filter out the below mentioned attribute lines in the m= section that do not\n  // belong to one of the Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n\n  var lines = section.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && pts.includes(parseInt(pt, 10));\n  }); // Filter the list of Payload Types in the first line of the m= section.\n\n  var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) {\n    return pts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\n}\n/**\n * Filter local codecs based on the remote SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\n\n\nfunction filterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return filterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @param revertForAll - when true simulcast will be reverted for all codecs. when false it will be reverted\n *  only for non-vp8 codecs.\n * @return {string} Updated SDP string\n */\n\n\nfunction revertSimulcast(localSdp, localSdpWithoutSimulcast, remoteSdp, revertForAll) {\n  if (revertForAll === void 0) {\n    revertForAll = false;\n  }\n\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n\n    if (!mid) {\n      return section;\n    }\n\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    var shouldRevertSimulcast = revertForAll || !isVP8ThePreferredCodec;\n    return shouldRevertSimulcast ? localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '') : section;\n  })).concat('').join('\\r\\n');\n}\n/**\n * Add or rewrite MSIDs for new m= sections in the given SDP with their corresponding\n * local MediaStreamTrack IDs. These can be different when previously removed MediaStreamTracks\n * are added back (or Track IDs may not be present in the SDPs at all once browsers implement\n * the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\n\n\nfunction addOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _a) {\n    var _b = __read(_a, 2),\n        kind = _b[0],\n        trackIds = _b[1];\n\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return addOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n/**\n * Add or rewrite MSIDs in the given SDP with their corresponding local MediaStreamTrack IDs.\n * These IDs need not be the same (or Track IDs may not be present in the SDPs at all once\n * browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\n\n\nfunction addOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n\n\n    var mid = getMidForMediaSection(mediaSection);\n\n    if (!mid) {\n      return mediaSection;\n    } // In case there is no Track ID for the given MID in the map, do nothing.\n\n\n    var trackId = midsToTrackIds.get(mid);\n\n    if (!trackId) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n\n\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n\n    if (!attributes) {\n      return mediaSection;\n    } // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n\n\n    var _a = __read(attributes.split(' '), 2),\n        msid = _a[0],\n        trackIdToRewrite = _a[1];\n\n    var msidRegex = new RegExp(\"msid:\" + msid + (trackIdToRewrite ? \" \" + trackIdToRewrite : '') + \"$\", 'gm');\n    return mediaSection.replace(msidRegex, \"msid:\" + msid + \" \" + trackId);\n  })).join('\\r\\n');\n}\n/**\n * Removes specified ssrc attributes from given sdp.\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\n\n\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(function (line) {\n    return !ssrcAttributesToRemove.find(function (srcAttribute) {\n      return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line);\n    });\n  }).join('\\r\\n');\n}\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\n\n\nfunction disableRtx(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    } // Create a map of codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(mediaSection); // Get the RTX payload types.\n\n    var rtxPts = codecsToPts.get('rtx'); // Do nothing if there are no RTX payload types.\n\n    if (!rtxPts) {\n      return mediaSection;\n    } // Remove the RTX payload types.\n\n\n    var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(function (rtxPt) {\n      return pts.delete(rtxPt);\n    }); // Get the RTX SSRC.\n\n    var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1]; // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n\n    var filterRegexes = [/^a=fmtp:.+ apt=.+$/, /^a=rtpmap:.+ rtx\\/.+$/, /^a=ssrc-group:.+$/].concat(rtxSSRC ? [new RegExp(\"^a=ssrc:\" + rtxSSRC + \" .+$\")] : []);\n    mediaSection = mediaSection.split('\\r\\n').filter(function (line) {\n      return filterRegexes.every(function (regex) {\n        return !regex.test(line);\n      });\n    }).join('\\r\\n'); // Reconstruct the m= section without the RTX payload types.\n\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\n\n\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_a) {\n    var _b = __read(_a, 2),\n        name = _b[0],\n        value = _b[1];\n\n    return name + \"=\" + value;\n  }).join(';');\n  return \"a=fmtp:\" + pt + \" \" + serializedFmtpAttrs;\n}\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\n\n\nfunction enableDtxForOpus(sdp, mids) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  mids = mids || mediaSections.filter(function (section) {\n    return /^m=audio/.test(section);\n  }).map(getMidForMediaSection);\n  return [session].concat(mediaSections.map(function (section) {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    } // Build a map codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(section); // Do nothing if a payload type for opus does not exist.\n\n    var opusPt = codecsToPts.get('opus');\n\n    if (!opusPt) {\n      return section;\n    } // If no fmtp attributes are found for opus, do nothing.\n\n\n    var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n\n    if (!opusFmtpAttrs) {\n      return section;\n    } // Add usedtx=1 to the a=fmtp: line for opus.\n\n\n    var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    var origOpusFmtpRegex = new RegExp(origOpusFmtpLine); // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n\n    var mid = getMidForMediaSection(section);\n\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n\n    var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\n\nexports.addOrRewriteNewTrackIds = addOrRewriteNewTrackIds;\nexports.addOrRewriteTrackIds = addOrRewriteTrackIds;\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.filterLocalCodecs = filterLocalCodecs;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcast = revertSimulcast;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;","map":{"version":3,"mappings":"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","names":["require","difference","flatMap","setSimulcastInMediaSection","ptToFixedBitrateAudioCodecName","createCodecMapForMediaSection","section","Array","from","createPtToCodecName","reduce","codecMap","pair","pt","codecName","pts","get","set","concat","Map","createMidToMediaSectionMap","sdp","getMediaSections","midsToMediaSections","mediaSection","mid","getMidForMediaSection","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","RegExp","matches","match","toLowerCase","getFmtpAttributesForPt","fmtpRegex","split","attrs","nvPair","name","value","isNaN","parseInt","midMatches","kind","direction","replace","slice","map","filter","kindPattern","directionPattern","test","mLine","getReorderedPayloadTypes","preferredCodecs","_a","codec","preferredPayloadTypes","remainingCodecs","keys","remainingPayloadTypes","setPayloadTypesInMediaSection","payloadTypes","lines","otherLines","join","setCodecPreferences","preferredAudioCodecs","preferredVideoCodecs","mediaSections","session","newSection","pcmaPayloadTypes","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","setSimulcast","trackIdsToAttributes","vp8PayloadTypes","hasVP8PayloadType","some","payloadType","getMatchingPayloadTypes","peerCodec","peerPt","codecsToPts","peerSection","matchingPts","length","peerFmtpAttrs","matchingPt","find","fmtpAttrs","Object","every","attr","filterCodecsInMediaSection","peerMidsToMediaSections","codecsToRemove","peerPtToCodecs","_b","includes","rtxPts","rtxPt","apt","ptMatches","line","orderedPts","filterLocalCodecs","localSdp","remoteSdp","localMediaSections","localSession","remoteMidsToMediaSections","localSection","revertSimulcast","localSdpWithoutSimulcast","revertForAll","remoteMidToMediaSections","localMidToMediaSectionsWithoutSimulcast","remoteSection","remotePtToCodecs","remotePayloadTypes","isVP8ThePreferredCodec","shouldRevertSimulcast","addOrRewriteNewTrackIds","activeMidsToTrackIds","trackIdsByKind","newMidsToTrackIds","midsToTrackIds","trackIds","newMids","forEach","i","addOrRewriteTrackIds","trackId","attributes","msid","trackIdToRewrite","msidRegex","removeSSRCAttributes","ssrcAttributesToRemove","srcAttribute","disableRtx","delete","rtxSSRCMatches","rtxSSRC","filterRegexes","regex","generateFmtpLineFromPtAndAttributes","serializedFmtpAttrs","entries","enableDtxForOpus","mids","opusPt","opusFmtpAttrs","origOpusFmtpLine","origOpusFmtpRegex","usedtx","opusFmtpLineWithDtx","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/util/sdp/index.js"],"sourcesContent":["'use strict';\n\nconst { difference, flatMap } = require('../');\nconst setSimulcastInMediaSection = require('./simulcast');\n\nconst ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce((codecMap, pair) => {\n    const pt = pair[0];\n    const codecName = pair[1];\n    const pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce((midsToMediaSections, mediaSection) => {\n    const mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce((ptToCodecName, pt) => {\n    const rtpmapPattern = new RegExp(`a=rtpmap:${pt} ([^/]+)`);\n    const matches = mediaSection.match(rtpmapPattern);\n    const codecName = matches\n      ? matches[1].toLowerCase()\n      : ptToFixedBitrateAudioCodecName[pt]\n        ? ptToFixedBitrateAudioCodecName[pt].toLowerCase()\n        : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  const fmtpRegex = new RegExp(`^a=fmtp:${pt} (.+)$`, 'm');\n  const matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce((attrs, nvPair) => {\n    const [name, value] = nvPair.split('=');\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  const midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(mediaSection => `m=${mediaSection}`).filter(mediaSection => {\n    const kindPattern = new RegExp(`m=${kind || '.*'}`, 'gm');\n    const directionPattern = new RegExp(`a=${direction || '.*'}`, 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  const mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n  const matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the Payload Types are needed, we discard the <port>.\n  return matches.slice(1).map(match => parseInt(match, 10));\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(({ codec }) => codec.toLowerCase());\n  const preferredPayloadTypes = flatMap(preferredCodecs, codecName => codecMap.get(codecName) || []);\n  const remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  const remainingPayloadTypes = flatMap(remainingCodecs, codecName => codecMap.get(codecName));\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  const lines = section.split('\\r\\n');\n  let mLine = lines[0];\n  const otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(section => {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    const kind = section.match(/^m=(audio|video)/)[1];\n    const codecMap = createCodecMapForMediaSection(section);\n    const preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    const payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    const newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    const pcmaPayloadTypes = codecMap.get('pcma') || [];\n    const pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    const fixedBitratePayloadTypes = kind === 'audio'\n      ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes))\n      : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0])\n      ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '')\n      : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\nfunction setSimulcast(sdp, trackIdsToAttributes) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(section => {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    const codecMap = createCodecMapForMediaSection(section);\n    const payloadTypes = getPayloadTypesInMediaSection(section);\n    const vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n\n    const hasVP8PayloadType = payloadTypes.some(payloadType => vp8PayloadTypes.has(payloadType));\n    return hasVP8PayloadType\n      ? setSimulcastInMediaSection(section, trackIdsToAttributes)\n      : section;\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Get the matching Payload Types in an m= section for a particular peer codec.\n * @param {Codec} peerCodec\n * @param {PT} peerPt\n * @param {Map<Codec, PT>} codecsToPts\n * @param {string} section\n * @param {string} peerSection\n * @returns {Array<PT>}\n */\nfunction getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  const matchingPts = codecsToPts.get(peerCodec) || [];\n  if (matchingPts.length <= 1) {\n    return matchingPts;\n  }\n\n  // If there are no fmtp attributes for the codec in the peer m= section, then we\n  // cannot get a match in the  m= section. In that case, retain all matching Payload\n  // Types.\n  const peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\n  if (!peerFmtpAttrs) {\n    return matchingPts;\n  }\n\n  // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n  const matchingPt = matchingPts.find(pt => {\n    const fmtpAttrs = getFmtpAttributesForPt(pt, section);\n    return fmtpAttrs && Object.keys(peerFmtpAttrs).every(attr => {\n      return peerFmtpAttrs[attr] === fmtpAttrs[attr];\n    });\n  });\n\n  // If none of the matched Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the Payload Type that\n  // matches the peer fmtp attributes.\n  return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\n}\n\n/**\n * Filter codecs in an m= section based on its peer m= section from the other peer.\n * @param {string} section\n * @param {Map<string, string>} peerMidsToMediaSections\n * @param {Array<string>} codecsToRemove\n * @returns {string}\n */\nfunction filterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\n  // Do nothing if the m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(section)) {\n    return section;\n  }\n\n  // Do nothing if the m= section does not have an equivalent remote m= section.\n  const mid = getMidForMediaSection(section);\n  const peerSection = mid && peerMidsToMediaSections.get(mid);\n  if (!peerSection) {\n    return section;\n  }\n\n  // Construct a Map of the peer Payload Types to their codec names.\n  const peerPtToCodecs = createPtToCodecName(peerSection);\n  // Construct a Map of the codec names to their Payload Types.\n  const codecsToPts = createCodecMapForMediaSection(section);\n  // Maintain a list of non-rtx Payload Types to retain.\n  let pts = flatMap(Array.from(peerPtToCodecs), ([peerPt, peerCodec]) =>\n    peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec)\n      ? getMatchingPayloadTypes(\n        peerCodec,\n        peerPt,\n        codecsToPts,\n        section,\n        peerSection)\n      : []);\n\n  // For each Payload Type that will be retained, retain their corresponding rtx\n  // Payload Type if present.\n  const rtxPts = codecsToPts.get('rtx') || [];\n  // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n  pts = pts.concat(rtxPts.filter(rtxPt => {\n    const fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\n    return fmtpAttrs && pts.includes(fmtpAttrs.apt);\n  }));\n\n  // Filter out the below mentioned attribute lines in the m= section that do not\n  // belong to one of the Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n  const lines = section.split('\\r\\n').filter(line => {\n    const ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    const pt = ptMatches && ptMatches[2];\n    return !ptMatches || (pt && pts.includes(parseInt(pt, 10)));\n  });\n\n  // Filter the list of Payload Types in the first line of the m= section.\n  const orderedPts = getPayloadTypesInMediaSection(section).filter(pt => pts.includes(pt));\n  return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\n}\n\n/**\n * Filter local codecs based on the remote SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\nfunction filterLocalCodecs(localSdp, remoteSdp) {\n  const localMediaSections = getMediaSections(localSdp);\n  const localSession = localSdp.split('\\r\\nm=')[0];\n  const remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(localSection => {\n    return filterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @param revertForAll - when true simulcast will be reverted for all codecs. when false it will be reverted\n *  only for non-vp8 codecs.\n * @return {string} Updated SDP string\n */\nfunction revertSimulcast(localSdp, localSdpWithoutSimulcast, remoteSdp, revertForAll = false) {\n  const remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  const localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  const mediaSections = getMediaSections(localSdp);\n  const session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(section => {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    const midMatches = section.match(/^a=mid:(.+)$/m);\n    const mid = midMatches && midMatches[1];\n    if (!mid) {\n      return section;\n    }\n\n    const remoteSection = remoteMidToMediaSections.get(mid);\n    const remotePtToCodecs = createPtToCodecName(remoteSection);\n    const remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n\n    const isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    const shouldRevertSimulcast = revertForAll || !isVP8ThePreferredCodec;\n    return shouldRevertSimulcast ? localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '') : section;\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Add or rewrite MSIDs for new m= sections in the given SDP with their corresponding\n * local MediaStreamTrack IDs. These can be different when previously removed MediaStreamTracks\n * are added back (or Track IDs may not be present in the SDPs at all once browsers implement\n * the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\nfunction addOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  const newMidsToTrackIds = Array.from(trackIdsByKind).reduce((midsToTrackIds, [kind, trackIds]) => {\n    const mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    const newMids = mediaSections.map(getMidForMediaSection).filter(mid => !activeMidsToTrackIds.has(mid));\n    newMids.forEach((mid, i) => midsToTrackIds.set(mid, trackIds[i]));\n    return midsToTrackIds;\n  }, new Map());\n  return addOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n\n/**\n * Add or rewrite MSIDs in the given SDP with their corresponding local MediaStreamTrack IDs.\n * These IDs need not be the same (or Track IDs may not be present in the SDPs at all once\n * browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\nfunction addOrRewriteTrackIds(sdp, midsToTrackIds) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSection => {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n    const mid = getMidForMediaSection(mediaSection);\n    if (!mid) {\n      return mediaSection;\n    }\n    // In case there is no Track ID for the given MID in the map, do nothing.\n    const trackId = midsToTrackIds.get(mid);\n    if (!trackId) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n    const attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n    if (!attributes) {\n      return mediaSection;\n    }\n    // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n    const [msid, trackIdToRewrite] = attributes.split(' ');\n    const msidRegex = new RegExp(`msid:${msid}${trackIdToRewrite ? ` ${trackIdToRewrite}` : ''}$`, 'gm');\n    return mediaSection.replace(msidRegex, `msid:${msid} ${trackId}`);\n  })).join('\\r\\n');\n}\n\n/**\n * Removes specified ssrc attributes from given sdp.\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(line =>\n    !ssrcAttributesToRemove.find(srcAttribute => new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line))\n  ).join('\\r\\n');\n}\n\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\nfunction disableRtx(sdp) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSection => {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    }\n\n    // Create a map of codecs to payload types.\n    const codecsToPts = createCodecMapForMediaSection(mediaSection);\n    // Get the RTX payload types.\n    const rtxPts = codecsToPts.get('rtx');\n\n    // Do nothing if there are no RTX payload types.\n    if (!rtxPts) {\n      return mediaSection;\n    }\n\n    // Remove the RTX payload types.\n    const pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(rtxPt => pts.delete(rtxPt));\n\n    // Get the RTX SSRC.\n    const rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    const rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];\n\n    // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n    const filterRegexes = [\n      /^a=fmtp:.+ apt=.+$/,\n      /^a=rtpmap:.+ rtx\\/.+$/,\n      /^a=ssrc-group:.+$/\n    ].concat(rtxSSRC\n      ? [new RegExp(`^a=ssrc:${rtxSSRC} .+$`)]\n      : []);\n\n    mediaSection = mediaSection.split('\\r\\n')\n      .filter(line => filterRegexes.every(regex => !regex.test(line)))\n      .join('\\r\\n');\n\n    // Reconstruct the m= section without the RTX payload types.\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  const serializedFmtpAttrs = Object.entries(fmtpAttrs).map(([name, value]) => {\n    return `${name}=${value}`;\n  }).join(';');\n  return `a=fmtp:${pt} ${serializedFmtpAttrs}`;\n}\n\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\nfunction enableDtxForOpus(sdp, mids) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n\n  mids = mids || mediaSections\n    .filter(section => /^m=audio/.test(section))\n    .map(getMidForMediaSection);\n\n  return [session].concat(mediaSections.map(section => {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    }\n\n    // Build a map codecs to payload types.\n    const codecsToPts = createCodecMapForMediaSection(section);\n\n    // Do nothing if a payload type for opus does not exist.\n    const opusPt = codecsToPts.get('opus');\n    if (!opusPt) {\n      return section;\n    }\n\n    // If no fmtp attributes are found for opus, do nothing.\n    const opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n    if (!opusFmtpAttrs) {\n      return section;\n    }\n\n    // Add usedtx=1 to the a=fmtp: line for opus.\n    const origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    const origOpusFmtpRegex = new RegExp(origOpusFmtpLine);\n\n    // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n    const mid = getMidForMediaSection(section);\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n\n    const opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\n\nexports.addOrRewriteNewTrackIds = addOrRewriteNewTrackIds;\nexports.addOrRewriteTrackIds = addOrRewriteTrackIds;\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.filterLocalCodecs = filterLocalCodecs;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcast = revertSimulcast;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\n"]},"metadata":{},"sourceType":"script"}