{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar MediaTrack = require('./mediatrack');\n\nvar VideoProcessorEventObserver = require('./videoprocessoreventobserver');\n\nvar DEFAULT_FRAME_RATE = require('../../util/constants').DEFAULT_FRAME_RATE;\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\n\n\nvar VideoTrack =\n/** @class */\nfunction (_super) {\n  __extends(VideoTrack, _super);\n  /**\n   * Construct a {@link VideoTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n\n\n  function VideoTrack(mediaTrackTransceiver, options) {\n    var _this = _super.call(this, mediaTrackTransceiver, options) || this;\n\n    Object.defineProperties(_this, {\n      _captureTimeoutId: {\n        value: null,\n        writable: true\n      },\n      _isCapturing: {\n        value: false,\n        writable: true\n      },\n      _inputFrame: {\n        value: null,\n        writable: true\n      },\n      _outputFrame: {\n        value: null,\n        writable: true\n      },\n      _processorEventObserver: {\n        value: null,\n        writable: true\n      },\n      _unmuteHandler: {\n        value: null,\n        writable: true\n      },\n      dimensions: {\n        enumerable: true,\n        value: {\n          width: null,\n          height: null\n        }\n      },\n      processor: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n    _this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(_this._log);\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._checkIfCanCaptureFrames = function (isPublishing) {\n    if (isPublishing === void 0) {\n      isPublishing = false;\n    }\n\n    var canCaptureFrames = true;\n    var message = '';\n    var _a = this.mediaStreamTrack,\n        enabled = _a.enabled,\n        readyState = _a.readyState;\n\n    if (!enabled) {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is disabled';\n    }\n\n    if (readyState === 'ended') {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is ended';\n    }\n\n    if (!this.processor) {\n      canCaptureFrames = false;\n      message = 'VideoProcessor not detected.';\n    }\n\n    if (!this._attachments.size && !isPublishing) {\n      canCaptureFrames = false;\n      message = 'VideoTrack is not publishing and there is no attached element.';\n    }\n\n    if (message) {\n      this._log.debug(message);\n    }\n\n    return {\n      canCaptureFrames: canCaptureFrames,\n      message: message\n    };\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._captureFrames = function () {\n    var _this = this;\n\n    if (this._isCapturing) {\n      this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n\n      return;\n    }\n\n    if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n      this._isCapturing = false;\n\n      this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n\n      return;\n    }\n\n    this._isCapturing = true;\n\n    this._processorEventObserver.emit('start');\n\n    this._log.debug('Start capturing frames');\n\n    var startTime = Date.now();\n    var processFramePeriodMs;\n\n    this._dummyEl.play().then(function () {\n      var captureFrame = function captureFrame(cb) {\n        clearTimeout(_this._captureTimeoutId);\n\n        var _a = _this.mediaStreamTrack.getSettings().frameRate,\n            frameRate = _a === void 0 ? DEFAULT_FRAME_RATE : _a;\n\n        var capturePeriodMs = Math.floor(1000 / frameRate);\n        var delay = capturePeriodMs - processFramePeriodMs;\n\n        if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n          delay = 0;\n        }\n\n        _this._captureTimeoutId = setTimeout(cb, delay);\n      };\n\n      var process = function process() {\n        var checkResult = _this._checkIfCanCaptureFrames();\n\n        if (!checkResult.canCaptureFrames) {\n          _this._isCapturing = false;\n\n          _this._processorEventObserver.emit('stop', checkResult.message);\n\n          _this._log.debug('Cannot capture frames. Stopping capturing frames.');\n\n          return;\n        }\n\n        startTime = Date.now();\n\n        var _a = _this.mediaStreamTrack.getSettings(),\n            _b = _a.width,\n            width = _b === void 0 ? 0 : _b,\n            _c = _a.height,\n            height = _c === void 0 ? 0 : _c; // Setting the canvas' dimension triggers a redraw.\n        // Only set it if it has changed.\n\n\n        if (_this._inputFrame.width !== width) {\n          _this._inputFrame.width = width;\n          _this._inputFrame.height = height;\n\n          if (_this._outputFrame) {\n            _this._outputFrame.width = width;\n            _this._outputFrame.height = height;\n          }\n        }\n\n        _this._inputFrame.getContext('2d').drawImage(_this._dummyEl, 0, 0, width, height);\n\n        var result = null;\n\n        try {\n          result = _this.processor.processFrame(_this._inputFrame, _this._outputFrame);\n        } catch (ex) {\n          _this._log.debug('Exception detected after calling processFrame.', ex);\n        }\n\n        (result instanceof Promise ? result : Promise.resolve(result)).then(function () {\n          if (_this._outputFrame) {\n            _this.processedTrack.requestFrame();\n\n            _this._processorEventObserver.emit('stats');\n          }\n        }).finally(function () {\n          processFramePeriodMs = Date.now() - startTime;\n          captureFrame(process);\n        });\n      };\n\n      captureFrame(process);\n    }).catch(function (error) {\n      return _this._log.error('Video element cannot be played', {\n        error: error,\n        track: _this\n      });\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._initialize = function () {\n    var _this = this;\n\n    _super.prototype._initialize.call(this);\n\n    if (this._dummyEl) {\n      this._dummyEl.onloadedmetadata = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n        }\n      };\n\n      this._dummyEl.onresize = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n\n          if (_this.isStarted) {\n            _this._log.debug('Dimensions changed:', _this.dimensions);\n\n            _this.emit(VideoTrack.DIMENSIONS_CHANGED, _this);\n          }\n        }\n      };\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._restartProcessor = function () {\n    var processor = this.processor;\n\n    if (processor) {\n      this.removeProcessor(processor);\n      this.addProcessor(processor);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._start = function (dummyEl) {\n    this.dimensions.width = dummyEl.videoWidth;\n    this.dimensions.height = dummyEl.videoHeight;\n\n    this._log.debug('Dimensions:', this.dimensions);\n\n    this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n    return _super.prototype._start.call(this, dummyEl);\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n   * });\n   */\n\n\n  VideoTrack.prototype.addProcessor = function (processor) {\n    var _this = this;\n\n    if (typeof OffscreenCanvas !== 'function') {\n      return this._log.warn('Adding a VideoProcessor is not supported in this browser.');\n    }\n\n    if (!processor || typeof processor.processFrame !== 'function') {\n      throw new Error('Received an invalid VideoProcessor from addProcessor.');\n    }\n\n    if (this.processor) {\n      throw new Error('A VideoProcessor has already been added.');\n    }\n\n    if (!this._dummyEl) {\n      throw new Error('VideoTrack has not been initialized.');\n    }\n\n    this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n\n    if (!this._unmuteHandler) {\n      this._unmuteHandler = function () {\n        _this._log.debug('mediaStreamTrack unmuted'); // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n        // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n        // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n\n\n        if (_this.processedTrack.muted) {\n          _this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n\n          _this._restartProcessor();\n        }\n      };\n\n      this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n    }\n\n    var _a = this.mediaStreamTrack.getSettings(),\n        _b = _a.width,\n        width = _b === void 0 ? 0 : _b,\n        _c = _a.height,\n        height = _c === void 0 ? 0 : _c,\n        _d = _a.frameRate,\n        frameRate = _d === void 0 ? DEFAULT_FRAME_RATE : _d;\n\n    this._inputFrame = new OffscreenCanvas(width, height);\n    this._outputFrame = document.createElement('canvas');\n    this._outputFrame.width = width;\n    this._outputFrame.height = height;\n    this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];\n    this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n    this.processor = processor;\n\n    this._processorEventObserver.emit('add', {\n      processor: processor,\n      captureHeight: height,\n      captureWidth: width,\n      inputFrameRate: frameRate,\n      isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')\n    });\n\n    this._updateElementsMediaStreamTrack();\n\n    this._captureFrames();\n\n    return this;\n  };\n  /**\n   * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n   *\n   * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n   * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n   *\n   * @returns {HTMLVideoElement} videoElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const videoElement = videoTrack.attach();\n   *   document.body.appendChild(videoElement);\n   * });\n  */\n\n  /**\n  * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n  * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n  *\n  * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n  * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n  * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n  * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n  * MediaStreamTracks of the same kind on the MediaStream, this method removes\n  * them.\n  *\n  * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * const Video = require('twilio-video');\n  *\n  * const videoElement = document.createElement('video');\n  * document.body.appendChild(videoElement);\n  *\n  * Video.createLocalVideoTrack().then(function(videoTrack) {\n  *   videoTrack.attach(videoElement);\n  * });\n  */\n\n  /**\n  * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n  * <code>document.querySelector</code>. The HTMLMediaElement could be an\n  * HTMLAudioElement or an HTMLVideoElement.\n  *\n  * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n  * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n  * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n  * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n  * MediaStreamTracks of the same kind on the MediaStream, this method removes\n  * them.\n  *\n  * @param {string} selector - A query selector for the HTMLMediaElement to\n  *   attach to\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * const Video = require('twilio-video');\n  *\n  * const videoElement = document.createElement('video');\n  * videoElement.id = 'my-video-element';\n  * document.body.appendChild(videoElement);\n  *\n  * Video.createLocalVideoTrack().then(function(track) {\n  *   track.attach('#my-video-element');\n  * });\n  */\n\n\n  VideoTrack.prototype.attach = function () {\n    var result = _super.prototype.attach.apply(this, arguments);\n\n    if (this.processor) {\n      this._captureFrames();\n    }\n\n    return result;\n  };\n  /**\n   * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n   * @returns {Array<HTMLMediaElement>} mediaElements\n   * @example\n   * const mediaElements = videoTrack.detach();\n   * mediaElements.forEach(mediaElement => mediaElement.remove());\n  */\n\n  /**\n  * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n  * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n  *   which the {@link VideoTrack} is attached\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * const videoElement = document.getElementById('my-video-element');\n  * videoTrack.detach(videoElement).remove();\n  */\n\n  /**\n  * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n  *   specified by <code>document.querySelector</code>.\n  * @param {string} selector - The query selector of HTMLMediaElement to which\n  *    the {@link VideoTrack} is attached\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * videoTrack.detach('#my-video-element').remove();\n  */\n\n\n  VideoTrack.prototype.detach = function () {\n    return _super.prototype.detach.apply(this, arguments);\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const grayScaleProcessor = new GrayScaleProcessor(100);\n   *   videoTrack.addProcessor(grayScaleProcessor);\n   *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n   * });\n   */\n\n\n  VideoTrack.prototype.removeProcessor = function (processor) {\n    if (!processor) {\n      throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n    }\n\n    if (!this.processor) {\n      throw new Error('No existing VideoProcessor detected.');\n    }\n\n    if (processor !== this.processor) {\n      throw new Error('The provided VideoProcessor is different than the existing one.');\n    }\n\n    this._processorEventObserver.emit('remove');\n\n    this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n\n    clearTimeout(this._captureTimeoutId);\n    this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n    this._unmuteHandler = null;\n    this._isCapturing = false;\n    this.processor = null;\n    this.processedTrack = null;\n\n    this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);\n\n    this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);\n\n    this._inputFrame = null;\n    this._outputFrame = null;\n\n    this._updateElementsMediaStreamTrack();\n\n    return this;\n  };\n\n  return VideoTrack;\n}(MediaTrack);\n\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\n\nfunction dimensionsChanged(track, elem) {\n  return track.dimensions.width !== elem.videoWidth || track.dimensions.height !== elem.videoHeight;\n}\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\n\n\nmodule.exports = VideoTrack;","map":{"version":3,"mappings":"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","names":["MediaTrack","require","VideoProcessorEventObserver","DEFAULT_FRAME_RATE","__extends","mediaTrackTransceiver","options","_super","Object","defineProperties","_this","_captureTimeoutId","value","writable","_isCapturing","_inputFrame","_outputFrame","_processorEventObserver","_unmuteHandler","dimensions","enumerable","width","height","processor","_log","VideoTrack","isPublishing","canCaptureFrames","message","mediaStreamTrack","enabled","readyState","_attachments","size","debug","_checkIfCanCaptureFrames","emit","startTime","Date","now","processFramePeriodMs","_dummyEl","play","then","captureFrame","clearTimeout","getSettings","frameRate","_a","capturePeriodMs","Math","floor","delay","setTimeout","cb","process","checkResult","_b","_c","getContext","drawImage","result","processFrame","ex","Promise","resolve","processedTrack","requestFrame","finally","catch","error","track","_initialize","call","onloadedmetadata","dimensionsChanged","videoWidth","videoHeight","onresize","isStarted","DIMENSIONS_CHANGED","removeProcessor","addProcessor","dummyEl","_start","OffscreenCanvas","warn","Error","muted","_restartProcessor","addEventListener","_d","document","createElement","captureStream","getTracks","captureHeight","captureWidth","inputFrameRate","isRemoteVideoTrack","toString","includes","_updateElementsMediaStreamTrack","_captureFrames","attach","apply","arguments","detach","removeEventListener","clearRect","elem","module","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/media/track/videotrack.js"],"sourcesContent":["'use strict';\n\nconst MediaTrack = require('./mediatrack');\nconst VideoProcessorEventObserver = require('./videoprocessoreventobserver');\nconst { DEFAULT_FRAME_RATE } = require('../../util/constants');\n\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\nclass VideoTrack extends MediaTrack {\n  /**\n   * Construct a {@link VideoTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  constructor(mediaTrackTransceiver, options) {\n    super(mediaTrackTransceiver, options);\n    Object.defineProperties(this, {\n      _captureTimeoutId: {\n        value: null,\n        writable: true\n      },\n      _isCapturing: {\n        value: false,\n        writable: true\n      },\n      _inputFrame: {\n        value: null,\n        writable: true\n      },\n      _outputFrame: {\n        value: null,\n        writable: true\n      },\n      _processorEventObserver: {\n        value: null,\n        writable: true,\n      },\n      _unmuteHandler: {\n        value: null,\n        writable: true\n      },\n      dimensions: {\n        enumerable: true,\n        value: {\n          width: null,\n          height: null\n        }\n      },\n      processor: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(this._log);\n\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _checkIfCanCaptureFrames(isPublishing = false) {\n    let canCaptureFrames = true;\n    let message = '';\n    const { enabled, readyState } = this.mediaStreamTrack;\n\n    if (!enabled) {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is disabled';\n    }\n    if (readyState === 'ended') {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is ended';\n    }\n    if (!this.processor) {\n      canCaptureFrames = false;\n      message = 'VideoProcessor not detected.';\n    }\n    if (!this._attachments.size && !isPublishing) {\n      canCaptureFrames = false;\n      message = 'VideoTrack is not publishing and there is no attached element.';\n    }\n\n    if (message) {\n      this._log.debug(message);\n    }\n    return { canCaptureFrames, message };\n  }\n\n  /**\n   * @private\n   */\n  _captureFrames() {\n    if (this._isCapturing) {\n      this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n      return;\n    }\n    if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n      this._isCapturing = false;\n      this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n      return;\n    }\n    this._isCapturing = true;\n    this._processorEventObserver.emit('start');\n    this._log.debug('Start capturing frames');\n\n    let startTime = Date.now();\n    let processFramePeriodMs;\n\n    this._dummyEl.play().then(() => {\n      const captureFrame = cb => {\n        clearTimeout(this._captureTimeoutId);\n        const { frameRate = DEFAULT_FRAME_RATE } = this.mediaStreamTrack.getSettings();\n        const capturePeriodMs = Math.floor(1000 / frameRate);\n        let delay = capturePeriodMs - processFramePeriodMs;\n        if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n          delay = 0;\n        }\n        this._captureTimeoutId = setTimeout(cb, delay);\n      };\n      const process = () => {\n        const checkResult = this._checkIfCanCaptureFrames();\n        if (!checkResult.canCaptureFrames) {\n          this._isCapturing = false;\n          this._processorEventObserver.emit('stop', checkResult.message);\n          this._log.debug('Cannot capture frames. Stopping capturing frames.');\n          return;\n        }\n        startTime = Date.now();\n\n        const { width = 0, height = 0 } = this.mediaStreamTrack.getSettings();\n        // Setting the canvas' dimension triggers a redraw.\n        // Only set it if it has changed.\n        if (this._inputFrame.width !== width) {\n          this._inputFrame.width = width;\n          this._inputFrame.height = height;\n\n          if (this._outputFrame) {\n            this._outputFrame.width = width;\n            this._outputFrame.height = height;\n          }\n        }\n        this._inputFrame.getContext('2d').drawImage(this._dummyEl, 0, 0, width, height);\n\n        let result = null;\n        try {\n          result = this.processor.processFrame(this._inputFrame, this._outputFrame);\n        } catch (ex) {\n          this._log.debug('Exception detected after calling processFrame.', ex);\n        }\n        ((result instanceof Promise) ? result : Promise.resolve(result))\n          .then(() => {\n            if (this._outputFrame) {\n              this.processedTrack.requestFrame();\n              this._processorEventObserver.emit('stats');\n            }\n          })\n          .finally(() => {\n            processFramePeriodMs = Date.now() - startTime;\n            captureFrame(process);\n          });\n      };\n      captureFrame(process);\n    }).catch(error => this._log.error('Video element cannot be played', { error, track: this }));\n  }\n\n  /**\n   * @private\n   */\n  _initialize() {\n    super._initialize();\n    if (this._dummyEl) {\n      this._dummyEl.onloadedmetadata = () => {\n        if (dimensionsChanged(this, this._dummyEl)) {\n          this.dimensions.width = this._dummyEl.videoWidth;\n          this.dimensions.height = this._dummyEl.videoHeight;\n        }\n      };\n      this._dummyEl.onresize = () => {\n        if (dimensionsChanged(this, this._dummyEl)) {\n          this.dimensions.width = this._dummyEl.videoWidth;\n          this.dimensions.height = this._dummyEl.videoHeight;\n          if (this.isStarted) {\n            this._log.debug('Dimensions changed:', this.dimensions);\n            this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n          }\n        }\n      };\n    }\n  }\n\n  /**\n   * @private\n   */\n  _restartProcessor() {\n    const processor = this.processor;\n    if (processor) {\n      this.removeProcessor(processor);\n      this.addProcessor(processor);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _start(dummyEl) {\n    this.dimensions.width = dummyEl.videoWidth;\n    this.dimensions.height = dummyEl.videoHeight;\n\n    this._log.debug('Dimensions:', this.dimensions);\n    this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n    return super._start.call(this, dummyEl);\n  }\n\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n   * });\n   */\n  addProcessor(processor) {\n    if (typeof OffscreenCanvas !== 'function') {\n      return this._log.warn('Adding a VideoProcessor is not supported in this browser.');\n    }\n    if (!processor || typeof processor.processFrame !== 'function') {\n      throw new Error('Received an invalid VideoProcessor from addProcessor.');\n    }\n    if (this.processor) {\n      throw new Error('A VideoProcessor has already been added.');\n    }\n    if (!this._dummyEl) {\n      throw new Error('VideoTrack has not been initialized.');\n    }\n\n    this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n\n    if (!this._unmuteHandler) {\n      this._unmuteHandler = () => {\n        this._log.debug('mediaStreamTrack unmuted');\n        // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n        // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n        // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n        if (this.processedTrack.muted) {\n          this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n          this._restartProcessor();\n        }\n      };\n      this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n    }\n\n    const { width = 0, height = 0, frameRate = DEFAULT_FRAME_RATE } = this.mediaStreamTrack.getSettings();\n    this._inputFrame = new OffscreenCanvas(width, height);\n    this._outputFrame = document.createElement('canvas');\n    this._outputFrame.width = width;\n    this._outputFrame.height = height;\n\n    this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];\n    this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n    this.processor = processor;\n\n    this._processorEventObserver.emit('add', {\n      processor,\n      captureHeight: height,\n      captureWidth: width,\n      inputFrameRate: frameRate,\n      isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')\n    });\n    this._updateElementsMediaStreamTrack();\n    this._captureFrames();\n    return this;\n  }\n\n  /**\n   * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n   *\n   * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n   * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n   *\n   * @returns {HTMLVideoElement} videoElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const videoElement = videoTrack.attach();\n   *   document.body.appendChild(videoElement);\n   * });\n  *//**\n   * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n   * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n   *\n   * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n   * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n   * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n   * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n   * MediaStreamTracks of the same kind on the MediaStream, this method removes\n   * them.\n   *\n   * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * const videoElement = document.createElement('video');\n   * document.body.appendChild(videoElement);\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.attach(videoElement);\n   * });\n  *//**\n   * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n   * <code>document.querySelector</code>. The HTMLMediaElement could be an\n   * HTMLAudioElement or an HTMLVideoElement.\n   *\n   * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n   * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n   * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n   * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n   * MediaStreamTracks of the same kind on the MediaStream, this method removes\n   * them.\n   *\n   * @param {string} selector - A query selector for the HTMLMediaElement to\n   *   attach to\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * const videoElement = document.createElement('video');\n   * videoElement.id = 'my-video-element';\n   * document.body.appendChild(videoElement);\n   *\n   * Video.createLocalVideoTrack().then(function(track) {\n   *   track.attach('#my-video-element');\n   * });\n   */\n  attach() {\n    const result = super.attach.apply(this, arguments);\n    if (this.processor) {\n      this._captureFrames();\n    }\n    return result;\n  }\n\n  /**\n   * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n   * @returns {Array<HTMLMediaElement>} mediaElements\n   * @example\n   * const mediaElements = videoTrack.detach();\n   * mediaElements.forEach(mediaElement => mediaElement.remove());\n  *//**\n   * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n   * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n   *   which the {@link VideoTrack} is attached\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const videoElement = document.getElementById('my-video-element');\n   * videoTrack.detach(videoElement).remove();\n  *//**\n   * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n   *   specified by <code>document.querySelector</code>.\n   * @param {string} selector - The query selector of HTMLMediaElement to which\n   *    the {@link VideoTrack} is attached\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * videoTrack.detach('#my-video-element').remove();\n   */\n  detach() {\n    return super.detach.apply(this, arguments);\n  }\n\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const grayScaleProcessor = new GrayScaleProcessor(100);\n   *   videoTrack.addProcessor(grayScaleProcessor);\n   *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n   * });\n   */\n  removeProcessor(processor) {\n    if (!processor) {\n      throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n    }\n    if (!this.processor) {\n      throw new Error('No existing VideoProcessor detected.');\n    }\n    if (processor !== this.processor) {\n      throw new Error('The provided VideoProcessor is different than the existing one.');\n    }\n\n    this._processorEventObserver.emit('remove');\n    this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n    clearTimeout(this._captureTimeoutId);\n    this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n    this._unmuteHandler = null;\n    this._isCapturing = false;\n\n    this.processor = null;\n    this.processedTrack = null;\n    this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);\n    this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);\n    this._inputFrame = null;\n    this._outputFrame = null;\n\n    this._updateElementsMediaStreamTrack();\n    return this;\n  }\n}\n\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\n\nfunction dimensionsChanged(track, elem) {\n  return track.dimensions.width !== elem.videoWidth\n    || track.dimensions.height !== elem.videoHeight;\n}\n\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\n\nmodule.exports = VideoTrack;\n"]},"metadata":{},"sourceType":"script"}