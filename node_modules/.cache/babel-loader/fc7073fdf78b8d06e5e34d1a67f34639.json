{"ast":null,"code":"'use strict';\n\nvar RTCSessionDescription = require('../../webrtc').RTCSessionDescription;\n\nvar _a = require('./'),\n    createPtToCodecName = _a.createPtToCodecName,\n    getMediaSections = _a.getMediaSections;\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\n\n\nfunction workaround(description) {\n  var descriptionInit = {\n    type: description.type\n  };\n\n  if (description.type !== 'rollback') {\n    descriptionInit.sdp = sdpWorkaround(description.sdp);\n  }\n\n  return new RTCSessionDescription(descriptionInit);\n}\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\n\n\nfunction sdpWorkaround(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSectionWorkaround)).join('\\r\\n');\n}\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\n\n\nfunction mediaSectionWorkaround(mediaSection) {\n  var ptToCodecName = createPtToCodecName(mediaSection);\n  mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n  var codecNameToPts = createCodecNameToPts(ptToCodecName);\n  var rtxPts = codecNameToPts.get('rtx') || new Set();\n  var invalidRtxPts = new Set();\n  var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n  var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);\n  var unassociatedRtxPts = Array.from(invalidRtxPts); // NOTE(mroberts): We normalize to lowercase.\n\n  var knownCodecNames = ['h264', 'vp8', 'vp9'];\n  var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return Array.from(pts).reduce(function (unassociatedPts, pt) {\n      return associatedPtToRtxPt.has(pt) ? unassociatedPts : unassociatedPts.add(pt);\n    }, unassociatedPts);\n  }, new Set());\n  unassociatedPts.forEach(function (pt) {\n    if (unassociatedRtxPts.length) {\n      var rtxPt = unassociatedRtxPts.shift();\n      mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n      mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n    }\n  });\n  unassociatedRtxPts.forEach(function (rtxPt) {\n    mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n    mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n  });\n  return mediaSection;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n  // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n  // with duplicate \"rtx\" payload mapping in media section. When applied,\n  // Chrome rejects the SDP. We workaround this by deleting duplicate\n  // \"rtx\" mappings found in SDP.\n  return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {\n    var rtpmapRegex = new RegExp(\"^a=rtpmap:\" + pt + \" rtx.+$\", 'gm');\n    return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {\n      var rtpmapRegex = new RegExp(\"\\r\\n\" + rtpmap);\n      var fmtpmapRegex = new RegExp(\"\\r\\na=fmtp:\" + pt + \" apt=[0-9]+\");\n      return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n    }, section);\n  }, mediaSection);\n}\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\n\n\nfunction createCodecNameToPts(ptToCodecName) {\n  var codecNameToPts = new Map();\n  ptToCodecName.forEach(function (codecName, pt) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return codecNameToPts.set(codecName, pts.add(pt));\n  });\n  return codecNameToPts;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\n\n\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n  return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {\n    var fmtpPattern = new RegExp(\"a=fmtp:\" + rtxPt + \" apt=(\\\\d+)\");\n    var matches = mediaSection.match(fmtpPattern);\n\n    if (!matches) {\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var pt = Number.parseInt(matches[1]);\n\n    if (!ptToCodecName.has(pt)) {\n      // This is Issue 8329.\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var codecName = ptToCodecName.get(pt);\n\n    if (codecName === 'rtx') {\n      // Strange\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    return rtxPtToAssociatedPt.set(rtxPt, pt);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\n\n\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n  // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n  var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {\n    var rtxPt = pair[0];\n    var pt = pair[1];\n    var rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n    return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n  }, new Map()); // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n  // same NonRtxPT are removed and added to invalidRtxPts.\n\n  return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {\n    var pt = pair[0];\n    var rtxPts = Array.from(pair[1]);\n\n    if (rtxPts.length > 1) {\n      rtxPts.forEach(function (rtxPt) {\n        invalidRtxPts.add(rtxPt);\n      });\n      return associatedPtToRtxPt;\n    }\n\n    return associatedPtToRtxPt.set(pt, rtxPts[0]);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp(\"a=fmtp:\" + rtxPt + \".*\\r\\n\", 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp(\"a=rtpmap:\" + rtxPt + \".*\\r\\n\", 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\n\n\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n  return mediaSection.endsWith('\\r\\n') ? mediaSection + \"a=fmtp:\" + rtxPt + \" apt=\" + pt + \"\\r\\n\" : mediaSection + \"\\r\\na=fmtp:\" + rtxPt + \" apt=\" + pt;\n}\n\nmodule.exports = workaround;","map":{"version":3,"mappings":"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","names":["require","RTCSessionDescription","createPtToCodecName","getMediaSections","workaround","description","descriptionInit","type","sdp","sdpWorkaround","mediaSections","session","split","concat","map","mediaSectionWorkaround","join","mediaSection","ptToCodecName","deleteDuplicateRtxPts","codecNameToPts","createCodecNameToPts","rtxPts","get","Set","invalidRtxPts","rtxPtToAssociatedPt","createRtxPtToAssociatedPt","associatedPtToRtxPt","createAssociatedPtToRtxPt","unassociatedRtxPts","Array","from","knownCodecNames","unassociatedPts","reduce","codecName","pts","pt","has","add","forEach","length","rtxPt","shift","deleteFmtpAttributesForRtxPt","addFmtpAttributeForRtxPt","deleteRtpmapAttributesForRtxPt","keys","section","rtpmapRegex","RegExp","match","slice","rtpmap","fmtpmapRegex","replace","Map","set","fmtpPattern","matches","Number","parseInt","associatedPtToRtxPts","pair","pattern","endsWith","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/util/sdp/issue8329.js"],"sourcesContent":["'use strict';\n\nconst { RTCSessionDescription } = require('../../webrtc');\n\nconst { createPtToCodecName, getMediaSections } = require('./');\n\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\nfunction workaround(description) {\n  const descriptionInit = { type: description.type };\n  if (description.type !== 'rollback') {\n    descriptionInit.sdp = sdpWorkaround(description.sdp);\n  }\n  return new RTCSessionDescription(descriptionInit);\n}\n\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\nfunction sdpWorkaround(sdp) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session]\n    .concat(mediaSections.map(mediaSectionWorkaround))\n    .join('\\r\\n');\n}\n\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\nfunction mediaSectionWorkaround(mediaSection) {\n  const ptToCodecName = createPtToCodecName(mediaSection);\n  mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n  const codecNameToPts = createCodecNameToPts(ptToCodecName);\n  const rtxPts = codecNameToPts.get('rtx') || new Set();\n\n  const invalidRtxPts = new Set();\n  const rtxPtToAssociatedPt = createRtxPtToAssociatedPt(\n    mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n  const associatedPtToRtxPt = createAssociatedPtToRtxPt(\n    rtxPtToAssociatedPt, invalidRtxPts);\n\n  const unassociatedRtxPts = Array.from(invalidRtxPts);\n\n  // NOTE(mroberts): We normalize to lowercase.\n  const knownCodecNames = ['h264', 'vp8', 'vp9'];\n  const unassociatedPts = knownCodecNames.reduce((unassociatedPts, codecName) => {\n    const pts = codecNameToPts.get(codecName) || new Set();\n    return Array.from(pts).reduce((unassociatedPts, pt) => associatedPtToRtxPt.has(pt)\n      ? unassociatedPts\n      : unassociatedPts.add(pt), unassociatedPts);\n  }, new Set());\n\n  unassociatedPts.forEach(pt => {\n    if (unassociatedRtxPts.length) {\n      const rtxPt = unassociatedRtxPts.shift();\n      mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n      mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n    }\n  });\n\n  unassociatedRtxPts.forEach(rtxPt => {\n    mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n    mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n  });\n\n  return mediaSection;\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n  // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n  // with duplicate \"rtx\" payload mapping in media section. When applied,\n  // Chrome rejects the SDP. We workaround this by deleting duplicate\n  // \"rtx\" mappings found in SDP.\n  return Array.from(ptToCodecName.keys()).reduce((section, pt) => {\n    const rtpmapRegex = new RegExp(`^a=rtpmap:${pt} rtx.+$`, 'gm');\n    return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce((section, rtpmap) => {\n      const rtpmapRegex = new RegExp(`\\r\\n${rtpmap}`);\n      const fmtpmapRegex = new RegExp(`\\r\\na=fmtp:${pt} apt=[0-9]+`);\n      return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n    }, section);\n  }, mediaSection);\n}\n\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\nfunction createCodecNameToPts(ptToCodecName) {\n  const codecNameToPts = new Map();\n  ptToCodecName.forEach((codecName, pt) => {\n    const pts = codecNameToPts.get(codecName) || new Set();\n    return codecNameToPts.set(codecName, pts.add(pt));\n  });\n  return codecNameToPts;\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n  return Array.from(rtxPts).reduce((rtxPtToAssociatedPt, rtxPt) => {\n    const fmtpPattern = new RegExp(`a=fmtp:${rtxPt} apt=(\\\\d+)`);\n    const matches = mediaSection.match(fmtpPattern);\n    if (!matches) {\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    const pt = Number.parseInt(matches[1]);\n    if (!ptToCodecName.has(pt)) {\n      // This is Issue 8329.\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    const codecName = ptToCodecName.get(pt);\n    if (codecName === 'rtx') {\n      // Strange\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    return rtxPtToAssociatedPt.set(rtxPt, pt);\n  }, new Map());\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n  // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n  const associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce((associatedPtToRtxPts, pair) => {\n    const rtxPt = pair[0];\n    const pt = pair[1];\n    const rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n    return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n  }, new Map());\n\n  // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n  // same NonRtxPT are removed and added to invalidRtxPts.\n  return Array.from(associatedPtToRtxPts).reduce((associatedPtToRtxPt, pair) => {\n    const pt = pair[0];\n    const rtxPts = Array.from(pair[1]);\n    if (rtxPts.length > 1) {\n      rtxPts.forEach(rtxPt => {\n        invalidRtxPts.add(rtxPt);\n      });\n      return associatedPtToRtxPt;\n    }\n    return associatedPtToRtxPt.set(pt, rtxPts[0]);\n  }, new Map());\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n  const pattern = new RegExp(`a=fmtp:${rtxPt}.*\\r\\n`, 'gm');\n  return mediaSection.replace(pattern, '');\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n  const pattern = new RegExp(`a=rtpmap:${rtxPt}.*\\r\\n`, 'gm');\n  return mediaSection.replace(pattern, '');\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n  return mediaSection.endsWith('\\r\\n')\n    ? `${mediaSection}a=fmtp:${rtxPt} apt=${pt}\\r\\n`\n    : `${mediaSection}\\r\\na=fmtp:${rtxPt} apt=${pt}`;\n}\n\nmodule.exports = workaround;\n"]},"metadata":{},"sourceType":"script"}