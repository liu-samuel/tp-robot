{"ast":null,"code":"'use strict';\n\nvar CancelablePromise = require('../../util/cancelablepromise');\n\nvar DefaultPeerConnectionManager = require('./peerconnectionmanager');\n\nvar DefaultRoomV2 = require('./room');\n\nvar DefaultTransport = require('./twilioconnectiontransport');\n\nvar _a = require('../../util/twilio-video-errors'),\n    SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError,\n    SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;\n\nvar _b = require('../../util'),\n    flatMap = _b.flatMap,\n    createRoomConnectEventPayload = _b.createRoomConnectEventPayload;\n\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n  var adaptiveSimulcast = preferredCodecs.video[0] && preferredCodecs.video[0].adaptiveSimulcast === true;\n  var PeerConnectionManager = options.PeerConnectionManager,\n      RoomV2 = options.RoomV2,\n      Transport = options.Transport,\n      iceServers = options.iceServers,\n      log = options.log;\n  var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  var trackSenders = flatMap(localParticipant.tracks, function (trackV2) {\n    return [trackV2.trackTransceiver];\n  });\n  peerConnectionManager.setTrackSenders(trackSenders);\n  var cancellationError = new Error('Canceled');\n  var transport;\n  var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {\n    var onIced = function (iceServers) {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n      return peerConnectionManager.createAndOffer().then(function () {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n\n        log.debug('createAndOffer() succeeded.'); // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n\n        peerConnectionManager.dequeue('description');\n      }).catch(function (error) {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n\n    var automaticSubscription = options.automaticSubscription,\n        bandwidthProfile = options.bandwidthProfile,\n        dominantSpeaker = options.dominantSpeaker,\n        environment = options.environment,\n        eventObserver = options.eventObserver,\n        loggerName = options.loggerName,\n        logLevel = options.logLevel,\n        name = options.name,\n        networkMonitor = options.networkMonitor,\n        networkQuality = options.networkQuality,\n        realm = options.realm,\n        sdpSemantics = options.sdpSemantics; // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n\n    var trackPriority = !!bandwidthProfile;\n    var trackSwitchOff = !!bandwidthProfile;\n    var renderHints = !!bandwidthProfile && (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n    var transportOptions = Object.assign({\n      adaptiveSimulcast: adaptiveSimulcast,\n      automaticSubscription: automaticSubscription,\n      dominantSpeaker: dominantSpeaker,\n      environment: environment,\n      eventObserver: eventObserver,\n      loggerName: loggerName,\n      logLevel: logLevel,\n      networkMonitor: networkMonitor,\n      networkQuality: networkQuality,\n      iceServers: iceServers,\n      onIced: onIced,\n      realm: realm,\n      renderHints: renderHints,\n      sdpSemantics: sdpSemantics,\n      trackPriority: trackPriority,\n      trackSwitchOff: trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile: bandwidthProfile\n    } : {});\n    transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);\n    var connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n    transport.once('connected', function (initialState) {\n      log.debug('Transport connected:', initialState);\n\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n\n      var localParticipantState = initialState.participant;\n\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n\n      var signalingRegion = initialState.options.signaling_region;\n      localParticipant.setSignalingRegion(signalingRegion);\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n    transport.once('stateChanged', function (state, error) {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n  cancelablePromise.catch(function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n\n    peerConnectionManager.close();\n  });\n  return cancelablePromise;\n}\n\nmodule.exports = createCancelableRoomSignalingPromise;","map":{"version":3,"mappings":"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","names":["CancelablePromise","require","DefaultPeerConnectionManager","DefaultRoomV2","DefaultTransport","SignalingConnectionDisconnectedError","SignalingIncomingMessageInvalidError","flatMap","createRoomConnectEventPayload","createCancelableRoomSignalingPromise","token","wsServer","localParticipant","encodingParameters","preferredCodecs","options","Object","assign","PeerConnectionManager","RoomV2","Transport","adaptiveSimulcast","video","iceServers","log","peerConnectionManager","trackSenders","tracks","trackV2","trackTransceiver","setTrackSenders","cancellationError","Error","transport","cancelablePromise","resolve","reject","isCanceled","onIced","Promise","debug","setConfiguration","createAndOffer","then","dequeue","catch","error","bandwidthProfile","dominantSpeaker","environment","eventObserver","loggerName","logLevel","name","networkMonitor","networkQuality","realm","sdpSemantics","trackPriority","trackSwitchOff","renderHints","clientTrackSwitchOffControl","contentPreferencesMode","transportOptions","automaticSubscription","connectEventPayload","emit","once","initialState","localParticipantState","signalingRegion","signaling_region","setSignalingRegion","state","disconnect","close","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/signaling/v2/cancelableroomsignalingpromise.js"],"sourcesContent":["'use strict';\n\nconst CancelablePromise = require('../../util/cancelablepromise');\nconst DefaultPeerConnectionManager = require('./peerconnectionmanager');\nconst DefaultRoomV2 = require('./room');\nconst DefaultTransport = require('./twilioconnectiontransport');\n\nconst {\n  SignalingConnectionDisconnectedError,\n  SignalingIncomingMessageInvalidError\n} = require('../../util/twilio-video-errors');\n\nconst { flatMap, createRoomConnectEventPayload } = require('../../util');\n\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n\n  const adaptiveSimulcast = preferredCodecs.video[0] &&  preferredCodecs.video[0].adaptiveSimulcast === true;\n  const { PeerConnectionManager, RoomV2, Transport, iceServers, log } = options;\n  const peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  const trackSenders = flatMap(localParticipant.tracks, trackV2 => [trackV2.trackTransceiver]);\n  peerConnectionManager.setTrackSenders(trackSenders);\n\n  const cancellationError = new Error('Canceled');\n\n  let transport;\n\n  const cancelablePromise = new CancelablePromise((resolve, reject, isCanceled) => {\n    const onIced = iceServers => {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n\n      return peerConnectionManager.createAndOffer().then(() => {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n        log.debug('createAndOffer() succeeded.');\n        // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n        peerConnectionManager.dequeue('description');\n      }).catch(error => {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n\n    const {\n      automaticSubscription,\n      bandwidthProfile,\n      dominantSpeaker,\n      environment,\n      eventObserver,\n      loggerName,\n      logLevel,\n      name,\n      networkMonitor,\n      networkQuality,\n      realm,\n      sdpSemantics,\n    } = options;\n\n    // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n    const trackPriority = !!bandwidthProfile;\n    const trackSwitchOff = !!bandwidthProfile;\n    const renderHints = !!bandwidthProfile &&\n      (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n\n    const transportOptions = Object.assign({\n      adaptiveSimulcast,\n      automaticSubscription,\n      dominantSpeaker,\n      environment,\n      eventObserver,\n      loggerName,\n      logLevel,\n      networkMonitor,\n      networkQuality,\n      iceServers,\n      onIced,\n      realm,\n      renderHints,\n      sdpSemantics,\n      trackPriority,\n      trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile\n    } : {});\n\n    transport = new Transport(\n      name,\n      token,\n      localParticipant,\n      peerConnectionManager,\n      wsServer,\n      transportOptions);\n\n    const connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n\n    transport.once('connected', initialState => {\n      log.debug('Transport connected:', initialState);\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n      const { participant: localParticipantState } = initialState;\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n\n      const { options: { signaling_region: signalingRegion } } = initialState;\n      localParticipant.setSignalingRegion(signalingRegion);\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n\n    transport.once('stateChanged', (state, error) => {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, () => {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n\n  cancelablePromise.catch(() => {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n    peerConnectionManager.close();\n  });\n\n  return cancelablePromise;\n}\n\nmodule.exports = createCancelableRoomSignalingPromise;\n"]},"metadata":{},"sourceType":"script"}