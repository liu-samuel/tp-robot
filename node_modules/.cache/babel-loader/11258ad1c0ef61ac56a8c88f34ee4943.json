{"ast":null,"code":"'use strict';\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\n\nfunction delay(timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n}\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\n\n\nfunction detectSilence(audioContext, stream, timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 250;\n  var source = audioContext.createMediaStreamSource(stream);\n  var analyser = audioContext.createAnalyser();\n  analyser.fftSize = 2048;\n  source.connect(analyser);\n  var samples = new Uint8Array(analyser.fftSize);\n  var timeoutDidFire = false;\n  setTimeout(function () {\n    timeoutDidFire = true;\n  }, timeout);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<boolean>}\n   */\n\n  function doDetectSilence() {\n    if (timeoutDidFire) {\n      return Promise.resolve(true);\n    }\n\n    analyser.getByteTimeDomainData(samples); // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples\n    // being equal to 128 or all samples being equal to 0.\n\n    return samples.some(function (sample) {\n      return sample !== 128 && sample !== 0;\n    }) ? Promise.resolve(false) : delay().then(doDetectSilence);\n  }\n\n  return doDetectSilence().then(function (isSilent) {\n    source.disconnect();\n    return isSilent;\n  }, function (error) {\n    source.disconnect();\n    throw error;\n  });\n}\n\nmodule.exports = detectSilence;","map":{"version":3,"mappings":"AAAA;AAEA;;;;;;AAKA,SAASA,KAAT,CAAeC,OAAf,EAAsB;EACpBA,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,CAAlD;EACA,OAAO,IAAIC,OAAJ,CAAY,mBAAO;IAAI,iBAAU,CAACC,OAAD,EAAUF,OAAV,CAAV;EAA4B,CAAnD,CAAP;AACD;AAED;;;;;;;;;;AAQA,SAASG,aAAT,CAAuBC,YAAvB,EAAqCC,MAArC,EAA6CL,OAA7C,EAAoD;EAClDA,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,GAAlD;EAEA,IAAMM,MAAM,GAAGF,YAAY,CAACG,uBAAb,CAAqCF,MAArC,CAAf;EACA,IAAMG,QAAQ,GAAGJ,YAAY,CAACK,cAAb,EAAjB;EACAD,QAAQ,CAACE,OAAT,GAAmB,IAAnB;EACAJ,MAAM,CAACK,OAAP,CAAeH,QAAf;EAEA,IAAMI,OAAO,GAAG,IAAIC,UAAJ,CAAeL,QAAQ,CAACE,OAAxB,CAAhB;EAEA,IAAII,cAAc,GAAG,KAArB;EACAC,UAAU,CAAC;IAAQD,cAAc,GAAG,IAAjB;EAAwB,CAAjC,EAAmCd,OAAnC,CAAV;EAEA;;;;;EAIA,SAASgB,eAAT,GAAwB;IACtB,IAAIF,cAAJ,EAAoB;MAClB,OAAOb,OAAO,CAACC,OAAR,CAAgB,IAAhB,CAAP;IACD;;IACDM,QAAQ,CAACS,qBAAT,CAA+BL,OAA/B,EAJsB,CAKtB;IACA;;IACA,OAAOA,OAAO,CAACM,IAAR,CAAa,kBAAM;MAAI,aAAM,KAAK,GAAX,IAAkBC,MAAM,KAAK,CAA7B;IAA8B,CAArD,IACHlB,OAAO,CAACC,OAAR,CAAgB,KAAhB,CADG,GAEHH,KAAK,GAAGqB,IAAR,CAAaJ,eAAb,CAFJ;EAGD;;EAED,OAAOA,eAAe,GAAGI,IAAlB,CAAuB,oBAAQ;IACpCd,MAAM,CAACe,UAAP;IACA,OAAOC,QAAP;EACD,CAHM,EAGJ,iBAAK;IACNhB,MAAM,CAACe,UAAP;IACA,MAAME,KAAN;EACD,CANM,CAAP;AAOD;;AAEDC,MAAM,CAACC,OAAP,GAAiBtB,aAAjB","names":["delay","timeout","Promise","resolve","detectSilence","audioContext","stream","source","createMediaStreamSource","analyser","createAnalyser","fftSize","connect","samples","Uint8Array","timeoutDidFire","setTimeout","doDetectSilence","getByteTimeDomainData","some","sample","then","disconnect","isSilent","error","module","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/webaudio/detectsilence.js"],"sourcesContent":["'use strict';\n\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\nfunction delay(timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 0;\n  return new Promise(resolve => setTimeout(resolve, timeout));\n}\n\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\nfunction detectSilence(audioContext, stream, timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 250;\n\n  const source = audioContext.createMediaStreamSource(stream);\n  const analyser = audioContext.createAnalyser();\n  analyser.fftSize = 2048;\n  source.connect(analyser);\n\n  const samples = new Uint8Array(analyser.fftSize);\n\n  let timeoutDidFire = false;\n  setTimeout(() => { timeoutDidFire = true; }, timeout);\n\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<boolean>}\n   */\n  function doDetectSilence() {\n    if (timeoutDidFire) {\n      return Promise.resolve(true);\n    }\n    analyser.getByteTimeDomainData(samples);\n    // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples\n    // being equal to 128 or all samples being equal to 0.\n    return samples.some(sample => sample !== 128 && sample !== 0)\n      ? Promise.resolve(false)\n      : delay().then(doDetectSilence);\n  }\n\n  return doDetectSilence().then(isSilent => {\n    source.disconnect();\n    return isSilent;\n  }, error => {\n    source.disconnect();\n    throw error;\n  });\n}\n\nmodule.exports = detectSilence;\n"]},"metadata":{},"sourceType":"script"}