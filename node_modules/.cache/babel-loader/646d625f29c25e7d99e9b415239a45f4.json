{"ast":null,"code":"/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\n\nvar EventTarget = require('../util/eventtarget');\n\nvar inherits = require('../../vendor/inherits');\n\nvar Latch = require('../util/latch');\n\nvar MediaStream = require('../mediastream');\n\nvar RTCRtpSenderShim = require('../rtcrtpsender');\n\nvar sdpUtils = require('../util/sdp');\n\nvar util = require('../util');\n\nvar isIOSChrome = require('../util').isIOSChrome;\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified'; // NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\n\nfunction ChromeRTCPeerConnection(configuration, constraints) {\n  if (!(this instanceof ChromeRTCPeerConnection)) {\n    return new ChromeRTCPeerConnection(configuration, constraints);\n  }\n\n  EventTarget.call(this);\n  configuration = configuration || {};\n  var newConfiguration = Object.assign(configuration.iceTransportPolicy ? {\n    iceTransports: configuration.iceTransportPolicy\n  } : {}, configuration);\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'signalingstatechange');\n  var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);\n  var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _localStream: {\n      value: new MediaStream()\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _sdpFormat: {\n      value: sdpFormat\n    },\n    _senders: {\n      value: new Map()\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function get() {\n        return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function get() {\n        return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function get() {\n        if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n\n        return peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  });\n\n  peerConnection.ontrack = function ontrack() {// NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n    // the ontrack property of the RTCPeerConnection.\n  };\n\n  if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n    peerConnection.addStream(this._localStream);\n  }\n\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(ChromeRTCPeerConnection, EventTarget);\n\nif (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var args = [].slice.call(arguments);\n    var track = args[0];\n\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', ' + track.kind + ']: RTCPeerConnection is closed');\n    }\n\n    var sender = this._senders.get(track);\n\n    if (sender && sender.track) {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', ' + track.kind + ']: RTCPeerConnection already has it');\n    }\n\n    this._peerConnection.removeStream(this._localStream);\n\n    this._localStream.addTrack(track);\n\n    this._peerConnection.addStream(this._localStream);\n\n    sender = new RTCRtpSenderShim(track);\n\n    this._senders.set(track, sender);\n\n    return sender;\n  }; // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n\n\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    var track = sender.track;\n\n    if (!track) {\n      return;\n    }\n\n    sender = this._senders.get(track);\n\n    if (sender && sender.track) {\n      sender.track = null;\n\n      this._peerConnection.removeStream(this._localStream);\n\n      this._localStream.removeTrack(track);\n\n      this._peerConnection.addStream(this._localStream);\n    }\n  };\n\n  ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {\n    return Array.from(this._senders.values());\n  };\n} else {\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    try {\n      this._peerConnection.removeTrack(sender);\n    } catch (e) {// NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n      // created by this peer connection'. This behavior does not seem to be\n      // spec compliant, so a temporary shim is introduced. A bug has been filed,\n      // and is tracked here:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n    }\n  };\n}\n\nChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n    // \"have-remote-offer\" signalingStates, we only want to invoke the true\n    // addIceCandidates method when the remote description has been applied.\n    promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  } else {\n    promise = this._peerConnection.addIceCandidate(candidate);\n  }\n\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n}; // NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n// Error; however, in Chrome it does. We workaround this by checking the\n// signalingState manually.\n\n\nChromeRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._pendingLocalOffer = null;\n    this._pendingRemoteOffer = null;\n\n    this._peerConnection.close();\n  }\n}; // NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n// \"faking\" setRemoteDescription, we cannot create an answer until we actually\n// apply the remote description. This means, once you call createAnswer, you\n// can no longer rollback. This is acceptable for our use case because we will\n// apply the newly-created answer almost immediately; however, this may be\n// unacceptable for other use cases.\n\n\nChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n      // and the underlying RTCPeerConnection implementation have converged. We\n      // can unblock any pending calls to addIceCandidate now.\n      self._signalingStateLatch.lower();\n\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null; // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  } else {\n    promise = this._peerConnection.createAnswer().then(function (answer) {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    });\n  }\n\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var self = this;\n\n  if (isIOSChrome()) {\n    // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n      delete options.offerToReceiveAudio;\n\n      try {\n        this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('audio');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n      delete options.offerToReceiveVideo;\n\n      try {\n        this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('video');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n  }\n\n  var promise = this._peerConnection.createOffer(options).then(function (offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new ChromeRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)\n    });\n  });\n\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  dataChannelDict = shimDataChannelInit(dataChannelDict);\n\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0]; // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  var promise = setDescription(this, true, description);\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0]; // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n\n  this._rolledBackTracksToSSRCs.clear();\n\n  var promise = setDescription(this, false, description);\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, ChromeRTCPeerConnection.prototype, '_peerConnection'); // NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  var promise;\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') + ' offer in state ' + peerConnection.signalingState));\n    } // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve(); // Only dispatch a signalingstatechange event if we transitioned.\n\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error('Cannot rollback ' + (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer(); // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n      promise = Promise.resolve();\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  }\n\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\n\n\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n\n  return new RTCSessionDescription(description);\n}\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\n\n\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\n\n\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n\n  return dataChannelDict;\n}\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\n\n\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n  });\n\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535 ? null : dataChannel.maxRetransmitTime\n    });\n  }\n\n  return dataChannel;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\n\n\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified' ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp) : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\n\nmodule.exports = ChromeRTCPeerConnection;","map":{"version":3,"mappings":"AAAA;AACA;;AAEA,IAAIA,2BAA2B,GAAGC,OAAO,CAAC,iCAAD,CAAzC;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,uBAAD,CAAtB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,eAAD,CAAnB;;AACA,IAAII,WAAW,GAAGJ,OAAO,CAAC,gBAAD,CAAzB;;AACA,IAAIK,gBAAgB,GAAGL,OAAO,CAAC,iBAAD,CAA9B;;AACA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,aAAD,CAAtB;;AACA,IAAIO,IAAI,GAAGP,OAAO,CAAC,SAAD,CAAlB;;AACA,IAAIQ,WAAW,GAAGR,OAAO,CAAC,SAAD,CAAP,CAAmBQ,WAArC;;AAEA,IAAIC,aAAa,GAAGH,QAAQ,CAACI,YAAT,OAA4B,SAAhD,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,uBAAT,CAAiCC,aAAjC,EAAgDC,WAAhD,EAA2D;EACzD,IAAI,EAAE,gBAAgBF,uBAAlB,CAAJ,EAAgD;IAC9C,OAAO,IAAIA,uBAAJ,CAA4BC,aAA5B,EAA2CC,WAA3C,CAAP;EACD;;EAEDZ,WAAW,CAACa,IAAZ,CAAiB,IAAjB;EAEAF,aAAa,GAAGA,aAAa,IAAI,EAAjC;EACA,IAAIG,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAcL,aAAa,CAACM,kBAAd,GACjC;IAAEC,aAAa,EAAEP,aAAa,CAACM;EAA/B,CADiC,GAEjC,EAFmB,EAEfN,aAFe,CAAvB;EAIAL,IAAI,CAACa,cAAL,CAAoB,IAApB,EAA0B,aAA1B;EACAb,IAAI,CAACa,cAAL,CAAoB,IAApB,EAA0B,sBAA1B;EAEA,IAAIC,SAAS,GAAGf,QAAQ,CAACI,YAAT,CAAsBK,gBAAgB,CAACO,YAAvC,CAAhB;EACA,IAAIC,cAAc,GAAG,IAAIC,iBAAJ,CAAsBT,gBAAtB,EAAwCF,WAAxC,CAArB;EAEAG,MAAM,CAACS,gBAAP,CAAwB,IAAxB,EAA8B;IAC5BC,qBAAqB,EAAE;MACrBC,KAAK,EAAE,IAAIC,GAAJ,EADc;MAErBC,QAAQ,EAAE;IAFW,CADK;IAK5BC,YAAY,EAAE;MACZH,KAAK,EAAE,IAAIvB,WAAJ;IADK,CALc;IAQ5B2B,eAAe,EAAE;MACfJ,KAAK,EAAEJ;IADQ,CARW;IAW5BS,kBAAkB,EAAE;MAClBL,KAAK,EAAE,IADW;MAElBE,QAAQ,EAAE;IAFQ,CAXQ;IAe5BI,mBAAmB,EAAE;MACnBN,KAAK,EAAE,IADY;MAEnBE,QAAQ,EAAE;IAFS,CAfO;IAmB5BK,wBAAwB,EAAE;MACxBP,KAAK,EAAE,IAAIC,GAAJ,EADiB;MAExBC,QAAQ,EAAE;IAFc,CAnBE;IAuB5BM,UAAU,EAAE;MACVR,KAAK,EAAEN;IADG,CAvBgB;IA0B5Be,QAAQ,EAAE;MACRT,KAAK,EAAE,IAAIC,GAAJ;IADC,CA1BkB;IA6B5BS,oBAAoB,EAAE;MACpBV,KAAK,EAAE,IAAIxB,KAAJ;IADa,CA7BM;IAgC5BmC,cAAc,EAAE;MACdX,KAAK,EAAE,IAAIC,GAAJ,EADO;MAEdC,QAAQ,EAAE;IAFI,CAhCY;IAoC5BU,gBAAgB,EAAE;MAChBC,UAAU,EAAE,IADI;MAEhBC,GAAG,EAAE;QACH,OAAO,KAAKT,kBAAL,GAA0B,KAAKA,kBAA/B,GAAoDT,cAAc,CAACgB,gBAA1E;MACD;IAJe,CApCU;IA0C5BG,iBAAiB,EAAE;MACjBF,UAAU,EAAE,IADK;MAEjBC,GAAG,EAAE;QACH,OAAO,KAAKR,mBAAL,GAA2B,KAAKA,mBAAhC,GAAsDV,cAAc,CAACmB,iBAA5E;MACD;IAJgB,CA1CS;IAgD5BC,cAAc,EAAE;MACdH,UAAU,EAAE,IADE;MAEdC,GAAG,EAAE;QACH,IAAI,KAAKT,kBAAT,EAA6B;UAC3B,OAAO,kBAAP;QACD,CAFD,MAEO,IAAI,KAAKC,mBAAT,EAA8B;UACnC,OAAO,mBAAP;QACD;;QACD,OAAOV,cAAc,CAACoB,cAAtB;MACD;IATa;EAhDY,CAA9B;EA6DA,IAAIC,IAAI,GAAG,IAAX;EAEArB,cAAc,CAACsB,gBAAf,CAAgC,aAAhC,EAA+C,SAASC,aAAT,CAAuBC,KAAvB,EAA4B;IACzEC,eAAe,CAACD,KAAK,CAACE,OAAP,CAAf;IACAL,IAAI,CAACM,aAAL,CAAmBH,KAAnB;EACD,CAHD;EAKAxB,cAAc,CAACsB,gBAAf,CAAgC,sBAAhC,EAAwD,SAASM,sBAAT,GAA+B;IACrF,IAAI5B,cAAc,CAACoB,cAAf,KAAkC,QAAtC,EAAgD;MAC9CC,IAAI,CAAClB,qBAAL,GAA6B,IAAIE,GAAJ,CAAQgB,IAAI,CAACN,cAAb,CAA7B;IACD;;IACD,IAAI,CAACM,IAAI,CAACZ,kBAAN,IAA4B,CAACY,IAAI,CAACX,mBAAtC,EAA2D;MACzDW,IAAI,CAACM,aAAL,CAAmBE,KAAnB,CAAyBR,IAAzB,EAA+BS,SAA/B;IACD;EACF,CAPD;;EASA9B,cAAc,CAAC+B,OAAf,GAAyB,SAASA,OAAT,GAAgB,CACvC;IACA;EACD,CAHD;;EAKA,IAAI,OAAO9B,iBAAiB,CAAC+B,SAAlB,CAA4BC,QAAnC,KAAgD,UAApD,EAAgE;IAC9DjC,cAAc,CAACkC,SAAf,CAAyB,KAAK3B,YAA9B;EACD;;EACDvB,IAAI,CAACmD,eAAL,CAAqBlC,iBAAiB,CAAC+B,SAAvC,EAAkD,IAAlD,EAAwDhC,cAAxD;AACD;;AAEDrB,QAAQ,CAACS,uBAAD,EAA0BV,WAA1B,CAAR;;AAEA,IAAI,OAAOuB,iBAAiB,CAAC+B,SAAlB,CAA4BC,QAAnC,KAAgD,UAApD,EAAgE;EAC9D;EACA;EACA;EACA;EACA7C,uBAAuB,CAAC4C,SAAxB,CAAkCC,QAAlC,GAA6C,SAASA,QAAT,GAAiB;IAC5D,IAAIG,IAAI,GAAG,GAAGC,KAAH,CAAS9C,IAAT,CAAcuC,SAAd,CAAX;IACA,IAAIQ,KAAK,GAAGF,IAAI,CAAC,CAAD,CAAhB;;IACA,IAAI,KAAK5B,eAAL,CAAqBY,cAArB,KAAwC,QAA5C,EAAsD;MACpD,MAAM,IAAImB,KAAJ,CAAU,kCAAkCD,KAAK,CAACE,EAAxC,GAA6C,IAA7C,GACZF,KAAK,CAACG,IADM,GACC,gCADX,CAAN;IAED;;IAED,IAAIC,MAAM,GAAG,KAAK7B,QAAL,CAAcK,GAAd,CAAkBoB,KAAlB,CAAb;;IACA,IAAII,MAAM,IAAIA,MAAM,CAACJ,KAArB,EAA4B;MAC1B,MAAM,IAAIC,KAAJ,CAAU,kCAAkCD,KAAK,CAACE,EAAxC,GAA6C,IAA7C,GACZF,KAAK,CAACG,IADM,GACC,qCADX,CAAN;IAED;;IACD,KAAKjC,eAAL,CAAqBmC,YAArB,CAAkC,KAAKpC,YAAvC;;IACA,KAAKA,YAAL,CAAkB0B,QAAlB,CAA2BK,KAA3B;;IACA,KAAK9B,eAAL,CAAqB0B,SAArB,CAA+B,KAAK3B,YAApC;;IAEAmC,MAAM,GAAG,IAAI5D,gBAAJ,CAAqBwD,KAArB,CAAT;;IACA,KAAKzB,QAAL,CAAc+B,GAAd,CAAkBN,KAAlB,EAAyBI,MAAzB;;IACA,OAAOA,MAAP;EACD,CApBD,CAL8D,CA2B9D;EACA;EACA;EACA;;;EACAtD,uBAAuB,CAAC4C,SAAxB,CAAkCa,WAAlC,GAAgD,SAASA,WAAT,CAAqBH,MAArB,EAA2B;IACzE,IAAI,KAAKlC,eAAL,CAAqBY,cAArB,KAAwC,QAA5C,EAAsD;MACpD,MAAM,IAAImB,KAAJ,CAAU,6DAAV,CAAN;IACD;;IAED,IAAID,KAAK,GAAGI,MAAM,CAACJ,KAAnB;;IACA,IAAI,CAACA,KAAL,EAAY;MACV;IACD;;IACDI,MAAM,GAAG,KAAK7B,QAAL,CAAcK,GAAd,CAAkBoB,KAAlB,CAAT;;IACA,IAAII,MAAM,IAAIA,MAAM,CAACJ,KAArB,EAA4B;MAC1BI,MAAM,CAACJ,KAAP,GAAe,IAAf;;MACA,KAAK9B,eAAL,CAAqBmC,YAArB,CAAkC,KAAKpC,YAAvC;;MACA,KAAKA,YAAL,CAAkBsC,WAAlB,CAA8BP,KAA9B;;MACA,KAAK9B,eAAL,CAAqB0B,SAArB,CAA+B,KAAK3B,YAApC;IACD;EACF,CAhBD;;EAkBAnB,uBAAuB,CAAC4C,SAAxB,CAAkCc,UAAlC,GAA+C,SAASA,UAAT,GAAmB;IAChE,OAAOC,KAAK,CAACC,IAAN,CAAW,KAAKnC,QAAL,CAAcoC,MAAd,EAAX,CAAP;EACD,CAFD;AAGD,CApDD,MAoDO;EACL7D,uBAAuB,CAAC4C,SAAxB,CAAkCa,WAAlC,GAAgD,SAASA,WAAT,CAAqBH,MAArB,EAA2B;IACzE,IAAI,KAAKlC,eAAL,CAAqBY,cAArB,KAAwC,QAA5C,EAAsD;MACpD,MAAM,IAAImB,KAAJ,CAAU,6DAAV,CAAN;IACD;;IACD,IAAI;MACF,KAAK/B,eAAL,CAAqBqC,WAArB,CAAiCH,MAAjC;IACD,CAFD,CAEE,OAAOQ,CAAP,EAAU,CACV;MACA;MACA;MACA;MACA;IACD;EACF,CAbD;AAcD;;AAED9D,uBAAuB,CAAC4C,SAAxB,CAAkCmB,eAAlC,GAAoD,SAASA,eAAT,CAAyBC,SAAzB,EAAkC;EACpF,IAAIhB,IAAI,GAAG,GAAGC,KAAH,CAAS9C,IAAT,CAAcuC,SAAd,CAAX;EACA,IAAIuB,OAAJ;EACA,IAAIhC,IAAI,GAAG,IAAX;;EAEA,IAAI,KAAKD,cAAL,KAAwB,mBAA5B,EAAiD;IAC/C;IACA;IACA;IACAiC,OAAO,GAAG,KAAKvC,oBAAL,CAA0BwC,IAA1B,CAA+B,KAA/B,EAAsCC,IAAtC,CAA2C,SAASC,uBAAT,GAAgC;MACnF,OAAOnC,IAAI,CAACb,eAAL,CAAqB2C,eAArB,CAAqCC,SAArC,CAAP;IACD,CAFS,CAAV;EAGD,CAPD,MAOO;IACLC,OAAO,GAAG,KAAK7C,eAAL,CAAqB2C,eAArB,CAAqCC,SAArC,CAAV;EACD;;EAED,OAAOhB,IAAI,CAACqB,MAAL,GAAc,CAAd,GACHzE,IAAI,CAAC0E,aAAL,CAAmBL,OAAnB,EAA4BjB,IAAI,CAAC,CAAD,CAAhC,EAAqCA,IAAI,CAAC,CAAD,CAAzC,CADG,GAEHiB,OAFJ;AAGD,CAnBD,C,CAqBA;AACA;AACA;;;AACAjE,uBAAuB,CAAC4C,SAAxB,CAAkC2B,KAAlC,GAA0C,SAASA,KAAT,GAAc;EACtD,IAAI,KAAKvC,cAAL,KAAwB,QAA5B,EAAsC;IACpC,KAAKX,kBAAL,GAA0B,IAA1B;IACA,KAAKC,mBAAL,GAA2B,IAA3B;;IACA,KAAKF,eAAL,CAAqBmD,KAArB;EACD;AACF,CAND,C,CAQA;AACA;AACA;AACA;AACA;AACA;;;AACAvE,uBAAuB,CAAC4C,SAAxB,CAAkC4B,YAAlC,GAAiD,SAASA,YAAT,GAAqB;EACpE,IAAIxB,IAAI,GAAG,GAAGC,KAAH,CAAS9C,IAAT,CAAcuC,SAAd,CAAX;EACA,IAAIuB,OAAJ;EACA,IAAIhC,IAAI,GAAG,IAAX;;EAEA,IAAI,KAAKX,mBAAT,EAA8B;IAC5B2C,OAAO,GAAG,KAAK7C,eAAL,CAAqBqD,oBAArB,CAA0C,KAAKnD,mBAA/C,EAAoE6C,IAApE,CAAyE,SAASO,6BAAT,GAAsC;MACvH;MACA;MACA;MACAzC,IAAI,CAACP,oBAAL,CAA0BiD,KAA1B;;MACA,OAAO1C,IAAI,CAACb,eAAL,CAAqBoD,YAArB,EAAP;IACD,CANS,EAMPL,IANO,CAMF,SAASS,qBAAT,CAA+BC,MAA/B,EAAqC;MAC3C5C,IAAI,CAACX,mBAAL,GAA2B,IAA3B,CAD2C,CAG3C;MACA;;MACAW,IAAI,CAACV,wBAAL,CAA8BuD,KAA9B;;MAEA,OAAO,IAAI1F,2BAAJ,CAAgC;QACrC2F,IAAI,EAAE,QAD+B;QAErCC,GAAG,EAAEC,qBAAqB,CAAChD,IAAI,CAACT,UAAN,EAAkBS,IAAI,CAACN,cAAvB,EAAuCkD,MAAM,CAACG,GAA9C;MAFW,CAAhC,CAAP;IAID,CAjBS,EAiBP,SAASE,wCAAT,CAAkDC,KAAlD,EAAuD;MACxDlD,IAAI,CAACX,mBAAL,GAA2B,IAA3B;MACA,MAAM6D,KAAN;IACD,CApBS,CAAV;EAqBD,CAtBD,MAsBO;IACLlB,OAAO,GAAG,KAAK7C,eAAL,CAAqBoD,YAArB,GAAoCL,IAApC,CAAyC,UAASU,MAAT,EAAe;MAChE;MACA;MACA5C,IAAI,CAACV,wBAAL,CAA8BuD,KAA9B;;MAEA,OAAO,IAAI1F,2BAAJ,CAAgC;QACrC2F,IAAI,EAAE,QAD+B;QAErCC,GAAG,EAAEC,qBAAqB,CAAChD,IAAI,CAACT,UAAN,EAAkBS,IAAI,CAACN,cAAvB,EAAuCkD,MAAM,CAACG,GAA9C;MAFW,CAAhC,CAAP;IAID,CATS,CAAV;EAUD;;EAED,OAAOhC,IAAI,CAACqB,MAAL,GAAc,CAAd,GACHzE,IAAI,CAAC0E,aAAL,CAAmBL,OAAnB,EAA4BjB,IAAI,CAAC,CAAD,CAAhC,EAAqCA,IAAI,CAAC,CAAD,CAAzC,CADG,GAEHiB,OAFJ;AAGD,CA3CD;;AA6CAjE,uBAAuB,CAAC4C,SAAxB,CAAkCwC,WAAlC,GAAgD,SAASA,WAAT,GAAoB;EAClE,IAAIpC,IAAI,GAAG,GAAGC,KAAH,CAAS9C,IAAT,CAAcuC,SAAd,CAAX;EACA,IAAI2C,OAAO,GAAG,CAACrC,IAAI,CAACqB,MAAL,GAAc,CAAd,GAAkBrB,IAAI,CAAC,CAAD,CAAtB,GAA4BA,IAAI,CAAC,CAAD,CAAjC,KAAyC,EAAvD;EACA,IAAIf,IAAI,GAAG,IAAX;;EAEA,IAAIpC,WAAW,EAAf,EAAmB;IACjB;IACA,IAAIwF,OAAO,CAACC,mBAAR,IAA+B,CAAC,KAAKC,iBAArC,IAA0D,EAAEzF,aAAa,IAAI0F,2BAA2B,CAAC,IAAD,EAAO,OAAP,CAA9C,CAA9D,EAA8H;MAC5H,OAAOH,OAAO,CAACI,mBAAf;;MACA,IAAI;QACF,KAAKF,iBAAL,GAAyBzF,aAAa,GAClC,KAAK4F,cAAL,CAAoB,OAApB,EAA6B;UAAEC,SAAS,EAAE;QAAb,CAA7B,CADkC,GAElC,KAAKD,cAAL,CAAoB,OAApB,CAFJ;MAGD,CAJD,CAIE,OAAO5B,CAAP,EAAU;QACV,OAAO8B,OAAO,CAACC,MAAR,CAAe/B,CAAf,CAAP;MACD;IACF;;IAED,IAAIuB,OAAO,CAACC,mBAAR,IAA+B,CAAC,KAAKQ,iBAArC,IAA0D,EAAEhG,aAAa,IAAI0F,2BAA2B,CAAC,IAAD,EAAO,OAAP,CAA9C,CAA9D,EAA8H;MAC5H,OAAOH,OAAO,CAACC,mBAAf;;MACA,IAAI;QACF,KAAKQ,iBAAL,GAAyBhG,aAAa,GAClC,KAAK4F,cAAL,CAAoB,OAApB,EAA6B;UAAEC,SAAS,EAAE;QAAb,CAA7B,CADkC,GAElC,KAAKD,cAAL,CAAoB,OAApB,CAFJ;MAGD,CAJD,CAIE,OAAO5B,CAAP,EAAU;QACV,OAAO8B,OAAO,CAACC,MAAR,CAAe/B,CAAf,CAAP;MACD;IACF;EACF;;EAED,IAAIG,OAAO,GAAG,KAAK7C,eAAL,CAAqBgE,WAArB,CAAiCC,OAAjC,EAA0ClB,IAA1C,CAA+C,UAAS4B,KAAT,EAAc;IACzE;IACA;IACA9D,IAAI,CAACV,wBAAL,CAA8BuD,KAA9B;;IAEA,OAAO,IAAI1F,2BAAJ,CAAgC;MACrC2F,IAAI,EAAEgB,KAAK,CAAChB,IADyB;MAErCC,GAAG,EAAEC,qBAAqB,CAAChD,IAAI,CAACT,UAAN,EAAkBS,IAAI,CAACN,cAAvB,EAAuCoE,KAAK,CAACf,GAA7C;IAFW,CAAhC,CAAP;EAID,CATa,CAAd;;EAWA,OAAOhC,IAAI,CAACqB,MAAL,GAAc,CAAd,GACHzE,IAAI,CAAC0E,aAAL,CAAmBL,OAAnB,EAA4BjB,IAAI,CAAC,CAAD,CAAhC,EAAqCA,IAAI,CAAC,CAAD,CAAzC,CADG,GAEHiB,OAFJ;AAGD,CA5CD;;AA8CAjE,uBAAuB,CAAC4C,SAAxB,CAAkCoD,iBAAlC,GAAsD,SAASA,iBAAT,CAA2BC,KAA3B,EAAkCC,eAAlC,EAAiD;EACrGA,eAAe,GAAGC,mBAAmB,CAACD,eAAD,CAArC;;EACA,IAAIE,WAAW,GAAG,KAAKhF,eAAL,CAAqB4E,iBAArB,CAAuCC,KAAvC,EAA8CC,eAA9C,CAAlB;;EACA7D,eAAe,CAAC+D,WAAD,CAAf;EACA,OAAOA,WAAP;AACD,CALD;;AAOApG,uBAAuB,CAAC4C,SAAxB,CAAkCyD,mBAAlC,GAAwD,SAASA,mBAAT,GAA4B;EAClF,IAAIrD,IAAI,GAAG,GAAGC,KAAH,CAAS9C,IAAT,CAAcuC,SAAd,CAAX;EACA,IAAI4D,WAAW,GAAGtD,IAAI,CAAC,CAAD,CAAtB,CAFkF,CAIlF;EACA;;EACA,IAAI,KAAKzB,wBAAL,CAA8BgF,IAA9B,GAAqC,CAAzC,EAA4C;IAC1C,KAAK5E,cAAL,GAAsB,IAAIV,GAAJ,CAAQ,KAAKM,wBAAb,CAAtB;;IACA,KAAKA,wBAAL,CAA8BuD,KAA9B;EACD;;EAED,IAAIb,OAAO,GAAGuC,cAAc,CAAC,IAAD,EAAO,IAAP,EAAaF,WAAb,CAA5B;EACA,OAAOtD,IAAI,CAACqB,MAAL,GAAc,CAAd,GACHzE,IAAI,CAAC0E,aAAL,CAAmBL,OAAnB,EAA4BjB,IAAI,CAAC,CAAD,CAAhC,EAAqCA,IAAI,CAAC,CAAD,CAAzC,CADG,GAEHiB,OAFJ;AAGD,CAfD;;AAiBAjE,uBAAuB,CAAC4C,SAAxB,CAAkC6B,oBAAlC,GAAyD,SAASA,oBAAT,GAA6B;EACpF,IAAIzB,IAAI,GAAG,GAAGC,KAAH,CAAS9C,IAAT,CAAcuC,SAAd,CAAX;EACA,IAAI4D,WAAW,GAAGtD,IAAI,CAAC,CAAD,CAAtB,CAFoF,CAIpF;EACA;;EACA,KAAKzB,wBAAL,CAA8BuD,KAA9B;;EAEA,IAAIb,OAAO,GAAGuC,cAAc,CAAC,IAAD,EAAO,KAAP,EAAcF,WAAd,CAA5B;EACA,OAAOtD,IAAI,CAACqB,MAAL,GAAc,CAAd,GACHzE,IAAI,CAAC0E,aAAL,CAAmBL,OAAnB,EAA4BjB,IAAI,CAAC,CAAD,CAAhC,EAAqCA,IAAI,CAAC,CAAD,CAAzC,CADG,GAEHiB,OAFJ;AAGD,CAZD;;AAcArE,IAAI,CAAC6G,eAAL,CACE5F,iBAAiB,CAAC+B,SADpB,EAEE5C,uBAAuB,CAAC4C,SAF1B,EAGE,iBAHF,E,CAKA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS4D,cAAT,CAAwB5F,cAAxB,EAAwC8F,KAAxC,EAA+CJ,WAA/C,EAA0D;EACxD,SAASK,oBAAT,CAA8BZ,KAA9B,EAAmC;IACjC,IAAIW,KAAJ,EAAW;MACT9F,cAAc,CAACS,kBAAf,GAAoC0E,KAApC;IACD,CAFD,MAEO;MACLnF,cAAc,CAACU,mBAAf,GAAqCyE,KAArC;IACD;EACF;;EAED,SAASa,sBAAT,GAA+B;IAC7B,IAAIF,KAAJ,EAAW;MACT9F,cAAc,CAACS,kBAAf,GAAoC,IAApC;IACD,CAFD,MAEO;MACLT,cAAc,CAACU,mBAAf,GAAqC,IAArC;IACD;EACF;;EAED,IAAIuF,iBAAiB,GAAGH,KAAK,GAAG9F,cAAc,CAACS,kBAAlB,GAAuCT,cAAc,CAACU,mBAAnF;EACA,IAAIwF,kBAAkB,GAAGJ,KAAK,GAAG9F,cAAc,CAACU,mBAAlB,GAAwCV,cAAc,CAACS,kBAArF;EACA,IAAI0F,iBAAiB,GAAGL,KAAK,GAAG,kBAAH,GAAwB,mBAArD;EACA,IAAIL,mBAAmB,GAAGK,KAAK,GAAG,qBAAH,GAA2B,sBAA1D;EACA,IAAIzC,OAAJ;;EAEA,IAAI,CAACyC,KAAD,IAAUI,kBAAV,IAAgCR,WAAW,CAACvB,IAAZ,KAAqB,QAAzD,EAAmE;IACjEd,OAAO,GAAG+C,eAAe,CAACpG,cAAD,EAAiB0F,WAAjB,CAAzB;EACD,CAFD,MAEO,IAAIA,WAAW,CAACvB,IAAZ,KAAqB,OAAzB,EAAkC;IACvC,IAAInE,cAAc,CAACoB,cAAf,KAAkC+E,iBAAlC,IAAuDnG,cAAc,CAACoB,cAAf,KAAkC,QAA7F,EAAuG;MACrG;MACA,OAAO4D,OAAO,CAACC,MAAR,CAAe,IAAI1C,KAAJ,CAAU,iBAAiBuD,KAAK,GAAG,OAAH,GAAa,QAAnC,IAC9B,kBAD8B,GACT9F,cAAc,CAACoB,cADhB,CAAf,CAAP;IAED,CALsC,CAOvC;IACA;IACA;IACA;;;IACA,IAAI,CAAC6E,iBAAD,IAAsBjG,cAAc,CAACc,oBAAf,CAAoCuF,KAApC,KAA8C,KAAxE,EAA+E;MAC7ErG,cAAc,CAACc,oBAAf,CAAoCwF,KAApC;IACD;;IACD,IAAIC,sBAAsB,GAAGvG,cAAc,CAACoB,cAA5C;IACA2E,oBAAoB,CAACS,MAAM,CAACd,WAAD,CAAP,CAApB;IACArC,OAAO,GAAG2B,OAAO,CAACyB,OAAR,EAAV,CAhBuC,CAkBvC;;IACA,IAAIzG,cAAc,CAACoB,cAAf,KAAkCmF,sBAAtC,EAA8D;MAC5DlD,OAAO,CAACE,IAAR,CAAa,SAASmD,iCAAT,GAA0C;QACrD1G,cAAc,CAAC2B,aAAf,CAA6B,IAAIgF,KAAJ,CAAU,sBAAV,CAA7B;MACD,CAFD;IAGD;EAEF,CAzBM,MAyBA,IAAIjB,WAAW,CAACvB,IAAZ,KAAqB,UAAzB,EAAqC;IAC1C,IAAInE,cAAc,CAACoB,cAAf,KAAkC+E,iBAAtC,EAAyD;MACvD;MACA9C,OAAO,GAAG2B,OAAO,CAACC,MAAR,CAAe,IAAI1C,KAAJ,CAAU,sBAChCuD,KAAK,GAAG,OAAH,GAAa,QADc,IACF,kBADE,GACmB9F,cAAc,CAACoB,cAD5C,CAAf,CAAV;IAED,CAJD,MAIO;MACL;MACA4E,sBAAsB,GAFjB,CAIL;MACA;MACA;MACA;;MACAhG,cAAc,CAACW,wBAAf,GAA0C,IAAIN,GAAJ,CAAQL,cAAc,CAACe,cAAvB,CAA1C;MACAf,cAAc,CAACe,cAAf,GAAgC,IAAIV,GAAJ,CAAQL,cAAc,CAACG,qBAAvB,CAAhC;MAEAkD,OAAO,GAAG2B,OAAO,CAACyB,OAAR,EAAV;MACApD,OAAO,CAACE,IAAR,CAAa,SAASmD,iCAAT,GAA0C;QACrD1G,cAAc,CAAC2B,aAAf,CAA6B,IAAIgF,KAAJ,CAAU,sBAAV,CAA7B;MACD,CAFD;IAGD;EACF;;EAED,OAAOtD,OAAO,IAAIrD,cAAc,CAACQ,eAAf,CAA+BiF,mBAA/B,EAAoDe,MAAM,CAACd,WAAD,CAA1D,CAAlB;AACD;;AAED,SAASU,eAAT,CAAyBpG,cAAzB,EAAyCiE,MAAzC,EAA+C;EAC7C;EACA,IAAIgC,iBAAiB,GAAGjG,cAAc,CAACS,kBAAvC;EACA,OAAOT,cAAc,CAACQ,eAAf,CAA+BiF,mBAA/B,CAAmDQ,iBAAnD,EAAsE1C,IAAtE,CAA2E,SAASqD,sBAAT,GAA+B;IAC/G5G,cAAc,CAACS,kBAAf,GAAoC,IAApC;IACA,OAAOT,cAAc,CAAC6D,oBAAf,CAAoCI,MAApC,CAAP;EACD,CAHM,EAGJV,IAHI,CAGC,SAASsD,wBAAT,GAAiC;IACvC;IACA;IACA;IACA7G,cAAc,CAACc,oBAAf,CAAoCiD,KAApC;EACD,CARM,CAAP;AASD;AAED;;;;;;;;;AAOA,SAASa,2BAAT,CAAqC5E,cAArC,EAAqDyC,IAArD,EAAyD;EACvD,OAAO,CAAC,CAACzC,cAAc,CAAC8G,eAAf,GAAiCC,IAAjC,CAAsC,UAASC,WAAT,EAAoB;IACjE,OAAOA,WAAW,CAACC,QAAZ,IAAwBD,WAAW,CAACC,QAAZ,CAAqB3E,KAA7C,IAAsD0E,WAAW,CAACC,QAAZ,CAAqB3E,KAArB,CAA2BG,IAA3B,KAAoCA,IAAjG;EACD,CAFQ,CAAT;AAGD;;AAED,SAAS+D,MAAT,CAAgBd,WAAhB,EAA2B;EACzB,IAAIA,WAAW,YAAYlH,2BAA3B,EAAwD;IACtD,IAAIkH,WAAW,CAACwB,YAAhB,EAA8B;MAC5B,OAAOxB,WAAW,CAACwB,YAAnB;IACD;EACF;;EACD,OAAO,IAAIC,qBAAJ,CAA0BzB,WAA1B,CAAP;AACD;AAED;;;;;;;;;;AAQA,SAAS0B,0BAAT,GAAmC;EACjC,OAAO,uBAAuBC,cAAc,CAACrF,SAAtC,IACF,EAAE,uBAAuBqF,cAAc,CAACrF,SAAxC,CADL;AAED;AAED;;;;;;;;AAMA,SAASuD,mBAAT,CAA6BD,eAA7B,EAA4C;EAC1CA,eAAe,GAAG7F,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB4F,eAAlB,CAAlB;;EACA,IAAI8B,0BAA0B,MAAM,uBAAuB9B,eAA3D,EAA4E;IAC1EA,eAAe,CAACgC,iBAAhB,GAAoChC,eAAe,CAACiC,iBAApD;EACD;;EACD,OAAOjC,eAAP;AACD;AAED;;;;;;;;AAMA,SAAS7D,eAAT,CAAyB+D,WAAzB,EAAoC;EAClC/F,MAAM,CAAC+H,cAAP,CAAsBhC,WAAtB,EAAmC,gBAAnC,EAAqD;IACnDpF,KAAK,EAAEoF,WAAW,CAACiC,cAAZ,KAA+B,KAA/B,GACH,IADG,GAEHjC,WAAW,CAACiC;EAHmC,CAArD;;EAKA,IAAIL,0BAA0B,EAA9B,EAAkC;IAChC;IACA;IACA;IACA;IACA3H,MAAM,CAAC+H,cAAP,CAAsBhC,WAAtB,EAAmC,mBAAnC,EAAwD;MACtDpF,KAAK,EAAEoF,WAAW,CAAC8B,iBAAZ,KAAkC,KAAlC,GACH,IADG,GAEH9B,WAAW,CAAC8B;IAHsC,CAAxD;EAKD;;EACD,OAAO9B,WAAP;AACD;AAED;;;;;;;;;;;AASA,SAASnB,qBAAT,CAA+BvE,SAA/B,EAA0C4H,aAA1C,EAAyDtD,GAAzD,EAA4D;EAC1D,OAAOtE,SAAS,KAAK,SAAd,GACHf,QAAQ,CAAC4I,gCAAT,CAA0CD,aAA1C,EAAyDtD,GAAzD,CADG,GAEHrF,QAAQ,CAAC6I,0BAAT,CAAoCF,aAApC,EAAmDtD,GAAnD,CAFJ;AAGD;;AAEDyD,MAAM,CAACC,OAAP,GAAiB1I,uBAAjB","names":["ChromeRTCSessionDescription","require","EventTarget","inherits","Latch","MediaStream","RTCRtpSenderShim","sdpUtils","util","isIOSChrome","isUnifiedPlan","getSdpFormat","ChromeRTCPeerConnection","configuration","constraints","call","newConfiguration","Object","assign","iceTransportPolicy","iceTransports","interceptEvent","sdpFormat","sdpSemantics","peerConnection","RTCPeerConnection","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_localStream","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_sdpFormat","_senders","_signalingStateLatch","_tracksToSSRCs","localDescription","enumerable","get","remoteDescription","signalingState","self","addEventListener","ondatachannel","event","shimDataChannel","channel","dispatchEvent","onsignalingstatechange","apply","arguments","ontrack","prototype","addTrack","addStream","proxyProperties","args","slice","track","Error","id","kind","sender","removeStream","set","removeTrack","getSenders","Array","from","values","e","addIceCandidate","candidate","promise","when","then","signalingStatesResolved","length","legacyPromise","close","createAnswer","setRemoteDescription","setRemoteDescriptionSucceeded","lower","createAnswerSucceeded","answer","clear","type","sdp","updateTrackIdsToSSRCs","setRemoteDescriptionOrCreateAnswerFailed","error","createOffer","options","offerToReceiveVideo","_audioTransceiver","hasReceiversForTracksOfKind","offerToReceiveAudio","addTransceiver","direction","Promise","reject","_videoTransceiver","offer","createDataChannel","label","dataChannelDict","shimDataChannelInit","dataChannel","setLocalDescription","description","size","setDescription","delegateMethods","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setRemoteAnswer","state","raise","previousSignalingState","unwrap","resolve","dispatchSignalingStateChangeEvent","Event","setLocalOfferSucceeded","setRemoteAnswerSucceeded","getTransceivers","find","transceiver","receiver","_description","RTCSessionDescription","needsMaxPacketLifeTimeShim","RTCDataChannel","maxRetransmitTime","maxPacketLifeTime","defineProperty","maxRetransmits","tracksToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","updatePlanBTrackIdsToSSRCs","module","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/chrome.js"],"sourcesContent":["/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\nvar EventTarget = require('../util/eventtarget');\nvar inherits = require('../../vendor/inherits');\nvar Latch = require('../util/latch');\nvar MediaStream = require('../mediastream');\nvar RTCRtpSenderShim = require('../rtcrtpsender');\nvar sdpUtils = require('../util/sdp');\nvar util = require('../util');\nvar isIOSChrome = require('../util').isIOSChrome;\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\n\n// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\nfunction ChromeRTCPeerConnection(configuration, constraints) {\n  if (!(this instanceof ChromeRTCPeerConnection)) {\n    return new ChromeRTCPeerConnection(configuration, constraints);\n  }\n\n  EventTarget.call(this);\n\n  configuration = configuration || {};\n  var newConfiguration = Object.assign(configuration.iceTransportPolicy\n    ? { iceTransports: configuration.iceTransportPolicy }\n    : {}, configuration);\n\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'signalingstatechange');\n\n  var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);\n  var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _localStream: {\n      value: new MediaStream()\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _sdpFormat: {\n      value: sdpFormat\n    },\n    _senders: {\n      value: new Map()\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function() {\n        if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n        return peerConnection.signalingState;\n      }\n    }\n  });\n\n  var self = this;\n\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  });\n\n  peerConnection.ontrack = function ontrack() {\n    // NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n    // the ontrack property of the RTCPeerConnection.\n  };\n\n  if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n    peerConnection.addStream(this._localStream);\n  }\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(ChromeRTCPeerConnection, EventTarget);\n\nif (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var args = [].slice.call(arguments);\n    var track = args[0];\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '\n        + track.kind + ']: RTCPeerConnection is closed');\n    }\n\n    var sender = this._senders.get(track);\n    if (sender && sender.track) {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '\n        + track.kind + ']: RTCPeerConnection already has it');\n    }\n    this._peerConnection.removeStream(this._localStream);\n    this._localStream.addTrack(track);\n    this._peerConnection.addStream(this._localStream);\n\n    sender = new RTCRtpSenderShim(track);\n    this._senders.set(track, sender);\n    return sender;\n  };\n\n  // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    var track = sender.track;\n    if (!track) {\n      return;\n    }\n    sender = this._senders.get(track);\n    if (sender && sender.track) {\n      sender.track = null;\n      this._peerConnection.removeStream(this._localStream);\n      this._localStream.removeTrack(track);\n      this._peerConnection.addStream(this._localStream);\n    }\n  };\n\n  ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {\n    return Array.from(this._senders.values());\n  };\n} else {\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n    try {\n      this._peerConnection.removeTrack(sender);\n    } catch (e) {\n      // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n      // created by this peer connection'. This behavior does not seem to be\n      // spec compliant, so a temporary shim is introduced. A bug has been filed,\n      // and is tracked here:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n    }\n  };\n}\n\nChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n    // \"have-remote-offer\" signalingStates, we only want to invoke the true\n    // addIceCandidates method when the remote description has been applied.\n    promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  } else {\n    promise = this._peerConnection.addIceCandidate(candidate);\n  }\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[1], args[2])\n    : promise;\n};\n\n// NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n// Error; however, in Chrome it does. We workaround this by checking the\n// signalingState manually.\nChromeRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._pendingLocalOffer = null;\n    this._pendingRemoteOffer = null;\n    this._peerConnection.close();\n  }\n};\n\n// NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n// \"faking\" setRemoteDescription, we cannot create an answer until we actually\n// apply the remote description. This means, once you call createAnswer, you\n// can no longer rollback. This is acceptable for our use case because we will\n// apply the newly-created answer almost immediately; however, this may be\n// unacceptable for other use cases.\nChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n      // and the underlying RTCPeerConnection implementation have converged. We\n      // can unblock any pending calls to addIceCandidate now.\n      self._signalingStateLatch.lower();\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null;\n\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  } else {\n    promise = this._peerConnection.createAnswer().then(function(answer) {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    });\n  }\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[0], args[1])\n    : promise;\n};\n\nChromeRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var self = this;\n\n  if (isIOSChrome()) {\n    // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n      delete options.offerToReceiveAudio;\n      try {\n        this._audioTransceiver = isUnifiedPlan\n          ? this.addTransceiver('audio', { direction: 'recvonly' })\n          : this.addTransceiver('audio');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n      delete options.offerToReceiveVideo;\n      try {\n        this._videoTransceiver = isUnifiedPlan\n          ? this.addTransceiver('video', { direction: 'recvonly' })\n          : this.addTransceiver('video');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n  }\n\n  var promise = this._peerConnection.createOffer(options).then(function(offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new ChromeRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)\n    });\n  });\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[0], args[1])\n    : promise;\n};\n\nChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  dataChannelDict = shimDataChannelInit(dataChannelDict);\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n\n  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  var promise = setDescription(this, true, description);\n  return args.length > 1\n    ? util.legacyPromise(promise, args[1], args[2])\n    : promise;\n};\n\nChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n\n  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n  this._rolledBackTracksToSSRCs.clear();\n\n  var promise = setDescription(this, false, description);\n  return args.length > 1\n    ? util.legacyPromise(promise, args[1], args[2])\n    : promise;\n};\n\nutil.delegateMethods(\n  RTCPeerConnection.prototype,\n  ChromeRTCPeerConnection.prototype,\n  '_peerConnection');\n\n// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  var promise;\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +\n        ' offer in state ' + peerConnection.signalingState));\n    }\n\n    // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve();\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error('Cannot rollback ' +\n        (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer();\n\n      // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n      promise = Promise.resolve();\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  }\n\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function(transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n  return new RTCSessionDescription(description);\n}\n\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype\n    && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n  return dataChannelDict;\n}\n\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535\n      ? null\n      : dataChannel.maxRetransmits\n  });\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535\n        ? null\n        : dataChannel.maxRetransmitTime\n    });\n  }\n  return dataChannel;\n}\n\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified'\n    ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp)\n    : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\n\nmodule.exports = ChromeRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script"}