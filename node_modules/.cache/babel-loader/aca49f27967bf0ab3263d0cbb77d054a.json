{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar _a = require('../'),\n    difference = _a.difference,\n    flatMap = _a.flatMap;\n/**\n * Create a random {@link SSRC}.\n * @returns {SSRC}\n */\n\n\nfunction createSSRC() {\n  var ssrcMax = 0xffffffff;\n  return String(Math.floor(Math.random() * ssrcMax));\n}\n/**\n * @property {string} cName\n * @property {boolean} isSimulcastEnabled\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\n * @property {Set<PrimarySSRC>} primarySSRCs\n * @property {string} streamId\n * @property {Track.ID} trackId\n */\n\n\nvar TrackAttributes =\n/** @class */\nfunction () {\n  /**\n   * Construct a {@link MediaStreamTrack} attribute store.\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\n   * @param {MediaStreamID} streamId - The MediaStream ID\n   * @param {string} cName - The MediaStream cname\n   */\n  function TrackAttributes(trackId, streamId, cName) {\n    Object.defineProperties(this, {\n      cName: {\n        enumerable: true,\n        value: cName\n      },\n      isSimulcastEnabled: {\n        enumerable: true,\n        value: false,\n        writable: true\n      },\n      primarySSRCs: {\n        enumerable: true,\n        value: new Set()\n      },\n      rtxPairs: {\n        enumerable: true,\n        value: new Map()\n      },\n      streamId: {\n        enumerable: true,\n        value: streamId\n      },\n      trackId: {\n        enumerable: true,\n        value: trackId\n      }\n    });\n  }\n  /**\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\n   * @returns {void}\n   */\n\n\n  TrackAttributes.prototype.addSimulcastSSRCs = function () {\n    if (this.isSimulcastEnabled) {\n      return;\n    }\n\n    var simulcastSSRCs = [createSSRC(), createSSRC()];\n    simulcastSSRCs.forEach(function (ssrc) {\n      this.primarySSRCs.add(ssrc);\n    }, this);\n\n    if (this.rtxPairs.size) {\n      simulcastSSRCs.forEach(function (ssrc) {\n        this.rtxPairs.set(createSSRC(), ssrc);\n      }, this);\n    }\n  };\n  /**\n   * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\n   * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\n   * @param {SSRC} ssrc - The {@link SSRC} to be added\n   * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\n   *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\n   * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\n   *   {@link SimSSRC}; false otherwise\n   * @returns {void}\n   */\n\n\n  TrackAttributes.prototype.addSSRC = function (ssrc, primarySSRC, isSimSSRC) {\n    if (primarySSRC) {\n      this.rtxPairs.set(ssrc, primarySSRC);\n    } else {\n      this.primarySSRCs.add(ssrc);\n    }\n\n    this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\n  };\n  /**\n   * Construct the SDP lines for the {@link TrackAttributes}.\n   * @param {boolean} [excludeRtx=false]\n   * @returns {Array<string>} Array of SDP lines\n   */\n\n\n  TrackAttributes.prototype.toSdpLines = function (excludeRtx) {\n    var _this = this;\n\n    var rtxPairs = excludeRtx ? [] : Array.from(this.rtxPairs.entries()).map(function (rtxPair) {\n      return rtxPair.reverse();\n    });\n    var simSSRCs = Array.from(this.primarySSRCs.values());\n    var ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\n    var attrLines = flatMap(ssrcs, function (ssrc) {\n      return [\"a=ssrc:\" + ssrc + \" cname:\" + _this.cName, \"a=ssrc:\" + ssrc + \" msid:\" + _this.streamId + \" \" + _this.trackId];\n    });\n    var rtxPairLines = rtxPairs.map(function (rtxPair) {\n      return \"a=ssrc-group:FID \" + rtxPair.join(' ');\n    });\n    var simGroupLines = [\"a=ssrc-group:SIM \" + simSSRCs.join(' ')];\n    return rtxPairLines.concat(attrLines).concat(simGroupLines);\n  };\n\n  return TrackAttributes;\n}();\n/**\n * Get the matches for a given RegEx pattern.\n * @param {string} section - SDP media section\n * @param {string} pattern - RegEx pattern\n * @returns {Array<Array<string>>} - Array of pattern matches\n */\n\n\nfunction getMatches(section, pattern) {\n  var matches = section.match(new RegExp(pattern, 'gm')) || [];\n  return matches.map(function (match) {\n    var matches = match.match(new RegExp(pattern)) || [];\n    return matches.slice(1);\n  });\n}\n/**\n * Get the {@link SimSSRC}s that belong to a simulcast group.\n * @param {string} section - SDP media section\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\n */\n\n\nfunction getSimulcastSSRCs(section) {\n  var simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\n}\n/**\n * Get the value of the given attribute for an SSRC.\n * @param {string} section - SDP media section\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\n * @param {string} attribute - {@link SSRC} attribute name\n * @param {string} - {@link SSRC} attribute value\n */\n\n\nfunction getSSRCAttribute(section, ssrc, attribute) {\n  var pattern = \"a=ssrc:\" + ssrc + \" \" + attribute + \":(.+)\";\n  return section.match(new RegExp(pattern))[1];\n}\n/**\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\n * @param {string} section - SDP media section\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\n *   corresponding {@link PrimarySSRC}s\n */\n\n\nfunction getSSRCRtxPairs(section) {\n  var rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\n  return new Map(getMatches(section, rtxPairPattern).map(function (pair) {\n    return pair.reverse();\n  }));\n}\n/**\n * Create SSRC attribute tuples.\n * @param {string} section\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\n */\n\n\nfunction createSSRCAttributeTuples(section) {\n  var _a = __read(flatMap(getMatches(section, '^a=msid:(.+) (.+)$')), 2),\n      streamId = _a[0],\n      trackId = _a[1];\n\n  var ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\n  return ssrcs.map(function (ssrc) {\n    return [ssrc, streamId, trackId];\n  });\n}\n/**\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\n * @param {string} section - SDP media section\n * @returns {Map<Track.ID, TrackAttributes>}\n */\n\n\nfunction createTrackIdsToAttributes(section) {\n  var simSSRCs = getSimulcastSSRCs(section);\n  var rtxPairs = getSSRCRtxPairs(section);\n  var ssrcAttrTuples = createSSRCAttributeTuples(section);\n  return ssrcAttrTuples.reduce(function (trackIdsToSSRCs, tuple) {\n    var ssrc = tuple[0];\n    var streamId = tuple[1];\n    var trackId = tuple[2];\n    var trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(trackId, streamId, getSSRCAttribute(section, ssrc, 'cname'));\n    var primarySSRC = rtxPairs.get(ssrc) || null;\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\n  }, new Map());\n}\n/**\n * Apply simulcast settings to the given SDP media section.\n * @param {string} section - SDP media section\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\n *   map which will be updated for new MediaStreamTrack IDs\n * @returns {string} - The transformed SDP media section\n */\n\n\nfunction setSimulcastInMediaSection(section, trackIdsToAttributes) {\n  var newTrackIdsToAttributes = createTrackIdsToAttributes(section);\n  var newTrackIds = Array.from(newTrackIdsToAttributes.keys());\n  var trackIds = Array.from(trackIdsToAttributes.keys());\n  var trackIdsToAdd = difference(newTrackIds, trackIds);\n  var trackIdsToIgnore = difference(trackIds, newTrackIds); // Update \"trackIdsToAttributes\" with TrackAttributes for new\n  // MediaStreamTrack IDs.\n\n  var trackAttributesToAdd = flatMap(trackIdsToAdd, function (trackId) {\n    return newTrackIdsToAttributes.get(trackId);\n  });\n  trackAttributesToAdd.forEach(function (trackAttributes) {\n    trackAttributes.addSimulcastSSRCs();\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\n  }); // Get the SDP lines of the relevant MediaStreamTrack IDs from\n  // \"trackIdsToAttributes\".\n\n  trackIds = Array.from(trackIdsToAttributes.keys());\n  var relevantTrackIds = difference(trackIds, trackIdsToIgnore);\n  var relevantTrackAttributes = flatMap(relevantTrackIds, function (trackId) {\n    return trackIdsToAttributes.get(trackId);\n  });\n  var excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\n  var relevantSdpLines = flatMap(relevantTrackAttributes, function (trackAttributes) {\n    return trackAttributes.toSdpLines(excludeRtx);\n  }); // Add the simulcast SSRC SDP lines to the media section. The Set ensures\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\n  // \"relevantSdpLines\" are removed.\n\n  var sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\n  var xGoogleFlagConference = 'a=x-google-flag:conference';\n\n  if (!section.match(xGoogleFlagConference)) {\n    sectionLines.push(xGoogleFlagConference);\n  }\n\n  return sectionLines.join('\\r\\n');\n}\n/**\n * String representing a MediaStream ID.\n * @typedef {string} MediaStreamID\n */\n\n/**\n * String representing the SSRC of a MediaStreamTrack.\n * @typedef {string} SSRC\n */\n\n/**\n * Primary SSRC.\n * @typedef {SSRC} PrimarySSRC\n */\n\n/**\n * Retransmission SSRC.\n * @typedef {SSRC} RtxSSRC\n */\n\n/**\n * Simulcast SSRC.\n * @typedef {SSRC} SimSSRC\n */\n\n\nmodule.exports = setSimulcastInMediaSection;","map":{"version":3,"mappings":"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","names":["require","difference","flatMap","createSSRC","ssrcMax","String","Math","floor","random","trackId","streamId","cName","Object","defineProperties","enumerable","value","isSimulcastEnabled","writable","primarySSRCs","Set","rtxPairs","Map","TrackAttributes","simulcastSSRCs","forEach","ssrc","add","size","set","primarySSRC","isSimSSRC","excludeRtx","Array","from","entries","map","reverse","simSSRCs","values","ssrcs","length","attrLines","_this","rtxPairLines","rtxPair","join","simGroupLines","concat","getMatches","section","pattern","matches","match","RegExp","slice","getSimulcastSSRCs","simGroupPattern","getSSRCAttribute","attribute","getSSRCRtxPairs","rtxPairPattern","createSSRCAttributeTuples","createTrackIdsToAttributes","ssrcAttrTuples","reduce","trackIdsToSSRCs","tuple","trackAttributes","get","addSSRC","has","setSimulcastInMediaSection","trackIdsToAttributes","newTrackIdsToAttributes","newTrackIds","keys","trackIds","trackIdsToAdd","trackIdsToIgnore","trackAttributesToAdd","addSimulcastSSRCs","relevantTrackIds","relevantTrackAttributes","relevantSdpLines","toSdpLines","sectionLines","split","xGoogleFlagConference","push","module","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/util/sdp/simulcast.js"],"sourcesContent":["'use strict';\n\nconst { difference, flatMap } = require('../');\n\n/**\n * Create a random {@link SSRC}.\n * @returns {SSRC}\n */\nfunction createSSRC() {\n  const ssrcMax = 0xffffffff;\n  return String(Math.floor(Math.random() * ssrcMax));\n}\n\n/**\n * @property {string} cName\n * @property {boolean} isSimulcastEnabled\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\n * @property {Set<PrimarySSRC>} primarySSRCs\n * @property {string} streamId\n * @property {Track.ID} trackId\n */\nclass TrackAttributes {\n  /**\n   * Construct a {@link MediaStreamTrack} attribute store.\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\n   * @param {MediaStreamID} streamId - The MediaStream ID\n   * @param {string} cName - The MediaStream cname\n   */\n  constructor(trackId, streamId, cName) {\n    Object.defineProperties(this, {\n      cName: {\n        enumerable: true,\n        value: cName\n      },\n      isSimulcastEnabled: {\n        enumerable: true,\n        value: false,\n        writable: true\n      },\n      primarySSRCs: {\n        enumerable: true,\n        value: new Set()\n      },\n      rtxPairs: {\n        enumerable: true,\n        value: new Map()\n      },\n      streamId: {\n        enumerable: true,\n        value: streamId\n      },\n      trackId: {\n        enumerable: true,\n        value: trackId\n      }\n    });\n  }\n\n  /**\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\n   * @returns {void}\n   */\n  addSimulcastSSRCs() {\n    if (this.isSimulcastEnabled) {\n      return;\n    }\n    const simulcastSSRCs = [createSSRC(), createSSRC()];\n    simulcastSSRCs.forEach(function(ssrc) {\n      this.primarySSRCs.add(ssrc);\n    }, this);\n\n    if (this.rtxPairs.size) {\n      simulcastSSRCs.forEach(function(ssrc) {\n        this.rtxPairs.set(createSSRC(), ssrc);\n      }, this);\n    }\n  }\n\n  /**\n   * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\n   * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\n   * @param {SSRC} ssrc - The {@link SSRC} to be added\n   * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\n   *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\n   * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\n   *   {@link SimSSRC}; false otherwise\n   * @returns {void}\n   */\n  addSSRC(ssrc, primarySSRC, isSimSSRC) {\n    if (primarySSRC) {\n      this.rtxPairs.set(ssrc, primarySSRC);\n    } else {\n      this.primarySSRCs.add(ssrc);\n    }\n    this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\n  }\n\n  /**\n   * Construct the SDP lines for the {@link TrackAttributes}.\n   * @param {boolean} [excludeRtx=false]\n   * @returns {Array<string>} Array of SDP lines\n   */\n  toSdpLines(excludeRtx) {\n    const rtxPairs = excludeRtx\n      ? []\n      : Array.from(this.rtxPairs.entries()).map(rtxPair => rtxPair.reverse());\n\n    const simSSRCs = Array.from(this.primarySSRCs.values());\n    const ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\n\n    const attrLines = flatMap(ssrcs, ssrc => [\n      `a=ssrc:${ssrc} cname:${this.cName}`,\n      `a=ssrc:${ssrc} msid:${this.streamId} ${this.trackId}`\n    ]);\n    const rtxPairLines = rtxPairs.map(rtxPair => `a=ssrc-group:FID ${rtxPair.join(' ')}`);\n    const simGroupLines = [\n      `a=ssrc-group:SIM ${simSSRCs.join(' ')}`\n    ];\n\n    return rtxPairLines.concat(attrLines).concat(simGroupLines);\n  }\n}\n\n/**\n * Get the matches for a given RegEx pattern.\n * @param {string} section - SDP media section\n * @param {string} pattern - RegEx pattern\n * @returns {Array<Array<string>>} - Array of pattern matches\n */\nfunction getMatches(section, pattern) {\n  const matches = section.match(new RegExp(pattern, 'gm')) || [];\n  return matches.map(match => {\n    const matches = match.match(new RegExp(pattern)) || [];\n    return matches.slice(1);\n  });\n}\n\n/**\n * Get the {@link SimSSRC}s that belong to a simulcast group.\n * @param {string} section - SDP media section\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\n */\nfunction getSimulcastSSRCs(section) {\n  const simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\n}\n\n/**\n * Get the value of the given attribute for an SSRC.\n * @param {string} section - SDP media section\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\n * @param {string} attribute - {@link SSRC} attribute name\n * @param {string} - {@link SSRC} attribute value\n */\nfunction getSSRCAttribute(section, ssrc, attribute) {\n  const pattern = `a=ssrc:${ssrc} ${attribute}:(.+)`;\n  return section.match(new RegExp(pattern))[1];\n}\n\n/**\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\n * @param {string} section - SDP media section\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\n *   corresponding {@link PrimarySSRC}s\n */\nfunction getSSRCRtxPairs(section) {\n  const rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\n  return new Map(getMatches(section, rtxPairPattern).map(pair => pair.reverse()));\n}\n\n/**\n * Create SSRC attribute tuples.\n * @param {string} section\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\n */\nfunction createSSRCAttributeTuples(section) {\n  const [streamId, trackId] = flatMap(getMatches(section, '^a=msid:(.+) (.+)$'));\n  const ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\n  return ssrcs.map(ssrc => [ssrc, streamId, trackId]);\n}\n\n/**\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\n * @param {string} section - SDP media section\n * @returns {Map<Track.ID, TrackAttributes>}\n */\nfunction createTrackIdsToAttributes(section) {\n  const simSSRCs = getSimulcastSSRCs(section);\n  const rtxPairs = getSSRCRtxPairs(section);\n  const ssrcAttrTuples = createSSRCAttributeTuples(section);\n\n  return ssrcAttrTuples.reduce((trackIdsToSSRCs, tuple) => {\n    const ssrc = tuple[0];\n    const streamId = tuple[1];\n    const trackId = tuple[2];\n\n    const trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(\n      trackId,\n      streamId,\n      getSSRCAttribute(section, ssrc, 'cname'));\n\n    const primarySSRC = rtxPairs.get(ssrc) || null;\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\n  }, new Map());\n}\n\n/**\n * Apply simulcast settings to the given SDP media section.\n * @param {string} section - SDP media section\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\n *   map which will be updated for new MediaStreamTrack IDs\n * @returns {string} - The transformed SDP media section\n */\nfunction setSimulcastInMediaSection(section, trackIdsToAttributes) {\n  const newTrackIdsToAttributes = createTrackIdsToAttributes(section);\n  const newTrackIds = Array.from(newTrackIdsToAttributes.keys());\n  let trackIds = Array.from(trackIdsToAttributes.keys());\n  const trackIdsToAdd = difference(newTrackIds, trackIds);\n  const trackIdsToIgnore = difference(trackIds, newTrackIds);\n\n  // Update \"trackIdsToAttributes\" with TrackAttributes for new\n  // MediaStreamTrack IDs.\n  const trackAttributesToAdd = flatMap(trackIdsToAdd, trackId => newTrackIdsToAttributes.get(trackId));\n  trackAttributesToAdd.forEach(trackAttributes => {\n    trackAttributes.addSimulcastSSRCs();\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\n  });\n\n  // Get the SDP lines of the relevant MediaStreamTrack IDs from\n  // \"trackIdsToAttributes\".\n  trackIds = Array.from(trackIdsToAttributes.keys());\n  const relevantTrackIds = difference(trackIds, trackIdsToIgnore);\n  const relevantTrackAttributes = flatMap(relevantTrackIds, trackId => trackIdsToAttributes.get(trackId));\n  const excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\n  const relevantSdpLines = flatMap(relevantTrackAttributes, trackAttributes => trackAttributes.toSdpLines(excludeRtx));\n\n  // Add the simulcast SSRC SDP lines to the media section. The Set ensures\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\n  // \"relevantSdpLines\" are removed.\n  const sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\n\n  const xGoogleFlagConference = 'a=x-google-flag:conference';\n  if (!section.match(xGoogleFlagConference)) {\n    sectionLines.push(xGoogleFlagConference);\n  }\n\n  return sectionLines.join('\\r\\n');\n}\n\n/**\n * String representing a MediaStream ID.\n * @typedef {string} MediaStreamID\n */\n\n/**\n * String representing the SSRC of a MediaStreamTrack.\n * @typedef {string} SSRC\n */\n\n/**\n * Primary SSRC.\n * @typedef {SSRC} PrimarySSRC\n */\n\n/**\n * Retransmission SSRC.\n * @typedef {SSRC} RtxSSRC\n */\n\n/**\n * Simulcast SSRC.\n * @typedef {SSRC} SimSSRC\n */\n\nmodule.exports = setSimulcastInMediaSection;\n"]},"metadata":{},"sourceType":"script"}