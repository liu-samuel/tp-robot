{"ast":null,"code":"/* eslint new-cap:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar getUserMedia = require('../../webrtc').getUserMedia;\n\nvar _a = require('../../webrtc/util'),\n    guessBrowser = _a.guessBrowser,\n    isIOSChrome = _a.isIOSChrome;\n\nvar _b = require('../../util'),\n    capitalize = _b.capitalize,\n    defer = _b.defer,\n    isUserMediaTrack = _b.isUserMediaTrack,\n    waitForSometime = _b.waitForSometime,\n    waitForEvent = _b.waitForEvent;\n\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\n\nvar detectSilentAudio = require('../../util/detectsilentaudio');\n\nvar detectSilentVideo = require('../../util/detectsilentvideo');\n\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\n\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\n\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\n\nvar MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#stopped\n   */\n  return (\n    /** @class */\n    function (_super) {\n      __extends(LocalMediaTrack, _super);\n      /**\n       * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n       * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n       * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n       */\n\n\n      function LocalMediaTrack(mediaStreamTrack, options) {\n        var _this = this; // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers\n        // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs\n        // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.\n\n\n        var workaroundWebKitBug1208516 = (guessBrowser() === 'safari' || isIOSChrome()) && isUserMediaTrack(mediaStreamTrack) && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string';\n        options = Object.assign({\n          getUserMedia: getUserMedia,\n          isCreatedByCreateLocalTracks: false,\n          workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n          gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n        }, options);\n        var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n        var kind = mediaTrackSender.kind;\n        _this = _super.call(this, mediaTrackSender, options) || this;\n        Object.defineProperties(_this, {\n          _constraints: {\n            value: typeof options[kind] === 'object' ? options[kind] : {},\n            writable: true\n          },\n          _getUserMedia: {\n            value: options.getUserMedia\n          },\n          _gUMSilentTrackWorkaround: {\n            value: options.gUMSilentTrackWorkaround\n          },\n          _workaroundWebKitBug1208516: {\n            value: options.workaroundWebKitBug1208516\n          },\n          _workaroundWebKitBug1208516Cleanup: {\n            value: null,\n            writable: true\n          },\n          _didCallEnd: {\n            value: false,\n            writable: true\n          },\n          _isCreatedByCreateLocalTracks: {\n            value: options.isCreatedByCreateLocalTracks\n          },\n          _trackSender: {\n            value: mediaTrackSender\n          },\n          id: {\n            enumerable: true,\n            value: mediaTrackSender.id\n          },\n          isEnabled: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.enabled;\n            }\n          },\n          isStopped: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.readyState === 'ended';\n            }\n          }\n        }); // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n        // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n\n        if (_this._workaroundWebKitBug1208516) {\n          _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n        }\n\n        return _this;\n      }\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._end = function () {\n        if (this._didCallEnd) {\n          return;\n        }\n\n        _super.prototype._end.call(this);\n\n        this._didCallEnd = true;\n        this.emit('stopped', this);\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._initialize = function () {\n        if (this._didCallEnd) {\n          this._didCallEnd = false;\n        }\n\n        _super.prototype._initialize.call(this);\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n        var _a;\n\n        var _b = this,\n            getUserMedia = _b._getUserMedia,\n            gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround,\n            log = _b._log,\n            kind = _b.mediaStreamTrack.kind;\n\n        log.info('Re-acquiring the MediaStreamTrack');\n        log.debug('Constraints:', constraints);\n        var gUMConstraints = Object.assign({\n          audio: false,\n          video: false\n        }, (_a = {}, _a[kind] = constraints, _a));\n        var gUMPromise = this._workaroundWebKitBug1208516Cleanup ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints) : getUserMedia(gUMConstraints);\n        return gUMPromise.then(function (mediaStream) {\n          return mediaStream.getTracks()[0];\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._restart = function (constraints) {\n        var _this = this;\n\n        var log = this._log;\n        constraints = constraints || this._constraints; // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n        // without stopping it first, then a NotReadableError is raised in case of\n        // video, or the restarted audio will still be silent. Hence, we stop the\n        // MediaStreamTrack here.\n\n        this._stop();\n\n        return this._reacquireTrack(constraints).catch(function (error) {\n          log.error('Failed to re-acquire the MediaStreamTrack:', {\n            error: error,\n            constraints: constraints\n          });\n          throw error;\n        }).then(function (newMediaStreamTrack) {\n          log.info('Re-acquired the MediaStreamTrack');\n          log.debug('MediaStreamTrack:', newMediaStreamTrack);\n          _this._constraints = Object.assign({}, constraints);\n          return _this._setMediaStreamTrack(newMediaStreamTrack);\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n        var _this = this; // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n\n\n        mediaStreamTrack.enabled = this.mediaStreamTrack.enabled; // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n        // stopped, this should fire a \"stopped\" event.\n\n        this._stop(); // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n        // the processedTrack already set, we don't want to replace that.\n\n\n        return (this._unprocessedTrack ? Promise.resolve().then(function () {\n          _this._unprocessedTrack = mediaStreamTrack;\n        }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n          _this._log.warn('setMediaStreamTrack failed:', {\n            error: error,\n            mediaStreamTrack: mediaStreamTrack\n          });\n        })).then(function () {\n          _this._initialize();\n\n          _this._getAllAttachedElements().forEach(function (el) {\n            return _this._attach(el);\n          });\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._stop = function () {\n        this.mediaStreamTrack.stop();\n\n        this._end();\n\n        return this;\n      };\n\n      LocalMediaTrack.prototype.enable = function (enabled) {\n        enabled = typeof enabled === 'boolean' ? enabled : true;\n\n        if (enabled !== this.mediaStreamTrack.enabled) {\n          this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n\n          this.mediaStreamTrack.enabled = enabled;\n          this.emit(enabled ? 'enabled' : 'disabled', this);\n        }\n\n        return this;\n      };\n\n      LocalMediaTrack.prototype.disable = function () {\n        return this.enable(false);\n      };\n\n      LocalMediaTrack.prototype.restart = function (constraints) {\n        var _this = this;\n\n        var kind = this.kind;\n\n        if (!this._isCreatedByCreateLocalTracks) {\n          return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a' + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\") + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n        }\n\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n\n        var promise = this._restart(constraints);\n\n        if (this._workaroundWebKitBug1208516) {\n          promise = promise.finally(function () {\n            _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n          });\n        }\n\n        return promise;\n      };\n\n      LocalMediaTrack.prototype.stop = function () {\n        this._log.info('Stopping');\n\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n\n        return this._stop();\n      };\n\n      return LocalMediaTrack;\n    }(AudioOrVideoTrack)\n  );\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\n\n\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  var log = localMediaTrack._log,\n      kind = localMediaTrack.kind;\n  var detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n  var el = localMediaTrack._dummyEl,\n      mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n  var trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(function () {\n      return detectSilence(el);\n    }).then(function (isSilent) {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n\n      return isSilent;\n    }).catch(function (error) {\n      log.warn('Failed to detect silence:', error);\n    }).finally(function () {\n      // Pause the dummy element again.\n      el.pause();\n    });\n  }\n\n  function shouldReacquireTrack() {\n    var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup,\n        isStopped = localMediaTrack.isStopped,\n        muted = localMediaTrack.mediaStreamTrack.muted;\n    var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup; // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n\n    return Promise.resolve().then(function () {\n      return document.visibilityState === 'visible' && !trackChangeInProgress && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([waitForEvent(mediaStreamTrack, 'unmute'), waitForSometime(50)]).then(function () {\n      return shouldReacquireTrack();\n    }).then(function (shouldReacquire) {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n\n        localMediaTrack._restart().finally(function () {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(function (error) {\n          log.error('failed to restart track: ', error);\n        });\n      } // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n\n\n      var promise = trackChangeInProgress && trackChangeInProgress.promise || Promise.resolve();\n      return promise.finally(function () {\n        return localMediaRestartDeferreds.resolveDeferred(kind);\n      });\n    }).catch(function (ex) {\n      log.error(\"error in maybeRestart: \" + ex.message);\n    });\n  }\n\n  function onMute() {\n    var log = localMediaTrack._log,\n        kind = localMediaTrack.kind;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack); // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  } // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n\n\n  var onVisibilityChange = function (isVisible) {\n    return isVisible ? maybeRestart() : false;\n  };\n\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;","map":{"version":3,"mappings":"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","names":["require","getUserMedia","guessBrowser","isIOSChrome","capitalize","defer","isUserMediaTrack","waitForSometime","waitForEvent","typeErrors","ILLEGAL_INVOKE","detectSilentAudio","detectSilentVideo","documentVisibilityMonitor","localMediaRestartDeferreds","gUMSilentTrackWorkaround","MediaTrackSender","mixinLocalMediaTrack","AudioOrVideoTrack","__extends","mediaStreamTrack","options","workaroundWebKitBug1208516","document","addEventListener","visibilityState","Object","assign","isCreatedByCreateLocalTracks","mediaTrackSender","_this","defineProperties","_constraints","value","kind","writable","_getUserMedia","_gUMSilentTrackWorkaround","_workaroundWebKitBug1208516","_workaroundWebKitBug1208516Cleanup","_didCallEnd","_isCreatedByCreateLocalTracks","_trackSender","id","enumerable","isEnabled","get","enabled","isStopped","readyState","restartWhenInadvertentlyStopped","LocalMediaTrack","_super","_end","call","emit","_initialize","constraints","log","info","debug","gUMConstraints","audio","video","_a","gUMPromise","then","mediaStream","getTracks","_log","_stop","_reacquireTrack","catch","error","newMediaStreamTrack","_setMediaStreamTrack","_unprocessedTrack","Promise","resolve","setMediaStreamTrack","warn","_getAllAttachedElements","forEach","_attach","el","stop","enable","reject","promise","_restart","finally","localMediaTrack","detectSilence","trackChangeInProgress","checkSilence","play","isSilent","pause","shouldReacquireTrack","muted","isInadvertentlyStopped","maybeRestart","race","shouldReacquire","_dummyEl","removeMediaStreamTrackListeners","addMediaStreamTrackListeners","resolveDeferred","ex","message","onMute","startDeferred","removeEventListener","onVisibilityChange","isVisible","offVisibilityChange","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/media/track/localmediatrack.js"],"sourcesContent":["/* eslint new-cap:0 */\n'use strict';\n\nconst { getUserMedia } = require('../../webrtc');\nconst { guessBrowser, isIOSChrome } = require('../../webrtc/util');\n\nconst { capitalize, defer, isUserMediaTrack, waitForSometime, waitForEvent } = require('../../util');\nconst { typeErrors: { ILLEGAL_INVOKE } } = require('../../util/constants');\nconst detectSilentAudio = require('../../util/detectsilentaudio');\nconst detectSilentVideo = require('../../util/detectsilentvideo');\nconst documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nconst localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nconst gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nconst MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#stopped\n   */\n  return class LocalMediaTrack extends AudioOrVideoTrack {\n    /**\n     * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n    constructor(mediaStreamTrack, options) {\n      // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers\n      // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs\n      // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.\n      const workaroundWebKitBug1208516 = (guessBrowser() === 'safari' || isIOSChrome())\n        && isUserMediaTrack(mediaStreamTrack)\n        && typeof document === 'object'\n        && typeof document.addEventListener === 'function'\n        && typeof document.visibilityState === 'string';\n\n      options = Object.assign({\n        getUserMedia,\n        isCreatedByCreateLocalTracks: false,\n        workaroundWebKitBug1208516,\n        gUMSilentTrackWorkaround\n      }, options);\n\n      const mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n      const { kind } = mediaTrackSender;\n\n      super(mediaTrackSender, options);\n\n      Object.defineProperties(this, {\n        _constraints: {\n          value: typeof options[kind] === 'object'\n            ? options[kind]\n            : {},\n          writable: true\n        },\n        _getUserMedia: {\n          value: options.getUserMedia\n        },\n        _gUMSilentTrackWorkaround: {\n          value: options.gUMSilentTrackWorkaround\n        },\n        _workaroundWebKitBug1208516: {\n          value: options.workaroundWebKitBug1208516\n        },\n        _workaroundWebKitBug1208516Cleanup: {\n          value: null,\n          writable: true\n        },\n        _didCallEnd: {\n          value: false,\n          writable: true\n        },\n        _isCreatedByCreateLocalTracks: {\n          value: options.isCreatedByCreateLocalTracks\n        },\n        _trackSender: {\n          value: mediaTrackSender\n        },\n        id: {\n          enumerable: true,\n          value: mediaTrackSender.id\n        },\n        isEnabled: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.enabled;\n          }\n        },\n        isStopped: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.readyState === 'ended';\n          }\n        }\n      });\n\n      // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n      // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n      if (this._workaroundWebKitBug1208516) {\n        this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n      }\n    }\n\n    /**\n     * @private\n     */\n    _end() {\n      if (this._didCallEnd) {\n        return;\n      }\n      super._end.call(this);\n      this._didCallEnd = true;\n      this.emit('stopped', this);\n    }\n\n    /**\n     * @private\n     */\n    _initialize() {\n      if (this._didCallEnd) {\n        this._didCallEnd = false;\n      }\n      super._initialize.call(this);\n    }\n\n    /**\n     * @private\n     */\n    _reacquireTrack(constraints) {\n      const {\n        _getUserMedia: getUserMedia,\n        _gUMSilentTrackWorkaround: gUMSilentTrackWorkaround,\n        _log: log,\n        mediaStreamTrack: { kind }\n      } = this;\n\n      log.info('Re-acquiring the MediaStreamTrack');\n      log.debug('Constraints:', constraints);\n\n      const gUMConstraints = Object.assign({\n        audio: false,\n        video: false\n      }, { [kind]: constraints });\n\n      const gUMPromise = this._workaroundWebKitBug1208516Cleanup\n        ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)\n        : getUserMedia(gUMConstraints);\n\n      return gUMPromise.then(mediaStream => {\n        return mediaStream.getTracks()[0];\n      });\n    }\n\n    /**\n     * @private\n     */\n    _restart(constraints) {\n      const { _log: log } = this;\n      constraints = constraints || this._constraints;\n\n      // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised in case of\n      // video, or the restarted audio will still be silent. Hence, we stop the\n      // MediaStreamTrack here.\n      this._stop();\n\n      return this._reacquireTrack(constraints).catch(error => {\n        log.error('Failed to re-acquire the MediaStreamTrack:', { error, constraints });\n        throw error;\n      }).then(newMediaStreamTrack => {\n        log.info('Re-acquired the MediaStreamTrack');\n        log.debug('MediaStreamTrack:', newMediaStreamTrack);\n        this._constraints = Object.assign({}, constraints);\n        return this._setMediaStreamTrack(newMediaStreamTrack);\n      });\n    }\n\n    /**\n     * @private\n     */\n    _setMediaStreamTrack(mediaStreamTrack) {\n      // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n      mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n\n      // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n      // stopped, this should fire a \"stopped\" event.\n      this._stop();\n\n      // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n      // the processedTrack already set, we don't want to replace that.\n      return (this._unprocessedTrack ? Promise.resolve().then(() => {\n        this._unprocessedTrack = mediaStreamTrack;\n      }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(error => {\n        this._log.warn('setMediaStreamTrack failed:', { error, mediaStreamTrack });\n      })).then(() => {\n        this._initialize();\n        this._getAllAttachedElements().forEach(el => this._attach(el));\n      });\n    }\n\n    /**\n     * @private\n     */\n    _stop() {\n      this.mediaStreamTrack.stop();\n      this._end();\n      return this;\n    }\n\n    enable(enabled) {\n      enabled = typeof enabled === 'boolean' ? enabled : true;\n      if (enabled !== this.mediaStreamTrack.enabled) {\n        this._log.info(`${enabled ? 'En' : 'Dis'}abling`);\n        this.mediaStreamTrack.enabled = enabled;\n        this.emit(enabled ? 'enabled' : 'disabled', this);\n      }\n      return this;\n    }\n\n    disable() {\n      return this.enable(false);\n    }\n\n    restart(constraints) {\n      const { kind } = this;\n      if (!this._isCreatedByCreateLocalTracks) {\n        return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'\n          + ` Local${capitalize(kind)}Track that is created using createLocalTracks`\n          + ` or createLocal${capitalize(kind)}Track.`));\n      }\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      let promise = this._restart(constraints);\n\n      if (this._workaroundWebKitBug1208516) {\n        promise = promise.finally(() => {\n          this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n        });\n      }\n      return promise;\n    }\n\n    stop() {\n      this._log.info('Stopping');\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      return this._stop();\n    }\n  };\n}\n\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  const { _log: log, kind } = localMediaTrack;\n  const detectSilence = { audio: detectSilentAudio, video: detectSilentVideo }[kind];\n\n  let { _dummyEl: el, mediaStreamTrack } = localMediaTrack;\n  let trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(() => detectSilence(el)).then(isSilent => {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n      return isSilent;\n    }).catch(error => {\n      log.warn('Failed to detect silence:', error);\n    }).finally(() => {\n      // Pause the dummy element again.\n      el.pause();\n    });\n  }\n\n  function shouldReacquireTrack() {\n    const {\n      _workaroundWebKitBug1208516Cleanup,\n      isStopped,\n      mediaStreamTrack: { muted }\n    } = localMediaTrack;\n\n    const isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n\n    // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n    return Promise.resolve().then(() => {\n      return document.visibilityState === 'visible'\n        && !trackChangeInProgress\n        && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([\n      waitForEvent(mediaStreamTrack, 'unmute'),\n      waitForSometime(50)\n    ]).then(() => shouldReacquireTrack()).then(shouldReacquire => {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n        localMediaTrack._restart().finally(() => {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(error => {\n          log.error('failed to restart track: ', error);\n        });\n      }\n\n      // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n      const promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();\n      return promise.finally(() => localMediaRestartDeferreds.resolveDeferred(kind));\n    }).catch(ex => {\n      log.error(`error in maybeRestart: ${ex.message}`);\n    });\n  }\n\n  function onMute() {\n    const { _log: log, kind } = localMediaTrack;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack);\n\n    // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  }\n\n  // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n  let onVisibilityChange = isVisible => {\n    return isVisible ? maybeRestart() : false;\n  };\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n\n  return () => {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;\n"]},"metadata":{},"sourceType":"script"}