{"ast":null,"code":"'use strict';\n\nvar Filter = require('../../util/filter');\n/**\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\n * {@link IceBox} via {@link IceBox#update} are compared against previously\n * trickled candidates and only new candidates will be returned (assuming they\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\n * @property {?string} ufrag\n */\n\n\nvar IceBox =\n/** @class */\nfunction () {\n  /**\n   * Construct an {@link IceBox}.\n   */\n  function IceBox() {\n    Object.defineProperties(this, {\n      _filter: {\n        value: new Filter({\n          getKey: function getKey(iceState) {\n            return iceState.ufrag;\n          },\n          isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\n            return a.revision <= b.revision;\n          }\n        })\n      },\n      _ufrag: {\n        writable: true,\n        value: null\n      },\n      ufrag: {\n        enumerable: true,\n        get: function () {\n          return this._ufrag;\n        }\n      }\n    });\n  }\n  /**\n   * Set the ICE username fragment on the {@link IceBox}. This method returns any\n   * ICE candidates associated with the username fragment.\n   * @param {string} ufrag\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n\n\n  IceBox.prototype.setUfrag = function (ufrag) {\n    this._ufrag = ufrag;\n\n    var ice = this._filter.toMap().get(ufrag);\n\n    return ice ? ice.candidates : [];\n  };\n  /**\n   * Update the {@link IceBox}. This method returns any new ICE candidates\n   * associated with the current username fragment.\n   * @param {object} iceState\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n\n\n  IceBox.prototype.update = function (iceState) {\n    // NOTE(mroberts): The Server sometimes does not set the candidates property.\n    iceState.candidates = iceState.candidates || [];\n\n    var oldIceState = this._filter.toMap().get(iceState.ufrag);\n\n    var oldCandidates = oldIceState ? oldIceState.candidates : [];\n    return this._filter.update(iceState) && this._ufrag === iceState.ufrag ? iceState.candidates.slice(oldCandidates.length) : [];\n  };\n\n  return IceBox;\n}();\n\nmodule.exports = IceBox;","map":{"version":3,"mappings":"AAAA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,mBAAD,CAAtB;AAEA;;;;;;;;;AAOA;AAAA;AAAA;EACE;;;EAGA;IACEC,MAAM,CAACC,gBAAP,CAAwB,IAAxB,EAA8B;MAC5BC,OAAO,EAAE;QACPC,KAAK,EAAE,IAAIL,MAAJ,CAAW;UAChBM,MAAM,EAAE,SAASA,MAAT,CAAgBC,QAAhB,EAAwB;YAC9B,OAAOA,QAAQ,CAACC,KAAhB;UACD,CAHe;UAIhBC,mBAAmB,EAAE,SAASA,mBAAT,CAA6BC,CAA7B,EAAgCC,CAAhC,EAAiC;YACpD,OAAOD,CAAC,CAACE,QAAF,IAAcD,CAAC,CAACC,QAAvB;UACD;QANe,CAAX;MADA,CADmB;MAW5BC,MAAM,EAAE;QACNC,QAAQ,EAAE,IADJ;QAENT,KAAK,EAAE;MAFD,CAXoB;MAe5BG,KAAK,EAAE;QACLO,UAAU,EAAE,IADP;QAELC,GAAG;UACD,OAAO,KAAKH,MAAZ;QACD;MAJI;IAfqB,CAA9B;EAsBD;EAED;;;;;;;;EAMAI,sCAAST,KAAT,EAAc;IACZ,KAAKK,MAAL,GAAcL,KAAd;;IACA,IAAMU,GAAG,GAAG,KAAKd,OAAL,CAAae,KAAb,GAAqBH,GAArB,CAAyBR,KAAzB,CAAZ;;IACA,OAAOU,GAAG,GAAGA,GAAG,CAACE,UAAP,GAAoB,EAA9B;EACD,CAJD;EAMA;;;;;;;;EAMAH,oCAAOV,QAAP,EAAe;IACb;IACAA,QAAQ,CAACa,UAAT,GAAsBb,QAAQ,CAACa,UAAT,IAAuB,EAA7C;;IACA,IAAMC,WAAW,GAAG,KAAKjB,OAAL,CAAae,KAAb,GAAqBH,GAArB,CAAyBT,QAAQ,CAACC,KAAlC,CAApB;;IACA,IAAMc,aAAa,GAAGD,WAAW,GAAGA,WAAW,CAACD,UAAf,GAA4B,EAA7D;IACA,OAAO,KAAKhB,OAAL,CAAamB,MAAb,CAAoBhB,QAApB,KAAiC,KAAKM,MAAL,KAAgBN,QAAQ,CAACC,KAA1D,GACHD,QAAQ,CAACa,UAAT,CAAoBI,KAApB,CAA0BF,aAAa,CAACG,MAAxC,CADG,GAEH,EAFJ;EAGD,CARD;;EASF;AAAC,CAxDD;;AA0DAC,MAAM,CAACC,OAAP,GAAiBV,MAAjB","names":["Filter","require","Object","defineProperties","_filter","value","getKey","iceState","ufrag","isLessThanOrEqualTo","a","b","revision","_ufrag","writable","enumerable","get","IceBox","ice","toMap","candidates","oldIceState","oldCandidates","update","slice","length","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/signaling/v2/icebox.js"],"sourcesContent":["'use strict';\n\nconst Filter = require('../../util/filter');\n\n/**\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\n * {@link IceBox} via {@link IceBox#update} are compared against previously\n * trickled candidates and only new candidates will be returned (assuming they\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\n * @property {?string} ufrag\n */\nclass IceBox {\n  /**\n   * Construct an {@link IceBox}.\n   */\n  constructor() {\n    Object.defineProperties(this, {\n      _filter: {\n        value: new Filter({\n          getKey: function getKey(iceState) {\n            return iceState.ufrag;\n          },\n          isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\n            return a.revision <= b.revision;\n          }\n        })\n      },\n      _ufrag: {\n        writable: true,\n        value: null\n      },\n      ufrag: {\n        enumerable: true,\n        get() {\n          return this._ufrag;\n        }\n      }\n    });\n  }\n\n  /**\n   * Set the ICE username fragment on the {@link IceBox}. This method returns any\n   * ICE candidates associated with the username fragment.\n   * @param {string} ufrag\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n  setUfrag(ufrag) {\n    this._ufrag = ufrag;\n    const ice = this._filter.toMap().get(ufrag);\n    return ice ? ice.candidates : [];\n  }\n\n  /**\n   * Update the {@link IceBox}. This method returns any new ICE candidates\n   * associated with the current username fragment.\n   * @param {object} iceState\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n  update(iceState) {\n    // NOTE(mroberts): The Server sometimes does not set the candidates property.\n    iceState.candidates = iceState.candidates || [];\n    const oldIceState = this._filter.toMap().get(iceState.ufrag);\n    const oldCandidates = oldIceState ? oldIceState.candidates : [];\n    return this._filter.update(iceState) && this._ufrag === iceState.ufrag\n      ? iceState.candidates.slice(oldCandidates.length)\n      : [];\n  }\n}\n\nmodule.exports = IceBox;\n"]},"metadata":{},"sourceType":"script"}