{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('./util');\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\n\n\nvar StateMachine =\n/** @class */\nfunction (_super) {\n  __extends(StateMachine, _super);\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n\n\n  function StateMachine(initialState, states) {\n    var _this = _super.call(this) || this;\n\n    var lock = null;\n    var state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(_this, {\n      _lock: {\n        get: function () {\n          return lock;\n        },\n        set: function (_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get: function () {\n          return state;\n        },\n        set: function (_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get: function () {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function () {\n          return state;\n        }\n      }\n    });\n\n    _this.on('stateChanged', function (state) {\n      _this._whenDeferreds.forEach(function (deferred) {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n\n    return _this;\n  }\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n\n\n  StateMachine.prototype._whenPromise = function (when) {\n    var _this = this;\n\n    if (typeof when !== 'function') {\n      return Promise.reject(new Error('when() executor must be a function'));\n    }\n\n    var deferred = util.defer();\n    deferred.when = when;\n\n    this._whenDeferreds.add(deferred);\n\n    return deferred.promise.then(function (payload) {\n      _this._whenDeferreds.delete(deferred);\n\n      return payload;\n    }, function (error) {\n      _this._whenDeferreds.delete(deferred);\n\n      throw error;\n    });\n  };\n  /**\n   * This method takes a lock and passes the {@link StateMachine#Key} to your\n   * transition function. You may perform zero or more state transitions in your\n   * transition function, but you should check for preemption in each tick. You\n   * may also reenter the lock. Once the Promise returned by your transition\n   * function resolves or rejects, this method releases the lock it acquired for\n   * you.\n   * @param {string} name - a name for the lock\n   * @param {function(StateMachine#Key): Promise} transitionFunction\n   * @returns {Promise}\n   */\n  // NOTE(mroberts): This method is named after a Haskell function:\n  // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n\n\n  StateMachine.prototype.bracket = function (name, transitionFunction) {\n    var key;\n    var self = this;\n\n    function releaseLock(error) {\n      if (self.hasLock(key)) {\n        self.releaseLockCompletely(key);\n      }\n\n      if (error) {\n        throw error;\n      }\n    }\n\n    return this.takeLock(name).then(function gotKey(_key) {\n      key = _key;\n      return transitionFunction(key);\n    }).then(function success(result) {\n      releaseLock();\n      return result;\n    }, releaseLock);\n  };\n  /**\n   * Check whether or not a {@link StateMachine#Key} matches the lock.\n   * @param {StateMachine#Key} key\n   * @returns {boolean}\n   */\n\n\n  StateMachine.prototype.hasLock = function (key) {\n    return this._lock === key;\n  };\n  /**\n   * Preempt any pending state transitions and immediately transition to the new\n   * state. If a lock name is specified, take the lock and return the\n   * {@link StateMachine#Key}.\n   * @param {string} newState\n   * @param {?string} [name=null] - a name for the lock\n   * @param {Array<*>} [payload=[]]\n   * @returns {?StateMachine#Key}\n   */\n\n\n  StateMachine.prototype.preempt = function (newState, name, payload) {\n    // 1. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    } // 2. Release the old lock, if any.\n\n\n    var oldLock;\n\n    if (this.isLocked) {\n      oldLock = this._lock;\n      this._lock = null;\n    } // 3. Take the lock, if requested.\n\n\n    var key = null;\n\n    if (name) {\n      key = this.takeLockSync(name);\n    } // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n    // maintain FIFO order of those taking locks.\n\n\n    var preemptionKey = key ? null : this.takeLockSync('preemption'); // 5. Transition.\n\n    this.transition(newState, key || preemptionKey, payload); // 6. Preempt anyone blocked on the old lock.\n\n    if (oldLock) {\n      oldLock.resolve();\n    } // 7. Release the \"preemption\" lock, if we took it.\n\n\n    if (preemptionKey) {\n      this.releaseLock(preemptionKey);\n    }\n\n    return key;\n  };\n  /**\n   * Release a lock. This method succeeds only if the {@link StateMachine} is\n   * still locked and has not been preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n\n\n  StateMachine.prototype.releaseLock = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n\n    if (key.depth === 0) {\n      this._lock = null;\n      key.resolve();\n    } else {\n      key.depth--;\n    }\n  };\n  /**\n   * Release a lock completely, even if it has been reentered. This method\n   * succeeds only if the {@link StateMachine} is still locked and has not been\n   * preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n\n\n  StateMachine.prototype.releaseLockCompletely = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n\n    key.depth = 0;\n    this._lock = null;\n    key.resolve();\n  };\n  /**\n   * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n   * take a lock anytime you intend to perform asynchronous transitions. Calls to\n   * this method are guaranteed to be resolved in FIFO order. You may reenter\n   * a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {Promise<object>}\n   */\n\n\n  StateMachine.prototype.takeLock = function (nameOrKey) {\n    var _this = this; // Reentrant lock\n\n\n    if (typeof nameOrKey === 'object') {\n      var key_1 = nameOrKey;\n      return new Promise(function (resolve) {\n        resolve(_this.takeLockSync(key_1));\n      });\n    } // New lock\n\n\n    var name = nameOrKey;\n\n    if (this.isLocked) {\n      var takeLock = this.takeLock.bind(this, name);\n      return this._lock.promise.then(takeLock);\n    }\n\n    return Promise.resolve(this.takeLockSync(name));\n  };\n  /**\n   * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n   * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n   * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {object}\n   * @throws Error\n   */\n\n\n  StateMachine.prototype.takeLockSync = function (nameOrKey) {\n    var key = typeof nameOrKey === 'string' ? null : nameOrKey;\n    var name = key ? key.name : nameOrKey;\n\n    if (key && !this.hasLock(key) || !key && this.isLocked) {\n      throw new Error(\"Could not take the lock for \" + name + \" because the lock for \" + this._lock.name + \" was not released\");\n    } // Reentrant lock\n\n\n    if (key) {\n      key.depth++;\n      return key;\n    } // New lock\n\n\n    var lock = makeLock(name);\n    this._lock = lock;\n    return lock;\n  };\n  /**\n   * Transition to a new state. If the {@link StateMachine} is locked, you must\n   * provide the {@link StateMachine#Key}. An invalid state or the wrong\n   * {@link StateMachine#Key} will throw an error.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @throws {Error}\n   */\n\n\n  StateMachine.prototype.transition = function (newState, key, payload) {\n    payload = payload || []; // 1. If we're locked, required the key.\n\n    if (this.isLocked) {\n      if (!key) {\n        throw new Error('You must provide the key in order to ' + 'transition');\n      } else if (!this.hasLock(key)) {\n        throw new Error(\"Could not transition using the key for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n      }\n    } else if (key) {\n      throw new Error(\"Key provided for \" + key.name + \", but the StateMachine was not locked (possibly due to preemption)\");\n    } // 2. Check that the new state is valid.\n\n\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    } // 3. Update the state and emit an event.\n\n\n    this._state = newState;\n    this.emit.apply(this, __spreadArray([], __read(['stateChanged', newState].concat(payload))));\n  };\n  /**\n   * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n   * this method does not throw.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @returns {boolean}\n   */\n\n\n  StateMachine.prototype.tryTransition = function (newState, key, payload) {\n    try {\n      this.transition(newState, key, payload);\n    } catch (error) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Return a Promise that resolves when the {@link StateMachine} transitions to\n   * the specified state. If the {@link StateMachine} transitions such that the\n   * requested state becomes unreachable, the Promise rejects.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n\n\n  StateMachine.prototype.when = function (state) {\n    var _this = this;\n\n    if (this.state === state) {\n      return Promise.resolve(this);\n    } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n      return Promise.reject(createUnreachableError(this.state, state));\n    }\n\n    return this._whenPromise(function (newState, resolve, reject) {\n      if (newState === state) {\n        resolve(_this);\n      } else if (!isValidTransition(_this._reachableStates, newState, state)) {\n        reject(createUnreachableError(newState, state));\n      }\n    });\n  };\n\n  return StateMachine;\n}(EventEmitter);\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\n\n\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n/**\n * @typedef {object} StateMachine#Key\n */\n\n\nfunction makeLock(name) {\n  var lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\n\n\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce(function (newGraph, from) {\n    return newGraph.set(from, reachableFrom(graph, from));\n  }, new Map());\n}\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\n\n\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(function (node) {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\n\nfunction transformStates(states) {\n  var newStates = new Map();\n\n  for (var key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n\n  return newStates;\n}\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\n\n\nfunction createUnreachableError(here, there) {\n  return new Error(\"\\\"\" + there + \"\\\" cannot be reached from \\\"\" + here + \"\\\"\");\n}\n\nmodule.exports = StateMachine;","map":{"version":3,"mappings":"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","names":["EventEmitter","require","util","__extends","initialState","states","_super","lock","state","transformStates","Object","defineProperties","_this","_lock","get","set","_reachableStates","value","reachable","_state","_states","_whenDeferreds","Set","isLocked","enumerable","on","forEach","deferred","when","resolve","reject","StateMachine","Promise","Error","defer","add","promise","then","delete","payload","error","name","transitionFunction","key","self","releaseLock","hasLock","releaseLockCompletely","takeLock","gotKey","_key","success","result","newState","isValidTransition","oldLock","takeLockSync","preemptionKey","transition","depth","nameOrKey","key_1","bind","makeLock","emit","apply","__spreadArray","concat","createUnreachableError","_whenPromise","graph","from","to","has","Array","keys","reduce","newGraph","reachableFrom","Map","node","newStates","here","there","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/statemachine.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst util = require('./util');\n\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\nclass StateMachine extends EventEmitter {\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n  constructor(initialState, states) {\n    super();\n    let lock = null;\n    let state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(this, {\n      _lock: {\n        get() {\n          return lock;\n        },\n        set(_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get() {\n          return state;\n        },\n        set(_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get() {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get() {\n          return state;\n        }\n      }\n    });\n\n    this.on('stateChanged', state => {\n      this._whenDeferreds.forEach(deferred => {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n  }\n\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n  _whenPromise(when) {\n    if (typeof when !== 'function') {\n      return Promise.reject(new Error('when() executor must be a function'));\n    }\n\n    const deferred = util.defer();\n\n    deferred.when = when;\n    this._whenDeferreds.add(deferred);\n\n    return deferred.promise.then(payload => {\n      this._whenDeferreds.delete(deferred);\n      return payload;\n    }, error => {\n      this._whenDeferreds.delete(deferred);\n      throw error;\n    });\n  }\n\n  /**\n   * This method takes a lock and passes the {@link StateMachine#Key} to your\n   * transition function. You may perform zero or more state transitions in your\n   * transition function, but you should check for preemption in each tick. You\n   * may also reenter the lock. Once the Promise returned by your transition\n   * function resolves or rejects, this method releases the lock it acquired for\n   * you.\n   * @param {string} name - a name for the lock\n   * @param {function(StateMachine#Key): Promise} transitionFunction\n   * @returns {Promise}\n   */\n  // NOTE(mroberts): This method is named after a Haskell function:\n  // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n  bracket(name, transitionFunction) {\n    let key;\n    const self = this;\n\n    function releaseLock(error) {\n      if (self.hasLock(key)) {\n        self.releaseLockCompletely(key);\n      }\n      if (error) {\n        throw error;\n      }\n    }\n\n    return this.takeLock(name).then(function gotKey(_key) {\n      key = _key;\n      return transitionFunction(key);\n    }).then(function success(result) {\n      releaseLock();\n      return result;\n    }, releaseLock);\n  }\n\n  /**\n   * Check whether or not a {@link StateMachine#Key} matches the lock.\n   * @param {StateMachine#Key} key\n   * @returns {boolean}\n   */\n  hasLock(key) {\n    return this._lock === key;\n  }\n\n  /**\n   * Preempt any pending state transitions and immediately transition to the new\n   * state. If a lock name is specified, take the lock and return the\n   * {@link StateMachine#Key}.\n   * @param {string} newState\n   * @param {?string} [name=null] - a name for the lock\n   * @param {Array<*>} [payload=[]]\n   * @returns {?StateMachine#Key}\n   */\n  preempt(newState, name, payload) {\n    // 1. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(`Cannot transition from \"${this.state}\" to \"${newState}\"`);\n    }\n\n    // 2. Release the old lock, if any.\n    let oldLock;\n    if (this.isLocked) {\n      oldLock = this._lock;\n      this._lock = null;\n    }\n\n    // 3. Take the lock, if requested.\n    let key = null;\n    if (name) {\n      key = this.takeLockSync(name);\n    }\n\n    // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n    // maintain FIFO order of those taking locks.\n    const preemptionKey = key ? null : this.takeLockSync('preemption');\n\n    // 5. Transition.\n    this.transition(newState, key || preemptionKey, payload);\n\n    // 6. Preempt anyone blocked on the old lock.\n    if (oldLock) {\n      oldLock.resolve();\n    }\n\n    // 7. Release the \"preemption\" lock, if we took it.\n    if (preemptionKey) {\n      this.releaseLock(preemptionKey);\n    }\n\n    return key;\n  }\n\n  /**\n   * Release a lock. This method succeeds only if the {@link StateMachine} is\n   * still locked and has not been preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  releaseLock(key) {\n    if (!this.isLocked) {\n      throw new Error(`Could not release the lock for ${key.name} because the StateMachine is not locked`);\n    } else if (!this.hasLock(key)) {\n      throw new Error(`Could not release the lock for ${key.name} because ${this._lock.name} has the lock`);\n    }\n    if (key.depth === 0) {\n      this._lock = null;\n      key.resolve();\n    } else {\n      key.depth--;\n    }\n  }\n\n  /**\n   * Release a lock completely, even if it has been reentered. This method\n   * succeeds only if the {@link StateMachine} is still locked and has not been\n   * preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  releaseLockCompletely(key) {\n    if (!this.isLocked) {\n      throw new Error(`Could not release the lock for ${key.name} because the StateMachine is not locked`);\n    } else if (!this.hasLock(key)) {\n      throw new Error(`Could not release the lock for ${key.name} because ${this._lock.name} has the lock`);\n    }\n    key.depth = 0;\n    this._lock = null;\n    key.resolve();\n  }\n\n  /**\n   * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n   * take a lock anytime you intend to perform asynchronous transitions. Calls to\n   * this method are guaranteed to be resolved in FIFO order. You may reenter\n   * a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {Promise<object>}\n   */\n  takeLock(nameOrKey) {\n    // Reentrant lock\n    if (typeof nameOrKey === 'object') {\n      const key = nameOrKey;\n      return new Promise(resolve => {\n        resolve(this.takeLockSync(key));\n      });\n    }\n\n    // New lock\n    const name = nameOrKey;\n    if (this.isLocked) {\n      var takeLock = this.takeLock.bind(this, name);\n      return this._lock.promise.then(takeLock);\n    }\n    return Promise.resolve(this.takeLockSync(name));\n  }\n\n  /**\n   * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n   * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n   * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {object}\n   * @throws Error\n   */\n  takeLockSync(nameOrKey) {\n    const key = typeof nameOrKey === 'string' ? null : nameOrKey;\n    const name = key ? key.name : nameOrKey;\n\n    if (key && !this.hasLock(key) || !key && this.isLocked) {\n      throw new Error(`Could not take the lock for ${name} because the lock for ${this._lock.name} was not released`);\n    }\n\n    // Reentrant lock\n    if (key) {\n      key.depth++;\n      return key;\n    }\n\n    // New lock\n    const lock = makeLock(name);\n    this._lock = lock;\n    return lock;\n  }\n\n  /**\n   * Transition to a new state. If the {@link StateMachine} is locked, you must\n   * provide the {@link StateMachine#Key}. An invalid state or the wrong\n   * {@link StateMachine#Key} will throw an error.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @throws {Error}\n   */\n  transition(newState, key, payload) {\n    payload = payload || [];\n\n    // 1. If we're locked, required the key.\n    if (this.isLocked) {\n      if (!key) {\n        throw new Error('You must provide the key in order to ' +\n          'transition');\n      } else if (!this.hasLock(key)) {\n        throw new Error(`Could not transition using the key for ${key.name} because ${this._lock.name} has the lock`);\n      }\n    } else if (key) {\n      throw new Error(`Key provided for ${key.name}, but the StateMachine was not locked (possibly due to preemption)`);\n    }\n\n    // 2. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(`Cannot transition from \"${this.state}\" to \"${newState}\"`);\n    }\n\n    // 3. Update the state and emit an event.\n    this._state = newState;\n    this.emit(...['stateChanged', newState].concat(payload));\n  }\n\n  /**\n   * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n   * this method does not throw.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @returns {boolean}\n   */\n  tryTransition(newState, key, payload) {\n    try {\n      this.transition(newState, key, payload);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Return a Promise that resolves when the {@link StateMachine} transitions to\n   * the specified state. If the {@link StateMachine} transitions such that the\n   * requested state becomes unreachable, the Promise rejects.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n  when(state) {\n    if (this.state === state) {\n      return Promise.resolve(this);\n    } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n      return Promise.reject(createUnreachableError(this.state, state));\n    }\n    return this._whenPromise((newState, resolve, reject) => {\n      if (newState === state) {\n        resolve(this);\n      } else if (!isValidTransition(this._reachableStates, newState, state)) {\n        reject(createUnreachableError(newState, state));\n      }\n    });\n  }\n}\n\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n\n/**\n * @typedef {object} StateMachine#Key\n */\n\nfunction makeLock(name) {\n  const lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce((newGraph, from) => newGraph.set(from, reachableFrom(graph, from)), new Map());\n}\n\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(node => {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\n\nfunction transformStates(states) {\n  const newStates = new Map();\n  for (const key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n  return newStates;\n}\n\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\nfunction createUnreachableError(here, there) {\n  return new Error(`\"${there}\" cannot be reached from \"${here}\"`);\n}\n\nmodule.exports = StateMachine;\n"]},"metadata":{},"sourceType":"script"}