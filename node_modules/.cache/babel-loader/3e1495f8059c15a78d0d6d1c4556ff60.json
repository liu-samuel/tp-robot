{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar DefaultBackoff = require('../../util/backoff');\n\nvar _a = require('../../webrtc'),\n    DefaultRTCIceCandidate = _a.RTCIceCandidate,\n    DefaultRTCPeerConnection = _a.RTCPeerConnection,\n    DefaultRTCSessionDescription = _a.RTCSessionDescription,\n    getStatistics = _a.getStats;\n\nvar util = require('../../webrtc/util');\n\nvar _b = require('../../util/constants'),\n    DEFAULT_ICE_GATHERING_TIMEOUT_MS = _b.DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n    DEFAULT_LOG_LEVEL = _b.DEFAULT_LOG_LEVEL,\n    DEFAULT_SESSION_TIMEOUT_SEC = _b.DEFAULT_SESSION_TIMEOUT_SEC,\n    iceRestartBackoffConfig = _b.iceRestartBackoffConfig;\n\nvar _c = require('../../util/sdp'),\n    addOrRewriteNewTrackIds = _c.addOrRewriteNewTrackIds,\n    addOrRewriteTrackIds = _c.addOrRewriteTrackIds,\n    createCodecMapForMediaSection = _c.createCodecMapForMediaSection,\n    disableRtx = _c.disableRtx,\n    enableDtxForOpus = _c.enableDtxForOpus,\n    filterLocalCodecs = _c.filterLocalCodecs,\n    getMediaSections = _c.getMediaSections,\n    removeSSRCAttributes = _c.removeSSRCAttributes,\n    revertSimulcast = _c.revertSimulcast,\n    setCodecPreferences = _c.setCodecPreferences,\n    setSimulcast = _c.setSimulcast;\n\nvar DefaultTimeout = require('../../util/timeout');\n\nvar _d = require('../../util/twilio-video-errors'),\n    MediaClientLocalDescFailedError = _d.MediaClientLocalDescFailedError,\n    MediaClientRemoteDescFailedError = _d.MediaClientRemoteDescFailedError;\n\nvar _e = require('../../util'),\n    buildLogLevels = _e.buildLogLevels,\n    getPlatform = _e.getPlatform,\n    isChromeScreenShareTrack = _e.isChromeScreenShareTrack,\n    oncePerTick = _e.oncePerTick,\n    defer = _e.defer;\n\nvar IceBox = require('./icebox');\n\nvar DefaultIceConnectionMonitor = require('./iceconnectionmonitor.js');\n\nvar DataTrackReceiver = require('../../data/receiver');\n\nvar MediaTrackReceiver = require('../../media/track/receiver');\n\nvar StateMachine = require('../../statemachine');\n\nvar Log = require('../../util/log');\n\nvar TrackMatcher = require('../../util/sdp/trackmatcher');\n\nvar workaroundIssue8329 = require('../../util/sdp/issue8329');\n\nvar guess = util.guessBrowser();\nvar platform = getPlatform();\nvar isAndroid = /android/.test(platform);\nvar isChrome = guess === 'chrome';\nvar isFirefox = guess === 'firefox';\nvar isSafari = guess === 'safari';\nvar nInstances = 0;\n/*\nPeerConnectionV2 States\n-----------------------\n\n    +------+    +--------+\n    |      |    |        |\n    | open |--->| closed |\n    |      |    |        |\n    +------+    +--------+\n      |  ^          ^\n      |  |          |\n      |  |          |\n      v  |          |\n  +----------+      |\n  |          |      |\n  | updating |------+\n  |          |\n  +----------+\n\n*/\n\nvar states = {\n  open: ['closed', 'updating'],\n  updating: ['closed', 'open'],\n  closed: []\n};\n/**\n * @extends StateMachine\n * @property {id}\n * @emits PeerConnectionV2#connectionStateChanged\n * @emits PeerConnectionV2#iceConnectionStateChanged\n * @emits PeerConnectionV2#candidates\n * @emits PeerConnectionV2#description\n */\n\nvar PeerConnectionV2 =\n/** @class */\nfunction (_super) {\n  __extends(PeerConnectionV2, _super);\n  /**\n   * Construct a {@link PeerConnectionV2}.\n   * @param {string} id\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} [options]\n   */\n\n\n  function PeerConnectionV2(id, encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this, 'open', states) || this;\n\n    options = Object.assign({\n      enableDscp: false,\n      dummyAudioMediaStreamTrack: null,\n      isChromeScreenShareTrack: isChromeScreenShareTrack,\n      iceServers: [],\n      logLevel: DEFAULT_LOG_LEVEL,\n      offerOptions: {},\n      revertSimulcast: revertSimulcast,\n      sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,\n      setCodecPreferences: setCodecPreferences,\n      setSimulcast: setSimulcast,\n      Backoff: DefaultBackoff,\n      IceConnectionMonitor: DefaultIceConnectionMonitor,\n      RTCIceCandidate: DefaultRTCIceCandidate,\n      RTCPeerConnection: DefaultRTCPeerConnection,\n      RTCSessionDescription: DefaultRTCSessionDescription,\n      Timeout: DefaultTimeout\n    }, options);\n    var configuration = getConfiguration(options);\n    var logLevels = buildLogLevels(options.logLevel);\n    var RTCPeerConnection = options.RTCPeerConnection;\n\n    if (options.enableDscp === true) {\n      options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};\n      options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];\n      options.chromeSpecificConstraints.optional.push({\n        googDscp: true\n      });\n    }\n\n    var log = options.log ? options.log.createLog('webrtc', _this) : new Log('webrtc', _this, logLevels, options.loggerName);\n    var peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);\n\n    if (options.dummyAudioMediaStreamTrack) {\n      peerConnection.addTrack(options.dummyAudioMediaStreamTrack);\n    }\n\n    Object.defineProperties(_this, {\n      _appliedTrackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _dataChannels: {\n        value: new Map()\n      },\n      _dataTrackReceivers: {\n        value: new Set()\n      },\n      _descriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _didGenerateLocalCandidates: {\n        writable: true,\n        value: false\n      },\n      _enableDscp: {\n        value: options.enableDscp\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _isChromeScreenShareTrack: {\n        value: options.isChromeScreenShareTrack\n      },\n      _iceGatheringFailed: {\n        value: false,\n        writable: true\n      },\n      _iceGatheringTimeout: {\n        value: new options.Timeout(function () {\n          return _this._handleIceGatheringTimeout();\n        }, DEFAULT_ICE_GATHERING_TIMEOUT_MS, false)\n      },\n      _iceRestartBackoff: {\n        // eslint-disable-next-line new-cap\n        value: new options.Backoff(iceRestartBackoffConfig)\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _isIceConnectionInactive: {\n        writable: true,\n        value: false\n      },\n      _isIceLite: {\n        writable: true,\n        value: false\n      },\n      _isIceRestartBackoffInProgress: {\n        writable: true,\n        value: false\n      },\n      _isRestartingIce: {\n        writable: true,\n        value: false\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: null\n      },\n      _lastStableDescriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _localCandidates: {\n        writable: true,\n        value: []\n      },\n      _localCodecs: {\n        value: new Set()\n      },\n      _localCandidatesRevision: {\n        writable: true,\n        value: 1\n      },\n      _localDescriptionWithoutSimulcast: {\n        writable: true,\n        value: null\n      },\n      _localDescription: {\n        writable: true,\n        value: null\n      },\n      _localUfrag: {\n        writable: true,\n        value: null\n      },\n      _log: {\n        value: log\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _remoteCodecMaps: {\n        value: new Map()\n      },\n      _rtpSenders: {\n        value: new Map()\n      },\n      _rtpNewSenders: {\n        value: new Set()\n      },\n      _iceConnectionMonitor: {\n        value: new options.IceConnectionMonitor(peerConnection)\n      },\n      _mediaTrackReceivers: {\n        value: new Set()\n      },\n      _needsAnswer: {\n        writable: true,\n        value: false\n      },\n      _negotiationRole: {\n        writable: true,\n        value: null\n      },\n      _offerOptions: {\n        writable: true,\n        value: options.offerOptions\n      },\n      _onEncodingParametersChanged: {\n        value: oncePerTick(function () {\n          if (!_this._needsAnswer) {\n            updateEncodingParameters(_this);\n          }\n        })\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _preferredAudioCodecs: {\n        value: preferredCodecs.audio\n      },\n      _preferredVideoCodecs: {\n        value: preferredCodecs.video\n      },\n      _shouldApplyDtx: {\n        value: preferredCodecs.audio.every(function (_a) {\n          var codec = _a.codec;\n          return codec !== 'opus';\n        }) || preferredCodecs.audio.some(function (_a) {\n          var codec = _a.codec,\n              dtx = _a.dtx;\n          return codec === 'opus' && dtx;\n        })\n      },\n      _queuedDescription: {\n        writable: true,\n        value: null\n      },\n      _iceReconnectTimeout: {\n        value: new options.Timeout(function () {\n          log.debug('ICE reconnect timed out');\n\n          _this.close();\n        }, options.sessionTimeout, false)\n      },\n      _recycledTransceivers: {\n        value: {\n          audio: [],\n          video: []\n        }\n      },\n      _replaceTrackPromises: {\n        value: new Map()\n      },\n      _remoteCandidates: {\n        writable: true,\n        value: new IceBox()\n      },\n      _setCodecPreferences: {\n        // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264\n        // preferred codec is selected does not work on Android Firefox due to this behavior:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by\n        // not applying any non-H264 preferred video codec.\n        value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264' ? function (sdp) {\n          return sdp;\n        } : options.setCodecPreferences\n      },\n      _setSimulcast: {\n        value: options.setSimulcast\n      },\n      _revertSimulcast: {\n        value: options.revertSimulcast\n      },\n      _RTCIceCandidate: {\n        value: options.RTCIceCandidate\n      },\n      _RTCPeerConnection: {\n        value: options.RTCPeerConnection\n      },\n      _RTCSessionDescription: {\n        value: options.RTCSessionDescription\n      },\n      _shouldOffer: {\n        writable: true,\n        value: false\n      },\n      _shouldRestartIce: {\n        writable: true,\n        value: false\n      },\n      _trackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _trackMatcher: {\n        writable: true,\n        value: null\n      },\n      _mediaTrackSenderToPublisherHints: {\n        value: new Map()\n      },\n      id: {\n        enumerable: true,\n        value: id\n      }\n    });\n    encodingParameters.on('changed', _this._onEncodingParametersChanged);\n    peerConnection.addEventListener('connectionstatechange', _this._handleConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('datachannel', _this._handleDataChannelEvent.bind(_this));\n    peerConnection.addEventListener('icecandidate', _this._handleIceCandidateEvent.bind(_this));\n    peerConnection.addEventListener('iceconnectionstatechange', _this._handleIceConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('icegatheringstatechange', _this._handleIceGatheringStateChange.bind(_this));\n    peerConnection.addEventListener('signalingstatechange', _this._handleSignalingStateChange.bind(_this));\n    peerConnection.addEventListener('track', _this._handleTrackEvent.bind(_this));\n    var self = _this;\n\n    _this.on('stateChanged', function stateChanged(state) {\n      if (state !== 'closed') {\n        return;\n      }\n\n      self.removeListener('stateChanged', stateChanged);\n\n      self._dataChannels.forEach(function (dataChannel, dataTrackSender) {\n        self.removeDataTrackSender(dataTrackSender);\n      });\n    });\n\n    return _this;\n  }\n\n  PeerConnectionV2.prototype.toString = function () {\n    return \"[PeerConnectionV2 #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n\n  PeerConnectionV2.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast); // clear adaptive simulcast from codec preferences if it was set.\n\n\n    this._preferredVideoCodecs.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n\n  Object.defineProperty(PeerConnectionV2.prototype, \"_shouldApplySimulcast\", {\n    get: function () {\n      if (!isChrome && !isSafari) {\n        return false;\n      } // adaptiveSimulcast is set to false after connected message is received if other party does not support it.\n\n\n      var simulcast = this._preferredVideoCodecs.some(function (cs) {\n        return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;\n      });\n\n      return simulcast;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"connectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState\n     * if supported by the browser, its RTCIceConnectionState otherwise.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function () {\n      return this.iceConnectionState === 'failed' ? 'failed' : this._peerConnection.connectionState || this.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"iceConnectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's\n     * RTCIceConnectionState.\n     * @property {RTCIceConnectionState}\n     */\n    get: function () {\n      return this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected' || this._iceGatheringFailed ? 'failed' : this._peerConnection.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"isApplicationSectionNegotiated\", {\n    /**\n     * Whether the {@link PeerConnectionV2} has negotiated or is in the process\n     * of negotiating the application m= section.\n     * @returns {boolean}\n     */\n    get: function () {\n      if (this._peerConnection.signalingState !== 'closed') {\n        // accessing .localDescription in 'closed' state causes it throw exceptions.\n        return this._peerConnection.localDescription ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0 : false;\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"_isAdaptiveSimulcastEnabled\", {\n    /**\n     * Whether adaptive simulcast is enabled.\n     * @returns {boolean}\n     */\n    get: function () {\n      var adaptiveSimulcastEntry = this._preferredVideoCodecs.find(function (cs) {\n        return 'adaptiveSimulcast' in cs;\n      });\n\n      return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   * @returns {boolean} true if encodings were updated.\n   */\n\n  PeerConnectionV2.prototype._maybeUpdateEncodings = function (track, encodings, trackReplaced) {\n    if (trackReplaced === void 0) {\n      trackReplaced = false;\n    }\n\n    if (track.kind !== 'video' || track.readyState === 'ended') {\n      return false;\n    }\n\n    var browser = util.guessBrowser(); // Note(mpatwardhan): always configure encodings for safari.\n    // for chrome only when adaptive simulcast enabled.\n\n    if (browser === 'safari' || browser === 'chrome' && this._isAdaptiveSimulcastEnabled) {\n      this._updateEncodings(track, encodings, trackReplaced);\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Configures with default encodings depending on track type and resolution.\n   * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy\n   * values. When trackReplaced is set to true, it will clear 'active' for any encodings that\n   * needs to be enabled.\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   */\n\n\n  PeerConnectionV2.prototype._updateEncodings = function (track, encodings, trackReplaced) {\n    if (this._isChromeScreenShareTrack(track)) {\n      var screenShareActiveLayerConfig_1 = [{\n        scaleResolutionDownBy: 1\n      }, {\n        scaleResolutionDownBy: 1\n      }];\n      encodings.forEach(function (encoding, i) {\n        var activeLayerConfig = screenShareActiveLayerConfig_1[i];\n\n        if (activeLayerConfig) {\n          encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;\n\n          if (trackReplaced) {\n            delete encoding.active;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    } else {\n      var _a = track.getSettings(),\n          width = _a.width,\n          height = _a.height; // NOTE(mpatwardhan): for non-screen share tracks\n      // enable layers depending on track resolutions\n\n\n      var pixelsToMaxActiveLayers = [{\n        pixels: 960 * 540,\n        maxActiveLayers: 3\n      }, {\n        pixels: 480 * 270,\n        maxActiveLayers: 2\n      }, {\n        pixels: 0,\n        maxActiveLayers: 1\n      }];\n      var trackPixels_1 = width * height;\n      var activeLayersInfo = pixelsToMaxActiveLayers.find(function (layer) {\n        return trackPixels_1 >= layer.pixels;\n      });\n      var activeLayers_1 = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);\n      encodings.forEach(function (encoding, i) {\n        var enabled = i < activeLayers_1;\n\n        if (enabled) {\n          encoding.scaleResolutionDownBy = 1 << activeLayers_1 - i - 1;\n\n          if (trackReplaced) {\n            encoding.active = true;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    }\n\n    this._log.debug('_updateEncodings:', encodings.map(function (_a, i) {\n      var active = _a.active,\n          scaleResolutionDownBy = _a.scaleResolutionDownBy;\n      return \"[\" + i + \": \" + active + \", \" + (scaleResolutionDownBy || 0) + \"]\";\n    }).join(', '));\n  };\n  /**\n   * Add an ICE candidate to the {@link PeerConnectionV2}.\n   * @private\n   * @param {object} candidate\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._addIceCandidate = function (candidate) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      candidate = new _this._RTCIceCandidate(candidate);\n      return _this._peerConnection.addIceCandidate(candidate);\n    }).catch(function (error) {\n      // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an\n      // empty candidate string to signal end-of-candidates, followed by a null\n      // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since\n      // this does not affect the media connection between Firefox 68+ and Chrome/Safari\n      // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.\n      //\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n      //\n      _this._log.warn(\"Failed to add RTCIceCandidate \" + (candidate ? \"\\\"\" + candidate.candidate + \"\\\"\" : 'null') + \": \" + error.message);\n    });\n  };\n  /**\n   * Add ICE candidates to the {@link PeerConnectionV2}.\n   * @private\n   * @param {Array<object>} candidates\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._addIceCandidates = function (candidates) {\n    return Promise.all(candidates.map(this._addIceCandidate, this)).then(function () {});\n  };\n  /**\n   * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the\n   * given MediaStreamTrack.\n   * @private\n   * @param {MediaStreamTrack} track\n   * @returns {RTCRtpTransceiver}\n   */\n\n\n  PeerConnectionV2.prototype._addOrUpdateTransceiver = function (track) {\n    var _this = this;\n\n    var transceiver = takeRecycledTransceiver(this, track.kind);\n\n    if (transceiver && transceiver.sender) {\n      var oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;\n\n      if (oldTrackId) {\n        this._log.warn(\"Reusing transceiver: \" + transceiver.mid + \"] \" + oldTrackId + \" => \" + track.id);\n      } // NOTE(mpatwardhan):remember this transceiver while we replace track.\n      // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent\n      // this one from getting recycled while replaceTrack is pending.\n\n\n      this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(function () {\n        transceiver.direction = 'sendrecv';\n      }, function () {// Do nothing.\n      }).finally(function () {\n        _this._replaceTrackPromises.delete(transceiver);\n      }));\n\n      return transceiver;\n    }\n\n    return this._peerConnection.addTransceiver(track);\n  };\n  /**\n   * Check the {@link IceBox}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._checkIceBox = function (description) {\n    var ufrag = getUfrag(description);\n\n    if (!ufrag) {\n      return Promise.resolve();\n    }\n\n    var candidates = this._remoteCandidates.setUfrag(ufrag);\n\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Create an answer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<boolean>}\n   */\n\n\n  PeerConnectionV2.prototype._answer = function (offer) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'answerer';\n      }\n\n      return _this._setRemoteDescription(offer);\n    }).catch(function () {\n      throw new MediaClientRemoteDescFailedError();\n    }).then(function () {\n      return _this._peerConnection.createAnswer();\n    }).then(function (answer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        answer = new _this._RTCSessionDescription({\n          sdp: disableRtx(answer.sdp),\n          type: answer.type\n        });\n      } else {\n        answer = workaroundIssue8329(answer);\n      } // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n\n\n      var updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);\n\n      if (_this._shouldApplySimulcast) {\n        var sdpWithoutSimulcast = updatedSdp;\n        updatedSdp = _this._setSimulcast(sdpWithoutSimulcast, _this._trackIdsToAttributes); // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n        // unset simulcast for sections in local offer where corresponding\n        // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n\n        updatedSdp = _this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);\n      } // NOTE(mmalavalli): Work around Chromium bug 1074421.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421\n\n\n      updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');\n      return _this._setLocalDescription({\n        type: answer.type,\n        sdp: updatedSdp\n      });\n    }).then(function () {\n      return _this._checkIceBox(offer);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription);\n    }).catch(function (error) {\n      var errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();\n\n      _this._publishMediaWarning({\n        message: 'Failed to _answer',\n        code: errorToThrow.code,\n        error: error\n      });\n\n      throw errorToThrow;\n    });\n  };\n  /**\n   * Close the underlying RTCPeerConnection. Returns false if the\n   * RTCPeerConnection was already closed.\n   * @private\n   * @returns {boolean}\n   */\n\n\n  PeerConnectionV2.prototype._close = function () {\n    this._iceConnectionMonitor.stop();\n\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.close();\n\n      this.preempt('closed');\n\n      this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Handle a \"connectionstatechange\" event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleConnectionStateChange = function () {\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle a \"datachannel\" event.\n   * @private\n   * @param {RTCDataChannelEvent} event\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleDataChannelEvent = function (event) {\n    var _this = this;\n\n    var dataChannel = event.channel;\n    var dataTrackReceiver = new DataTrackReceiver(dataChannel);\n\n    this._dataTrackReceivers.add(dataTrackReceiver);\n\n    dataChannel.addEventListener('close', function () {\n      _this._dataTrackReceivers.delete(dataTrackReceiver);\n    });\n    this.emit('trackAdded', dataTrackReceiver);\n  };\n  /**\n   * Handle a glare scenario on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._handleGlare = function (offer) {\n    var _this = this;\n\n    this._log.debug('Glare detected; rolling back');\n\n    if (this._isRestartingIce) {\n      this._log.debug('An ICE restart was in progress; we\\'ll need to restart ICE again after rolling back');\n\n      this._isRestartingIce = false;\n      this._shouldRestartIce = true;\n    }\n\n    return Promise.resolve().then(function () {\n      _this._trackIdsToAttributes = new Map(_this._appliedTrackIdsToAttributes);\n      return _this._setLocalDescription({\n        type: 'rollback'\n      });\n    }).then(function () {\n      _this._needsAnswer = false;\n      return _this._answer(offer);\n    }).then(function (didReoffer) {\n      return didReoffer ? Promise.resolve() : _this._offer();\n    });\n  };\n\n  PeerConnectionV2.prototype._publishMediaWarning = function (_a) {\n    var message = _a.message,\n        code = _a.code,\n        error = _a.error,\n        sdp = _a.sdp;\n\n    this._eventObserver.emit('event', {\n      level: 'warning',\n      name: 'error',\n      group: 'media',\n      payload: {\n        message: message,\n        code: code,\n        context: JSON.stringify({\n          error: error.message,\n          sdp: sdp\n        })\n      }\n    });\n  };\n  /**\n   * Handle an ICE candidate event.\n   * @private\n   * @param {Event} event\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceCandidateEvent = function (event) {\n    if (event.candidate) {\n      this._log.debug('Clearing ICE gathering timeout');\n\n      this._didGenerateLocalCandidates = true;\n\n      this._iceGatheringTimeout.clear();\n\n      this._localCandidates.push(event.candidate);\n    }\n\n    var peerConnectionState = {\n      ice: {\n        candidates: this._isIceLite ? [] : this._localCandidates.slice(),\n        ufrag: this._localUfrag\n      },\n      id: this.id\n    };\n\n    if (!event.candidate) {\n      peerConnectionState.ice.complete = true;\n    }\n\n    if (!(this._isIceLite && event.candidate)) {\n      peerConnectionState.ice.revision = this._localCandidatesRevision++;\n      this.emit('candidates', peerConnectionState);\n    }\n  };\n  /**\n   * Handle an ICE connection state change event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceConnectionStateChange = function () {\n    var _this = this;\n\n    var iceConnectionState = this._peerConnection.iceConnectionState;\n    var isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);\n    var log = this._log;\n    log.debug(\"ICE connection state is \\\"\" + iceConnectionState + \"\\\"\");\n\n    if (isIceConnectedOrComplete) {\n      this._iceReconnectTimeout.clear();\n\n      this._iceRestartBackoff.reset();\n    }\n\n    if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {\n      // Case 1: Transition to \"failed\".\n      log.warn('ICE failed');\n\n      this._initiateIceRestartBackoff();\n    } else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {\n      // Case 2: Transition from \"disconnected\" or \"failed\".\n      log.debug('ICE reconnected');\n    } // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.\n\n\n    if (iceConnectionState === 'connected') {\n      this._isIceConnectionInactive = false;\n\n      this._iceConnectionMonitor.start(function () {\n        // note: iceConnection monitor waits for iceConnectionState=disconnected for\n        // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange\n        _this._iceConnectionMonitor.stop();\n\n        if (!_this._shouldRestartIce && !_this._isRestartingIce) {\n          log.warn('ICE Connection Monitor detected inactivity');\n          _this._isIceConnectionInactive = true;\n\n          _this._initiateIceRestartBackoff();\n\n          _this.emit('iceConnectionStateChanged');\n\n          _this.emit('connectionStateChanged');\n        }\n      });\n    } else if (!['disconnected', 'completed'].includes(iceConnectionState)) {\n      // don't stop monitoring for disconnected or completed.\n      this._iceConnectionMonitor.stop();\n\n      this._isIceConnectionInactive = false;\n    }\n\n    this._lastIceConnectionState = iceConnectionState;\n    this.emit('iceConnectionStateChanged');\n  };\n  /**\n   * Handle ICE gathering timeout.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceGatheringTimeout = function () {\n    this._log.warn('ICE failed to gather any local candidates');\n\n    this._iceGatheringFailed = true;\n\n    this._initiateIceRestartBackoff();\n\n    this.emit('iceConnectionStateChanged');\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle an ICE gathering state change event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleIceGatheringStateChange = function () {\n    var iceGatheringState = this._peerConnection.iceGatheringState;\n    var log = this._log;\n    log.debug(\"ICE gathering state is \\\"\" + iceGatheringState + \"\\\"\"); // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection\n    // has started gathering candidates for the first time since the initial offer/answer\n    // or an offer/answer with ICE restart.\n\n    var _a = this._iceGatheringTimeout,\n        delay = _a.delay,\n        isSet = _a.isSet;\n\n    if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {\n      log.debug(\"Starting ICE gathering timeout: \" + delay);\n      this._iceGatheringFailed = false;\n\n      this._iceGatheringTimeout.start();\n    }\n  };\n  /**\n   * Handle a signaling state change event.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleSignalingStateChange = function () {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);\n    }\n  };\n  /**\n   * Handle a track event.\n   * @private\n   * @param {RTCTrackEvent} event\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._handleTrackEvent = function (event) {\n    var _this = this;\n\n    var sdp = this._peerConnection.remoteDescription ? this._peerConnection.remoteDescription.sdp : null;\n    this._trackMatcher = this._trackMatcher || new TrackMatcher();\n\n    this._trackMatcher.update(sdp);\n\n    var mediaStreamTrack = event.track;\n    var signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;\n    var mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack); // NOTE(mmalavalli): \"ended\" is not fired on the remote MediaStreamTrack when\n    // the remote peer removes a track. So, when this MediaStreamTrack is re-used\n    // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),\n    // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack\n    // before adding the new MediaTrackReceiver.\n\n    this._mediaTrackReceivers.forEach(function (trackReceiver) {\n      if (trackReceiver.track.id === mediaTrackReceiver.track.id) {\n        _this._mediaTrackReceivers.delete(trackReceiver);\n      }\n    });\n\n    this._mediaTrackReceivers.add(mediaTrackReceiver);\n\n    mediaStreamTrack.addEventListener('ended', function () {\n      return _this._mediaTrackReceivers.delete(mediaTrackReceiver);\n    });\n    this.emit('trackAdded', mediaTrackReceiver);\n  };\n  /**\n   * Initiate ICE Restart.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._initiateIceRestart = function () {\n    if (this._peerConnection.signalingState === 'closed') {\n      return;\n    }\n\n    var log = this._log;\n    log.warn('Attempting to restart ICE');\n    this._didGenerateLocalCandidates = false;\n    this._isIceRestartBackoffInProgress = false;\n    this._shouldRestartIce = true;\n    var _a = this._iceReconnectTimeout,\n        delay = _a.delay,\n        isSet = _a.isSet;\n\n    if (!isSet) {\n      log.debug(\"Starting ICE reconnect timeout: \" + delay);\n\n      this._iceReconnectTimeout.start();\n    }\n\n    this.offer().catch(function (ex) {\n      log.error(\"offer failed in _initiateIceRestart with: \" + ex.message);\n    });\n  };\n  /**\n   * Schedule an ICE Restart.\n   * @private\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype._initiateIceRestartBackoff = function () {\n    var _this = this;\n\n    if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {\n      return;\n    }\n\n    this._log.warn('An ICE restart has been scheduled');\n\n    this._isIceRestartBackoffInProgress = true;\n\n    this._iceRestartBackoff.backoff(function () {\n      return _this._initiateIceRestart();\n    });\n  };\n  /**\n   * Conditionally re-offer.\n   * @private\n   * @param {?RTCSessionDescriptionInit} localDescription\n   * @returns {Promise<boolean>}\n   */\n\n\n  PeerConnectionV2.prototype._maybeReoffer = function (localDescription) {\n    var shouldReoffer = this._shouldOffer;\n\n    if (localDescription && localDescription.sdp) {\n      // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or\n      // video send* m= lines than the corresponding RTCRtpSenders with non-null\n      // MediaStreamTracks, it means that the newly added RTCRtpSenders require\n      // renegotiation.\n      var senders_1 = this._peerConnection.getSenders().filter(function (sender) {\n        return sender.track;\n      });\n\n      shouldReoffer = ['audio', 'video'].reduce(function (shouldOffer, kind) {\n        var mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');\n        var sendersOfKind = senders_1.filter(isSenderOfKind.bind(null, kind));\n        return shouldOffer || mediaSections.length < sendersOfKind.length;\n      }, shouldReoffer); // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share\n      // but no m= application section.\n\n      var hasDataTrack = this._dataChannels.size > 0;\n      var hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;\n      var needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;\n      shouldReoffer = shouldReoffer || needsApplicationMediaSection;\n    }\n\n    var promise = shouldReoffer ? this._offer() : Promise.resolve();\n    return promise.then(function () {\n      return shouldReoffer;\n    });\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._offer = function () {\n    var _this = this;\n\n    var offerOptions = Object.assign({}, this._offerOptions);\n    this._needsAnswer = true;\n\n    if (this._shouldRestartIce) {\n      this._shouldRestartIce = false;\n      this._isRestartingIce = true;\n      offerOptions.iceRestart = true;\n    }\n\n    return Promise.all(this._replaceTrackPromises.values()).then(function () {\n      return _this._peerConnection.createOffer(offerOptions);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientLocalDescFailedError();\n\n      _this._publishMediaWarning({\n        message: 'Failed to create offer',\n        code: errorToThrow.code,\n        error: error\n      });\n\n      throw errorToThrow;\n    }).then(function (offer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        offer = new _this._RTCSessionDescription({\n          sdp: disableRtx(offer.sdp),\n          type: offer.type\n        });\n      } else {\n        offer = workaroundIssue8329(offer);\n      } // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n\n\n      var sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);\n      sdp = _this._peerConnection.remoteDescription ? filterLocalCodecs(sdp, _this._peerConnection.remoteDescription.sdp) : sdp;\n\n      var updatedSdp = _this._setCodecPreferences(sdp, _this._preferredAudioCodecs, _this._preferredVideoCodecs);\n\n      _this._shouldOffer = false;\n\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'offerer';\n      }\n\n      if (_this._shouldApplySimulcast) {\n        _this._localDescriptionWithoutSimulcast = {\n          type: 'offer',\n          sdp: updatedSdp\n        };\n        updatedSdp = _this._setSimulcast(updatedSdp, _this._trackIdsToAttributes);\n      }\n\n      return _this._setLocalDescription({\n        type: 'offer',\n        sdp: updatedSdp\n      });\n    });\n  };\n  /**\n   * Get the MediaTrackSender ID of the given MediaStreamTrack ID.\n   * Since a MediaTrackSender's underlying MediaStreamTrack can be\n   * replaced, the corresponding IDs can mismatch.\n   * @private\n   * @param {Track.ID} id\n   * @returns {Track.ID}\n   */\n\n\n  PeerConnectionV2.prototype._getMediaTrackSenderId = function (trackId) {\n    var mediaTrackSender = Array.from(this._rtpSenders.keys()).find(function (_a) {\n      var id = _a.track.id;\n      return id === trackId;\n    });\n    return mediaTrackSender ? mediaTrackSender.id : trackId;\n  };\n  /**\n   * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.\n   * @private\n   * @param {RTCSessionDescription} description\n   * @return {RTCSessionDescription}\n   */\n\n\n  PeerConnectionV2.prototype._addOrRewriteLocalTrackIds = function (description) {\n    var _this = this;\n\n    var transceivers = this._peerConnection.getTransceivers();\n\n    var activeTransceivers = transceivers.filter(function (_a) {\n      var sender = _a.sender,\n          stopped = _a.stopped;\n      return !stopped && sender && sender.track;\n    }); // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in\n    // SDPs, and even if they are, there is no guarantee that they will be the same as the\n    // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs\n    // to the assigned m= sections here.\n\n    var assignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return mid;\n    });\n    var midsToTrackIds = new Map(assignedTransceivers.map(function (_a) {\n      var mid = _a.mid,\n          sender = _a.sender;\n      return [mid, _this._getMediaTrackSenderId(sender.track.id)];\n    }));\n    var sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds); // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.\n    // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.\n\n    var unassignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return !mid;\n    });\n    var newTrackIdsByKind = new Map(['audio', 'video'].map(function (kind) {\n      return [kind, unassignedTransceivers.filter(function (_a) {\n        var sender = _a.sender;\n        return sender.track.kind === kind;\n      }).map(function (_a) {\n        var sender = _a.sender;\n        return _this._getMediaTrackSenderId(sender.track.id);\n      })];\n    }));\n    var sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);\n    return new this._RTCSessionDescription({\n      sdp: sdp2,\n      type: description.type\n    });\n  };\n  /**\n   * Rollback and apply the given offer.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._rollbackAndApplyOffer = function (offer) {\n    var _this = this;\n\n    return this._setLocalDescription({\n      type: 'rollback'\n    }).then(function () {\n      return _this._setLocalDescription(offer);\n    });\n  };\n  /**\n   * Set a local description on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescription|RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._setLocalDescription = function (description) {\n    var _this = this;\n\n    if (description.type !== 'rollback' && this._shouldApplyDtx) {\n      description = new this._RTCSessionDescription({\n        sdp: enableDtxForOpus(description.sdp),\n        type: description.type\n      });\n    }\n\n    return this._peerConnection.setLocalDescription(description).catch(function (error) {\n      _this._log.warn(\"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n\n      var errorToThrow = new MediaClientLocalDescFailedError();\n      var publishWarning = {\n        message: \"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error\n      };\n\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n\n        publishWarning.sdp = description.sdp;\n      }\n\n      _this._publishMediaWarning(publishWarning);\n\n      throw errorToThrow;\n    }).then(function () {\n      if (description.type !== 'rollback') {\n        _this._localDescription = _this._addOrRewriteLocalTrackIds(description); // NOTE(mmalavalli): In order for this feature to be backward compatible with older\n        // SDK versions which to not support opus DTX, we append \"usedtx=1\" to the local SDP\n        // only while applying it. We will not send it over the wire to prevent inadvertent\n        // enabling of opus DTX in older SDKs. Newer SDKs will append \"usedtx=1\" by themselves\n        // if the developer has requested opus DTX to be enabled. (JSDK-3063)\n\n        if (_this._shouldApplyDtx) {\n          _this._localDescription = new _this._RTCSessionDescription({\n            sdp: enableDtxForOpus(_this._localDescription.sdp, []),\n            type: _this._localDescription.type\n          });\n        }\n\n        _this._localCandidates = [];\n\n        if (description.type === 'offer') {\n          _this._descriptionRevision++;\n        } else if (description.type === 'answer') {\n          _this._lastStableDescriptionRevision = _this._descriptionRevision;\n          negotiationCompleted(_this);\n        }\n\n        _this._localUfrag = getUfrag(description);\n\n        _this.emit('description', _this.getState());\n      }\n    });\n  };\n  /**\n   * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._setRemoteDescription = function (description) {\n    var _this = this;\n\n    if (description.sdp) {\n      description.sdp = this._setCodecPreferences(description.sdp, this._preferredAudioCodecs, this._preferredVideoCodecs);\n\n      if (this._shouldApplyDtx) {\n        description.sdp = enableDtxForOpus(description.sdp);\n      } else {\n        // NOTE(mmalavalli): Remove \"usedtx=1\" from opus's fmtp line if present\n        // since DTX is disabled.\n        description.sdp = enableDtxForOpus(description.sdp, []);\n      }\n\n      if (isFirefox) {\n        // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By\n        // mapping MediaStream IDs in the SDP to \"-\", we ensure the \"track\" event\n        // doesn't include any new MediaStreams in Firefox. Its `streams` member\n        // will always be the empty Array.\n        description.sdp = filterOutMediaStreamIds(description.sdp);\n      }\n\n      if (!this._peerConnection.remoteDescription) {\n        this._isIceLite = /a=ice-lite/.test(description.sdp);\n      }\n    }\n\n    description = new this._RTCSessionDescription(description); // eslint-disable-next-line consistent-return\n\n    return Promise.resolve().then(function () {\n      // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n      // unset simulcast for sections in local offer where corresponding\n      // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n      if (description.type === 'answer' && _this._localDescriptionWithoutSimulcast) {\n        // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server\n        // revert simulcast even for vp8.\n        var adaptiveSimulcastEntry = _this._preferredVideoCodecs.find(function (cs) {\n          return 'adaptiveSimulcast' in cs;\n        });\n\n        var revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;\n\n        var sdpWithoutSimulcastForNonVP8MediaSections = _this._revertSimulcast(_this._localDescription.sdp, _this._localDescriptionWithoutSimulcast.sdp, description.sdp, revertForAll);\n\n        _this._localDescriptionWithoutSimulcast = null;\n\n        if (sdpWithoutSimulcastForNonVP8MediaSections !== _this._localDescription.sdp) {\n          return _this._rollbackAndApplyOffer({\n            type: _this._localDescription.type,\n            sdp: sdpWithoutSimulcastForNonVP8MediaSections\n          });\n        }\n      }\n    }).then(function () {\n      return _this._peerConnection.setRemoteDescription(description);\n    }).then(function () {\n      if (description.type === 'answer') {\n        if (_this._isRestartingIce) {\n          _this._log.debug('An ICE restart was in-progress and is now completed');\n\n          _this._isRestartingIce = false;\n        }\n\n        negotiationCompleted(_this);\n      }\n    }, function (error) {\n      _this._log.warn(\"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n      }\n\n      throw error;\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s description.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._updateDescription = function (description) {\n    var _this = this;\n\n    switch (description.type) {\n      case 'answer':\n      case 'pranswer':\n        if (description.revision !== this._descriptionRevision || this._peerConnection.signalingState !== 'have-local-offer') {\n          return Promise.resolve();\n        }\n\n        this._descriptionRevision = description.revision;\n        break;\n\n      case 'close':\n        return this._close();\n\n      case 'create-offer':\n        if (description.revision <= this._lastStableDescriptionRevision) {\n          return Promise.resolve();\n        } else if (this._needsAnswer) {\n          this._queuedDescription = description;\n          return Promise.resolve();\n        }\n\n        this._descriptionRevision = description.revision;\n        return this._offer();\n\n      case 'offer':\n        if (description.revision <= this._lastStableDescriptionRevision || this._peerConnection.signalingState === 'closed') {\n          return Promise.resolve();\n        }\n\n        if (this._peerConnection.signalingState === 'have-local-offer') {\n          // NOTE(mpatwardhan): For a peer connection\n          // 1) createOffer always generate SDP with `setup:actpass`\n          // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive\n          // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active\n          // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)\n          // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936\n          // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.\n          // we do not want that. lets wait for \"initial negotiation\" before attempting glare handling.\n          if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {\n            this._queuedDescription = description;\n            return Promise.resolve();\n          }\n\n          this._descriptionRevision = description.revision;\n          return this._handleGlare(description);\n        }\n\n        this._descriptionRevision = description.revision;\n        return this._answer(description).then(function () {});\n\n      default: // Do nothing.\n\n    } // Handle answer or pranswer.\n\n\n    var revision = description.revision;\n    return Promise.resolve().then(function () {\n      return _this._setRemoteDescription(description);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientRemoteDescFailedError();\n\n      _this._publishMediaWarning({\n        message: \"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error,\n        sdp: description.sdp\n      });\n\n      throw errorToThrow;\n    }).then(function () {\n      _this._lastStableDescriptionRevision = revision;\n      _this._needsAnswer = false;\n      return _this._checkIceBox(description);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription).then(function () {});\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s ICE candidates.\n   * @private\n   * @param {object} iceState\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype._updateIce = function (iceState) {\n    var candidates = this._remoteCandidates.update(iceState);\n\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.addDataTrackSender = function (dataTrackSender) {\n    if (this._dataChannels.has(dataTrackSender)) {\n      return;\n    }\n\n    try {\n      var dataChannelDict = {\n        ordered: dataTrackSender.ordered\n      };\n\n      if (dataTrackSender.maxPacketLifeTime !== null) {\n        dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;\n      }\n\n      if (dataTrackSender.maxRetransmits !== null) {\n        dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;\n      }\n\n      var dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);\n\n      dataTrackSender.addDataChannel(dataChannel);\n\n      this._dataChannels.set(dataTrackSender, dataChannel);\n    } catch (error) {\n      this._log.warn(\"Error creating an RTCDataChannel for DataTrack \\\"\" + dataTrackSender.id + \"\\\": \" + error.message);\n    }\n  };\n\n  PeerConnectionV2.prototype._handleQueuedPublisherHints = function () {\n    var _this = this;\n\n    if (this._peerConnection.signalingState === 'stable') {\n      this._mediaTrackSenderToPublisherHints.forEach(function (_a, mediaTrackSender) {\n        var deferred = _a.deferred,\n            encodings = _a.encodings;\n\n        _this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n\n        _this._setPublisherHint(mediaTrackSender, encodings).then(function (result) {\n          return deferred.resolve(result);\n        }).catch(function (error) {\n          return deferred.reject(error);\n        });\n      });\n    }\n  };\n  /**\n   * updates encodings for simulcast layers of given sender.\n   * @param {RTCRtpSender} sender\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>} string indicating result of the operation. can be one of\n   *  \"OK\", \"INVALID_HINT\", \"COULD_NOT_APPLY_HINT\", \"UNKNOWN_TRACK\"\n   */\n\n\n  PeerConnectionV2.prototype._setPublisherHint = function (mediaTrackSender, encodings) {\n    var _this = this;\n\n    if (isFirefox) {\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      // skip any stale hint associated with the mediaTrackSender.\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n\n      queuedHint.deferred.resolve('REQUEST_SKIPPED');\n\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n\n    var sender = this._rtpSenders.get(mediaTrackSender);\n\n    if (!sender) {\n      this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');\n\n      return Promise.resolve('UNKNOWN_TRACK');\n    }\n\n    if (this._peerConnection.signalingState === 'closed') {\n      this._log.warn('Could not apply publisher hint because signalingState was \"closed\"');\n\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._peerConnection.signalingState !== 'stable') {\n      // enqueue this hint to be applied when pc becomes stable.\n      this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);\n\n      var deferred = defer();\n\n      this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, {\n        deferred: deferred,\n        encodings: encodings\n      });\n\n      return deferred.promise;\n    }\n\n    var parameters = sender.getParameters();\n\n    if (encodings !== null) {\n      encodings.forEach(function (_a) {\n        var enabled = _a.enabled,\n            layerIndex = _a.layer_index;\n\n        if (parameters.encodings.length > layerIndex) {\n          _this._log.debug(\"layer:\" + layerIndex + \", active:\" + parameters.encodings[layerIndex].active + \" => \" + enabled);\n\n          parameters.encodings[layerIndex].active = enabled;\n        } else {\n          _this._log.warn(\"invalid layer:\" + layerIndex + \", active:\" + enabled);\n        }\n      });\n    } // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings\n    // to disable any encoding that shouldn't have been enabled by publisher_hints.\n    // When encodings===null (that is we are asked to reset encodings for replaceTrack)\n    // along with disabling encodings, clear active flag for encodings that should not be disabled\n\n\n    this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null\n    /* trackReplaced */\n    );\n\n    return sender.setParameters(parameters).then(function () {\n      return 'OK';\n    }).catch(function (error) {\n      _this._log.error('Failed to apply publisher hints:', error);\n\n      return 'COULD_NOT_APPLY_HINT';\n    });\n  };\n  /**\n   * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.addMediaTrackSender = function (mediaTrackSender) {\n    var _this = this;\n\n    if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {\n      return;\n    }\n\n    var transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);\n\n    var sender = transceiver.sender;\n    mediaTrackSender.addSender(sender, function (encodings) {\n      return _this._setPublisherHint(mediaTrackSender, encodings);\n    });\n\n    this._rtpNewSenders.add(sender);\n\n    this._rtpSenders.set(mediaTrackSender, sender);\n  };\n  /**\n   * Close the {@link PeerConnectionV2}.\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.close = function () {\n    if (this._close()) {\n      this._descriptionRevision++;\n      this._localDescription = {\n        type: 'close'\n      };\n      this.emit('description', this.getState());\n    }\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the\n   * {@link PeerConnectionV2}.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n\n\n  PeerConnectionV2.prototype.getTrackReceivers = function () {\n    return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s state (specifically, its description).\n   * @returns {?object}\n   */\n\n\n  PeerConnectionV2.prototype.getState = function () {\n    if (!this._localDescription) {\n      return null;\n    } // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an\n    // answer, and this method is called for sending a \"sync\" message while the next remote offer is being processed,\n    // we need to send the most recent stable description revision instead of the current description revision,\n    // which is supposed to be for the next local answer.\n\n\n    var localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;\n    var localDescription = {\n      type: this._localDescription.type,\n      revision: localDescriptionRevision\n    };\n\n    if (this._localDescription.sdp) {\n      localDescription.sdp = this._localDescription.sdp;\n    }\n\n    return {\n      description: localDescription,\n      id: this.id\n    };\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype.offer = function () {\n    var _this = this;\n\n    if (this._needsAnswer || this._isRestartingIce) {\n      this._shouldOffer = true;\n      return Promise.resolve();\n    }\n\n    return this.bracket('offering', function (key) {\n      _this.transition('updating', key);\n\n      var promise = _this._needsAnswer || _this._isRestartingIce ? Promise.resolve() : _this._offer();\n      return promise.then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n\n        throw error;\n      });\n    });\n  };\n  /**\n   * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.removeDataTrackSender = function (dataTrackSender) {\n    var dataChannel = this._dataChannels.get(dataTrackSender);\n\n    if (dataChannel) {\n      dataTrackSender.removeDataChannel(dataChannel);\n\n      this._dataChannels.delete(dataTrackSender);\n\n      dataChannel.close();\n    }\n  };\n  /**\n   * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.removeMediaTrackSender = function (mediaTrackSender) {\n    var sender = this._rtpSenders.get(mediaTrackSender);\n\n    if (!sender) {\n      return;\n    }\n\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.removeTrack(sender);\n    }\n\n    mediaTrackSender.removeSender(sender); // clean up any pending publisher hints associated with this mediaTrackSender.\n\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n\n      queuedHint.deferred.resolve('UNKNOWN_TRACK');\n\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n\n    this._rtpNewSenders.delete(sender);\n\n    this._rtpSenders.delete(mediaTrackSender);\n  };\n  /**\n   * Set the RTCConfiguration on the underlying RTCPeerConnection.\n   * @param {RTCConfiguration} configuration\n   * @returns {void}\n   */\n\n\n  PeerConnectionV2.prototype.setConfiguration = function (configuration) {\n    if (typeof this._peerConnection.setConfiguration === 'function') {\n      this._peerConnection.setConfiguration(getConfiguration(configuration));\n    }\n  };\n  /**\n   * Set the ICE reconnect timeout period.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n\n\n  PeerConnectionV2.prototype.setIceReconnectTimeout = function (period) {\n    this._iceReconnectTimeout.setDelay(period);\n\n    this._log.debug('Updated ICE reconnection timeout period:', this._iceReconnectTimeout.delay);\n\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionV2}.\n   * @param {object} peerConnectionState\n   * @returns {Promise<void>}\n   */\n\n\n  PeerConnectionV2.prototype.update = function (peerConnectionState) {\n    var _this = this;\n\n    return this.bracket('updating', function (key) {\n      if (_this.state === 'closed') {\n        return Promise.resolve();\n      }\n\n      _this.transition('updating', key);\n\n      var updates = [];\n\n      if (peerConnectionState.ice) {\n        updates.push(_this._updateIce(peerConnectionState.ice));\n      }\n\n      if (peerConnectionState.description) {\n        updates.push(_this._updateDescription(peerConnectionState.description));\n      }\n\n      return Promise.all(updates).then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n\n        throw error;\n      });\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s media statistics.\n   * @returns {Promise<StandardizedStatsResponse>}\n   */\n\n\n  PeerConnectionV2.prototype.getStats = function () {\n    var _this = this;\n\n    return getStatistics(this._peerConnection).then(function (response) {\n      return rewriteTrackIds(_this, response);\n    });\n  };\n\n  return PeerConnectionV2;\n}(StateMachine);\n\nfunction rewriteLocalTrackId(pcv2, stats) {\n  var trackId = pcv2._getMediaTrackSenderId(stats.trackId);\n\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\n\nfunction rewriteTrackId(pcv2, stats) {\n  var receiver = __spreadArray([], __read(pcv2._mediaTrackReceivers)).find(function (receiver) {\n    return receiver.track.id === stats.trackId;\n  });\n\n  var trackId = receiver ? receiver.id : null;\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\n\nfunction rewriteTrackIds(pcv2, response) {\n  return Object.assign(response, {\n    remoteAudioTrackStats: response.remoteAudioTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    remoteVideoTrackStats: response.remoteVideoTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    localAudioTrackStats: response.localAudioTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    }),\n    localVideoTrackStats: response.localVideoTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    })\n  });\n}\n/**\n * @event PeerConnectionV2#candidates\n * @param {object} candidates\n */\n\n/**\n * @event PeerConnectionV2#connectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#description\n * @param {object} description\n */\n\n/**\n * @event PeerConnectionV2#iceConnectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#trackAdded\n * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver\n */\n\n\nfunction getUfrag(description) {\n  if (description.sdp) {\n    var match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);\n\n    if (match) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\nfunction getConfiguration(configuration) {\n  return Object.assign({\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n  }, configuration);\n}\n/**\n * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended\n * MediaStreamTrack of a given kind.\n * @private\n * @param {string} kind\n * @param {RTCRtpSender} sender\n * @return {boolean}\n */\n\n\nfunction isSenderOfKind(kind, sender) {\n  var track = sender.track;\n  return track && track.kind === kind && track.readyState !== 'ended';\n}\n/**\n * Preferred codecs.\n * @typedef {object} PreferredCodecs\n * @property {Array<AudioCodec>} audio\n * @property {Array<VideoCodec>} video\n */\n\n\nfunction filterOutMediaStreamIds(sdp) {\n  return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');\n}\n/**\n * Whether an RTCRtpTransceiver can be recycled.\n * @param {RTCRtpTransceiver} transceiver\n * @returns {boolean}\n */\n\n\nfunction shouldRecycleTransceiver(transceiver, pcv2) {\n  return !transceiver.stopped && !pcv2._replaceTrackPromises.has(transceiver) && ['inactive', 'recvonly'].includes(transceiver.direction);\n}\n/**\n * Take a recycled RTCRtpTransceiver if available.\n * @param {PeerConnectionV2} pcv2\n * @param {Track.Kind} kind\n * @returns {?RTCRtpTransceiver}\n */\n\n\nfunction takeRecycledTransceiver(pcv2, kind) {\n  var preferredCodecs = {\n    audio: pcv2._preferredAudioCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    }),\n    video: pcv2._preferredVideoCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    })\n  }[kind];\n  var recycledTransceivers = pcv2._recycledTransceivers[kind];\n  var localCodec = preferredCodecs.find(function (codec) {\n    return pcv2._localCodecs.has(codec);\n  });\n\n  if (!localCodec) {\n    return recycledTransceivers.shift();\n  }\n\n  var transceiver = recycledTransceivers.find(function (transceiver) {\n    var remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);\n\n    return remoteCodecMap && remoteCodecMap.has(localCodec);\n  });\n\n  if (transceiver) {\n    recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);\n  }\n\n  return transceiver;\n}\n/**\n * Update the set of locally supported {@link Codec}s.\n * @param pcv2\n * @returns {void}\n */\n\n\nfunction updateLocalCodecs(pcv2) {\n  var description = pcv2._peerConnection.localDescription;\n\n  if (!description || !description.sdp) {\n    return;\n  }\n\n  getMediaSections(description.sdp).forEach(function (section) {\n    var codecMap = createCodecMapForMediaSection(section);\n    codecMap.forEach(function (pts, codec) {\n      return pcv2._localCodecs.add(codec);\n    });\n  });\n}\n/**\n * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\n\n\nfunction updateRemoteCodecMaps(pcv2) {\n  var description = pcv2._peerConnection.remoteDescription;\n\n  if (!description || !description.sdp) {\n    return;\n  }\n\n  getMediaSections(description.sdp).forEach(function (section) {\n    var matched = section.match(/^a=mid:(.+)$/m);\n\n    if (!matched || !matched[1]) {\n      return;\n    }\n\n    var mid = matched[1];\n    var codecMap = createCodecMapForMediaSection(section);\n\n    pcv2._remoteCodecMaps.set(mid, codecMap);\n  });\n}\n/**\n * Update the list of recycled RTCRtpTransceivers.\n * @param {PeerConnectionV2} pcv2\n */\n\n\nfunction updateRecycledTransceivers(pcv2) {\n  pcv2._recycledTransceivers.audio = [];\n  pcv2._recycledTransceivers.video = [];\n\n  pcv2._peerConnection.getTransceivers().forEach(function (transceiver) {\n    if (shouldRecycleTransceiver(transceiver, pcv2)) {\n      var track = transceiver.receiver.track;\n\n      pcv2._recycledTransceivers[track.kind].push(transceiver);\n    }\n  });\n}\n/**\n * Perform certain updates after an SDP negotiation is completed.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\n\n\nfunction negotiationCompleted(pcv2) {\n  updateRecycledTransceivers(pcv2);\n  updateLocalCodecs(pcv2);\n  updateRemoteCodecMaps(pcv2);\n  updateEncodingParameters(pcv2).then(function () {\n    // if there any any publisher hints queued, apply them now.\n    pcv2._handleQueuedPublisherHints();\n  });\n}\n/**\n * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\n\n\nfunction updateEncodingParameters(pcv2) {\n  var _a = pcv2._encodingParameters,\n      maxAudioBitrate = _a.maxAudioBitrate,\n      maxVideoBitrate = _a.maxVideoBitrate;\n  var maxBitrates = new Map([['audio', maxAudioBitrate], ['video', maxVideoBitrate]]);\n  var promises = [];\n\n  pcv2._peerConnection.getSenders().filter(function (sender) {\n    return sender.track;\n  }).forEach(function (sender) {\n    var maxBitrate = maxBitrates.get(sender.track.kind);\n    var params = sender.getParameters();\n\n    if (maxBitrate === null || maxBitrate === 0) {\n      removeMaxBitrate(params);\n    } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n      // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,\n      // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome\n      pcv2._log.warn(\"Not setting maxBitrate for \" + sender.track.kind + \" Track \" + sender.track.id + \" because it appears to be screen share track: \" + sender.track.label);\n    } else {\n      setMaxBitrate(params, maxBitrate);\n    }\n\n    if (!isFirefox && pcv2._enableDscp && params.encodings.length > 0) {\n      // NOTE(mmalavalli): \"networkPriority\" is a per-sender property and not\n      // a per-encoding-layer property. So, we set the value only on the first\n      // encoding layer. Any attempt to set the value on subsequent encoding\n      // layers (in the case of simulcast) will result in the Promise returned\n      // by RTCRtpSender.setParameters() being rejected.\n      params.encodings[0].networkPriority = 'high';\n    } // when a sender is reused, delete any active encodings set by server.\n\n\n    var trackReplaced = pcv2._rtpNewSenders.has(sender);\n\n    pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);\n\n    pcv2._rtpNewSenders.delete(sender);\n\n    var promise = sender.setParameters(params).catch(function (error) {\n      pcv2._log.warn(\"Error while setting encodings parameters for \" + sender.track.kind + \" Track \" + sender.track.id + \": \" + (error.message || error.name));\n    });\n    promises.push(promise);\n  });\n\n  return Promise.all(promises);\n}\n/**\n * Remove maxBitrate from the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @returns {void}\n */\n\n\nfunction removeMaxBitrate(params) {\n  if (Array.isArray(params.encodings)) {\n    params.encodings.forEach(function (encoding) {\n      return delete encoding.maxBitrate;\n    });\n  }\n}\n/**\n * Set the given maxBitrate in the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @param {number} maxBitrate\n * @returns {void}\n */\n\n\nfunction setMaxBitrate(params, maxBitrate) {\n  if (isFirefox) {\n    params.encodings = [{\n      maxBitrate: maxBitrate\n    }];\n  } else {\n    params.encodings.forEach(function (encoding) {\n      encoding.maxBitrate = maxBitrate;\n    });\n  }\n}\n\nmodule.exports = PeerConnectionV2;","map":{"version":3,"mappings":"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","names":["DefaultBackoff","require","DefaultRTCIceCandidate","DefaultRTCPeerConnection","DefaultRTCSessionDescription","getStatistics","util","DEFAULT_ICE_GATHERING_TIMEOUT_MS","DEFAULT_LOG_LEVEL","DEFAULT_SESSION_TIMEOUT_SEC","iceRestartBackoffConfig","addOrRewriteNewTrackIds","addOrRewriteTrackIds","createCodecMapForMediaSection","disableRtx","enableDtxForOpus","filterLocalCodecs","getMediaSections","removeSSRCAttributes","revertSimulcast","setCodecPreferences","setSimulcast","DefaultTimeout","MediaClientLocalDescFailedError","MediaClientRemoteDescFailedError","buildLogLevels","getPlatform","isChromeScreenShareTrack","oncePerTick","defer","IceBox","DefaultIceConnectionMonitor","DataTrackReceiver","MediaTrackReceiver","StateMachine","Log","TrackMatcher","workaroundIssue8329","guess","guessBrowser","platform","isAndroid","test","isChrome","isFirefox","isSafari","nInstances","states","open","updating","closed","__extends","id","encodingParameters","preferredCodecs","options","_super","Object","assign","enableDscp","dummyAudioMediaStreamTrack","iceServers","logLevel","offerOptions","sessionTimeout","Backoff","IceConnectionMonitor","RTCIceCandidate","RTCPeerConnection","RTCSessionDescription","Timeout","configuration","getConfiguration","logLevels","chromeSpecificConstraints","optional","push","googDscp","log","createLog","_this","loggerName","peerConnection","addTrack","defineProperties","_appliedTrackIdsToAttributes","value","Map","writable","_dataChannels","_dataTrackReceivers","Set","_descriptionRevision","_didGenerateLocalCandidates","_enableDscp","_encodingParameters","_isChromeScreenShareTrack","_iceGatheringFailed","_iceGatheringTimeout","_handleIceGatheringTimeout","_iceRestartBackoff","_instanceId","_isIceConnectionInactive","_isIceLite","_isIceRestartBackoffInProgress","_isRestartingIce","_lastIceConnectionState","_lastStableDescriptionRevision","_localCandidates","_localCodecs","_localCandidatesRevision","_localDescriptionWithoutSimulcast","_localDescription","_localUfrag","_log","_eventObserver","eventObserver","_remoteCodecMaps","_rtpSenders","_rtpNewSenders","_iceConnectionMonitor","_mediaTrackReceivers","_needsAnswer","_negotiationRole","_offerOptions","_onEncodingParametersChanged","updateEncodingParameters","_peerConnection","_preferredAudioCodecs","audio","_preferredVideoCodecs","video","_shouldApplyDtx","every","_a","codec","some","dtx","_queuedDescription","_iceReconnectTimeout","debug","close","_recycledTransceivers","_replaceTrackPromises","_remoteCandidates","_setCodecPreferences","toLowerCase","_setSimulcast","_revertSimulcast","_RTCIceCandidate","_RTCPeerConnection","_RTCSessionDescription","_shouldOffer","_shouldRestartIce","_trackIdsToAttributes","_trackMatcher","_mediaTrackSenderToPublisherHints","enumerable","on","addEventListener","_handleConnectionStateChange","bind","_handleDataChannelEvent","_handleIceCandidateEvent","_handleIceConnectionStateChange","_handleIceGatheringStateChange","_handleSignalingStateChange","_handleTrackEvent","self","stateChanged","state","removeListener","forEach","dataChannel","dataTrackSender","removeDataTrackSender","PeerConnectionV2","effectiveAdaptiveSimulcast","cs","adaptiveSimulcast","simulcast","iceConnectionState","connectionState","signalingState","localDescription","sdp","length","adaptiveSimulcastEntry","find","track","encodings","trackReplaced","kind","readyState","browser","_isAdaptiveSimulcastEnabled","_updateEncodings","screenShareActiveLayerConfig_1","scaleResolutionDownBy","encoding","i","activeLayerConfig","active","getSettings","width","height","pixelsToMaxActiveLayers","pixels","maxActiveLayers","trackPixels_1","activeLayersInfo","layer","activeLayers_1","Math","min","enabled","map","join","candidate","Promise","resolve","then","addIceCandidate","catch","warn","error","message","candidates","all","_addIceCandidate","transceiver","takeRecycledTransceiver","sender","oldTrackId","mid","set","replaceTrack","direction","finally","delete","addTransceiver","description","ufrag","getUfrag","setUfrag","_addIceCandidates","offer","_setRemoteDescription","createAnswer","answer","type","updatedSdp","_shouldApplySimulcast","sdpWithoutSimulcast","replace","_setLocalDescription","_checkIceBox","_updateDescription","_maybeReoffer","errorToThrow","_publishMediaWarning","code","stop","preempt","emit","event","channel","dataTrackReceiver","add","_answer","didReoffer","_offer","level","name","group","payload","context","JSON","stringify","clear","peerConnectionState","ice","slice","complete","revision","isIceConnectedOrComplete","includes","reset","_initiateIceRestartBackoff","start","iceGatheringState","delay","isSet","remoteDescription","update","mediaStreamTrack","signaledTrackId","match","mediaTrackReceiver","trackReceiver","ex","backoff","_initiateIceRestart","shouldReoffer","senders_1","getSenders","filter","reduce","shouldOffer","mediaSections","sendersOfKind","isSenderOfKind","hasDataTrack","size","hasApplicationMediaSection","needsApplicationMediaSection","promise","iceRestart","values","createOffer","trackId","mediaTrackSender","Array","from","keys","transceivers","getTransceivers","activeTransceivers","stopped","assignedTransceivers","midsToTrackIds","_getMediaTrackSenderId","sdp1","unassignedTransceivers","newTrackIdsByKind","sdp2","setLocalDescription","publishWarning","_addOrRewriteLocalTrackIds","negotiationCompleted","getState","filterOutMediaStreamIds","revertForAll","sdpWithoutSimulcastForNonVP8MediaSections","_rollbackAndApplyOffer","setRemoteDescription","_close","_handleGlare","iceState","has","dataChannelDict","ordered","maxPacketLifeTime","maxRetransmits","createDataChannel","addDataChannel","deferred","_setPublisherHint","result","reject","queuedHint","get","parameters","getParameters","layerIndex","_maybeUpdateEncodings","setParameters","_addOrUpdateTransceiver","addSender","concat","localDescriptionRevision","bracket","transition","key","tryTransition","removeDataChannel","removeTrack","removeSender","setConfiguration","period","setDelay","updates","_updateIce","response","rewriteLocalTrackId","pcv2","stats","rewriteTrackId","receiver","__spreadArray","rewriteTrackIds","remoteAudioTrackStats","remoteVideoTrackStats","localAudioTrackStats","localVideoTrackStats","bundlePolicy","rtcpMuxPolicy","shouldRecycleTransceiver","recycledTransceivers","localCodec","shift","remoteCodecMap","splice","indexOf","updateLocalCodecs","codecMap","section","pts","updateRemoteCodecMaps","matched","updateRecycledTransceivers","_handleQueuedPublisherHints","maxAudioBitrate","maxVideoBitrate","maxBitrates","promises","maxBitrate","params","removeMaxBitrate","label","setMaxBitrate","networkPriority","isArray","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/signaling/v2/peerconnection.js"],"sourcesContent":["'use strict';\n\nconst DefaultBackoff = require('../../util/backoff');\nconst {\n  RTCIceCandidate: DefaultRTCIceCandidate,\n  RTCPeerConnection: DefaultRTCPeerConnection,\n  RTCSessionDescription: DefaultRTCSessionDescription,\n  getStats: getStatistics\n} = require('../../webrtc');\n\nconst util = require('../../webrtc/util');\n\nconst {\n  DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n  DEFAULT_LOG_LEVEL,\n  DEFAULT_SESSION_TIMEOUT_SEC,\n  iceRestartBackoffConfig\n} = require('../../util/constants');\n\nconst {\n  addOrRewriteNewTrackIds,\n  addOrRewriteTrackIds,\n  createCodecMapForMediaSection,\n  disableRtx,\n  enableDtxForOpus,\n  filterLocalCodecs,\n  getMediaSections,\n  removeSSRCAttributes,\n  revertSimulcast,\n  setCodecPreferences,\n  setSimulcast\n} = require('../../util/sdp');\n\nconst DefaultTimeout = require('../../util/timeout');\n\nconst {\n  MediaClientLocalDescFailedError,\n  MediaClientRemoteDescFailedError\n} = require('../../util/twilio-video-errors');\n\nconst {\n  buildLogLevels,\n  getPlatform,\n  isChromeScreenShareTrack,\n  oncePerTick,\n  defer\n} = require('../../util');\n\nconst IceBox = require('./icebox');\nconst DefaultIceConnectionMonitor = require('./iceconnectionmonitor.js');\nconst DataTrackReceiver = require('../../data/receiver');\nconst MediaTrackReceiver = require('../../media/track/receiver');\nconst StateMachine = require('../../statemachine');\nconst Log = require('../../util/log');\nconst TrackMatcher = require('../../util/sdp/trackmatcher');\nconst workaroundIssue8329 = require('../../util/sdp/issue8329');\n\nconst guess = util.guessBrowser();\nconst platform = getPlatform();\nconst isAndroid = /android/.test(platform);\nconst isChrome = guess === 'chrome';\nconst isFirefox = guess === 'firefox';\nconst isSafari = guess === 'safari';\n\nlet nInstances = 0;\n\n/*\nPeerConnectionV2 States\n-----------------------\n\n    +------+    +--------+\n    |      |    |        |\n    | open |--->| closed |\n    |      |    |        |\n    +------+    +--------+\n      |  ^          ^\n      |  |          |\n      |  |          |\n      v  |          |\n  +----------+      |\n  |          |      |\n  | updating |------+\n  |          |\n  +----------+\n\n*/\n\nconst states = {\n  open: [\n    'closed',\n    'updating'\n  ],\n  updating: [\n    'closed',\n    'open'\n  ],\n  closed: []\n};\n\n/**\n * @extends StateMachine\n * @property {id}\n * @emits PeerConnectionV2#connectionStateChanged\n * @emits PeerConnectionV2#iceConnectionStateChanged\n * @emits PeerConnectionV2#candidates\n * @emits PeerConnectionV2#description\n */\nclass PeerConnectionV2 extends StateMachine {\n  /**\n   * Construct a {@link PeerConnectionV2}.\n   * @param {string} id\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} [options]\n   */\n  constructor(id, encodingParameters, preferredCodecs, options) {\n    super('open', states);\n    options = Object.assign({\n      enableDscp: false,\n      dummyAudioMediaStreamTrack: null,\n      isChromeScreenShareTrack,\n      iceServers: [],\n      logLevel: DEFAULT_LOG_LEVEL,\n      offerOptions: {},\n      revertSimulcast,\n      sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,\n      setCodecPreferences,\n      setSimulcast,\n      Backoff: DefaultBackoff,\n      IceConnectionMonitor: DefaultIceConnectionMonitor,\n      RTCIceCandidate: DefaultRTCIceCandidate,\n      RTCPeerConnection: DefaultRTCPeerConnection,\n      RTCSessionDescription: DefaultRTCSessionDescription,\n      Timeout: DefaultTimeout\n    }, options);\n\n    const configuration = getConfiguration(options);\n    const logLevels = buildLogLevels(options.logLevel);\n    const RTCPeerConnection = options.RTCPeerConnection;\n\n    if (options.enableDscp === true) {\n      options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};\n      options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];\n      options.chromeSpecificConstraints.optional.push({ googDscp: true });\n    }\n\n    const log = options.log ? options.log.createLog('webrtc', this) : new Log('webrtc', this, logLevels, options.loggerName);\n    const peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);\n\n    if (options.dummyAudioMediaStreamTrack) {\n      peerConnection.addTrack(options.dummyAudioMediaStreamTrack);\n    }\n\n    Object.defineProperties(this, {\n      _appliedTrackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _dataChannels: {\n        value: new Map()\n      },\n      _dataTrackReceivers: {\n        value: new Set()\n      },\n      _descriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _didGenerateLocalCandidates: {\n        writable: true,\n        value: false\n      },\n      _enableDscp: {\n        value: options.enableDscp\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _isChromeScreenShareTrack: {\n        value: options.isChromeScreenShareTrack,\n      },\n      _iceGatheringFailed: {\n        value: false,\n        writable: true\n      },\n      _iceGatheringTimeout: {\n        value: new options.Timeout(\n          () => this._handleIceGatheringTimeout(),\n          DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n          false)\n      },\n      _iceRestartBackoff: {\n        // eslint-disable-next-line new-cap\n        value: new options.Backoff(iceRestartBackoffConfig)\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _isIceConnectionInactive: {\n        writable: true,\n        value: false\n      },\n      _isIceLite: {\n        writable: true,\n        value: false\n      },\n      _isIceRestartBackoffInProgress: {\n        writable: true,\n        value: false\n      },\n      _isRestartingIce: {\n        writable: true,\n        value: false\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: null\n      },\n      _lastStableDescriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _localCandidates: {\n        writable: true,\n        value: []\n      },\n      _localCodecs: {\n        value: new Set()\n      },\n      _localCandidatesRevision: {\n        writable: true,\n        value: 1\n      },\n      _localDescriptionWithoutSimulcast: {\n        writable: true,\n        value: null\n      },\n      _localDescription: {\n        writable: true,\n        value: null\n      },\n      _localUfrag: {\n        writable: true,\n        value: null\n      },\n      _log: {\n        value: log\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _remoteCodecMaps: {\n        value: new Map()\n      },\n      _rtpSenders: {\n        value: new Map()\n      },\n      _rtpNewSenders: {\n        value: new Set()\n      },\n      _iceConnectionMonitor: {\n        value: new options.IceConnectionMonitor(peerConnection)\n      },\n      _mediaTrackReceivers: {\n        value: new Set()\n      },\n      _needsAnswer: {\n        writable: true,\n        value: false\n      },\n      _negotiationRole: {\n        writable: true,\n        value: null\n      },\n      _offerOptions: {\n        writable: true,\n        value: options.offerOptions\n      },\n      _onEncodingParametersChanged: {\n        value: oncePerTick(() => {\n          if (!this._needsAnswer) {\n            updateEncodingParameters(this);\n          }\n        })\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _preferredAudioCodecs: {\n        value: preferredCodecs.audio\n      },\n      _preferredVideoCodecs: {\n        value: preferredCodecs.video\n      },\n      _shouldApplyDtx: {\n        value: preferredCodecs.audio.every(({ codec }) => codec !== 'opus')\n          || preferredCodecs.audio.some(({ codec, dtx }) => codec === 'opus' && dtx)\n      },\n      _queuedDescription: {\n        writable: true,\n        value: null\n      },\n      _iceReconnectTimeout: {\n        value: new options.Timeout(() => {\n          log.debug('ICE reconnect timed out');\n          this.close();\n        }, options.sessionTimeout, false)\n      },\n      _recycledTransceivers: {\n        value: {\n          audio: [],\n          video: []\n        }\n      },\n      _replaceTrackPromises: {\n        value: new Map()\n      },\n      _remoteCandidates: {\n        writable: true,\n        value: new IceBox()\n      },\n      _setCodecPreferences: {\n        // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264\n        // preferred codec is selected does not work on Android Firefox due to this behavior:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by\n        // not applying any non-H264 preferred video codec.\n        value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264'\n          ? sdp => sdp\n          : options.setCodecPreferences\n      },\n      _setSimulcast: {\n        value: options.setSimulcast\n      },\n      _revertSimulcast: {\n        value: options.revertSimulcast\n      },\n      _RTCIceCandidate: {\n        value: options.RTCIceCandidate\n      },\n      _RTCPeerConnection: {\n        value: options.RTCPeerConnection\n      },\n      _RTCSessionDescription: {\n        value: options.RTCSessionDescription\n      },\n      _shouldOffer: {\n        writable: true,\n        value: false\n      },\n      _shouldRestartIce: {\n        writable: true,\n        value: false\n      },\n      _trackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _trackMatcher: {\n        writable: true,\n        value: null\n      },\n      _mediaTrackSenderToPublisherHints: {\n        value: new Map()\n      },\n      id: {\n        enumerable: true,\n        value: id\n      }\n    });\n\n    encodingParameters.on('changed', this._onEncodingParametersChanged);\n\n    peerConnection.addEventListener('connectionstatechange', this._handleConnectionStateChange.bind(this));\n    peerConnection.addEventListener('datachannel', this._handleDataChannelEvent.bind(this));\n    peerConnection.addEventListener('icecandidate', this._handleIceCandidateEvent.bind(this));\n    peerConnection.addEventListener('iceconnectionstatechange', this._handleIceConnectionStateChange.bind(this));\n    peerConnection.addEventListener('icegatheringstatechange', this._handleIceGatheringStateChange.bind(this));\n    peerConnection.addEventListener('signalingstatechange', this._handleSignalingStateChange.bind(this));\n    peerConnection.addEventListener('track', this._handleTrackEvent.bind(this));\n\n    const self = this;\n    this.on('stateChanged', function stateChanged(state) {\n      if (state !== 'closed') {\n        return;\n      }\n      self.removeListener('stateChanged', stateChanged);\n      self._dataChannels.forEach((dataChannel, dataTrackSender) => {\n        self.removeDataTrackSender(dataTrackSender);\n      });\n    });\n  }\n\n  toString() {\n    return `[PeerConnectionV2 #${this._instanceId}: ${this.id}]`;\n  }\n\n  setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast) {\n    this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast);\n    // clear adaptive simulcast from codec preferences if it was set.\n    this._preferredVideoCodecs.forEach(cs => {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  }\n\n  get _shouldApplySimulcast() {\n    if (!isChrome && !isSafari) {\n      return false;\n    }\n\n    // adaptiveSimulcast is set to false after connected message is received if other party does not support it.\n    const simulcast = this._preferredVideoCodecs.some(cs => {\n      return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;\n    });\n\n    return simulcast;\n  }\n\n  /**\n   * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState\n   * if supported by the browser, its RTCIceConnectionState otherwise.\n   * @property {RTCPeerConnectionState}\n   */\n  get connectionState() {\n    return this.iceConnectionState === 'failed'\n      ? 'failed' : (this._peerConnection.connectionState || this.iceConnectionState);\n  }\n\n  /**\n   * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's\n   * RTCIceConnectionState.\n   * @property {RTCIceConnectionState}\n   */\n  get iceConnectionState() {\n    return ((this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected') || this._iceGatheringFailed)\n      ? 'failed' : this._peerConnection.iceConnectionState;\n  }\n\n  /**\n   * Whether the {@link PeerConnectionV2} has negotiated or is in the process\n   * of negotiating the application m= section.\n   * @returns {boolean}\n   */\n  get isApplicationSectionNegotiated() {\n    if (this._peerConnection.signalingState !== 'closed') {\n      // accessing .localDescription in 'closed' state causes it throw exceptions.\n      return this._peerConnection.localDescription\n        ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0\n        : false;\n    }\n    return true;\n  }\n\n  /**\n   * Whether adaptive simulcast is enabled.\n   * @returns {boolean}\n   */\n  get _isAdaptiveSimulcastEnabled() {\n    const adaptiveSimulcastEntry = this._preferredVideoCodecs.find(cs => 'adaptiveSimulcast' in cs);\n    return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;\n  }\n\n  /**\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   * @returns {boolean} true if encodings were updated.\n   */\n  _maybeUpdateEncodings(track, encodings, trackReplaced = false) {\n    if (track.kind !== 'video' || track.readyState === 'ended') {\n      return false;\n    }\n\n    const browser = util.guessBrowser();\n\n    // Note(mpatwardhan): always configure encodings for safari.\n    // for chrome only when adaptive simulcast enabled.\n    if (browser === 'safari' || (browser === 'chrome' && this._isAdaptiveSimulcastEnabled)) {\n      this._updateEncodings(track, encodings, trackReplaced);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Configures with default encodings depending on track type and resolution.\n   * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy\n   * values. When trackReplaced is set to true, it will clear 'active' for any encodings that\n   * needs to be enabled.\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   */\n  _updateEncodings(track, encodings, trackReplaced) {\n    if (this._isChromeScreenShareTrack(track)) {\n      const screenShareActiveLayerConfig = [\n        { scaleResolutionDownBy: 1 },\n        { scaleResolutionDownBy: 1 }\n      ];\n      encodings.forEach((encoding, i) => {\n        const activeLayerConfig = screenShareActiveLayerConfig[i];\n        if (activeLayerConfig) {\n          encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;\n          if (trackReplaced) {\n            delete encoding.active;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    } else {\n      const { width, height }  = track.getSettings();\n      // NOTE(mpatwardhan): for non-screen share tracks\n      // enable layers depending on track resolutions\n      const pixelsToMaxActiveLayers = [\n        { pixels: 960 * 540, maxActiveLayers: 3 },\n        { pixels: 480 * 270, maxActiveLayers: 2 },\n        { pixels: 0, maxActiveLayers: 1 }\n      ];\n\n      const trackPixels =  width * height;\n      const activeLayersInfo = pixelsToMaxActiveLayers.find(layer => trackPixels >= layer.pixels);\n      const activeLayers = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);\n      encodings.forEach((encoding, i) => {\n        const enabled  = i < activeLayers;\n        if (enabled) {\n          encoding.scaleResolutionDownBy = 1 << (activeLayers - i - 1);\n          if (trackReplaced) {\n            encoding.active = true;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    }\n    this._log.debug('_updateEncodings:', encodings.map(({ active, scaleResolutionDownBy }, i) => `[${i}: ${active}, ${scaleResolutionDownBy || 0}]`).join(', '));\n  }\n\n  /**\n   * Add an ICE candidate to the {@link PeerConnectionV2}.\n   * @private\n   * @param {object} candidate\n   * @returns {Promise<void>}\n   */\n  _addIceCandidate(candidate) {\n    return Promise.resolve().then(() => {\n      candidate = new this._RTCIceCandidate(candidate);\n      return this._peerConnection.addIceCandidate(candidate);\n    }).catch(error => {\n      // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an\n      // empty candidate string to signal end-of-candidates, followed by a null\n      // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since\n      // this does not affect the media connection between Firefox 68+ and Chrome/Safari\n      // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.\n      //\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n      //\n      this._log.warn(`Failed to add RTCIceCandidate ${candidate ? `\"${candidate.candidate}\"` : 'null'}: `\n        + error.message);\n    });\n  }\n\n  /**\n   * Add ICE candidates to the {@link PeerConnectionV2}.\n   * @private\n   * @param {Array<object>} candidates\n   * @returns {Promise<void>}\n   */\n  _addIceCandidates(candidates) {\n    return Promise.all(candidates.map(this._addIceCandidate, this)).then(() => {});\n  }\n\n  /**\n   * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the\n   * given MediaStreamTrack.\n   * @private\n   * @param {MediaStreamTrack} track\n   * @returns {RTCRtpTransceiver}\n   */\n  _addOrUpdateTransceiver(track) {\n    const transceiver = takeRecycledTransceiver(this, track.kind);\n    if (transceiver && transceiver.sender) {\n      const oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;\n      if (oldTrackId) {\n        this._log.warn(`Reusing transceiver: ${transceiver.mid}] ${oldTrackId} => ${track.id}`);\n      }\n      // NOTE(mpatwardhan):remember this transceiver while we replace track.\n      // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent\n      // this one from getting recycled while replaceTrack is pending.\n      this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(() => {\n        transceiver.direction = 'sendrecv';\n      }, () => {\n        // Do nothing.\n      }).finally(() => {\n        this._replaceTrackPromises.delete(transceiver);\n      }));\n      return transceiver;\n    }\n    return this._peerConnection.addTransceiver(track);\n  }\n\n  /**\n   * Check the {@link IceBox}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _checkIceBox(description) {\n    const ufrag = getUfrag(description);\n    if (!ufrag) {\n      return Promise.resolve();\n    }\n    const candidates = this._remoteCandidates.setUfrag(ufrag);\n    return this._addIceCandidates(candidates);\n  }\n\n  /**\n   * Create an answer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<boolean>}\n   */\n  _answer(offer) {\n    return Promise.resolve().then(() => {\n      if (!this._negotiationRole) {\n        this._negotiationRole = 'answerer';\n      }\n      return this._setRemoteDescription(offer);\n    }).catch(() => {\n      throw new MediaClientRemoteDescFailedError();\n    }).then(() => {\n      return this._peerConnection.createAnswer();\n    }).then(answer => {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        answer = new this._RTCSessionDescription({\n          sdp: disableRtx(answer.sdp),\n          type: answer.type\n        });\n      } else {\n        answer = workaroundIssue8329(answer);\n      }\n\n      // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      let updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);\n\n      if (this._shouldApplySimulcast) {\n        let sdpWithoutSimulcast = updatedSdp;\n        updatedSdp = this._setSimulcast(sdpWithoutSimulcast, this._trackIdsToAttributes);\n        // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n        // unset simulcast for sections in local offer where corresponding\n        // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n        updatedSdp = this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);\n      }\n\n      // NOTE(mmalavalli): Work around Chromium bug 1074421.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421\n      updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');\n\n      return this._setLocalDescription({\n        type: answer.type,\n        sdp: updatedSdp\n      });\n    }).then(() => {\n      return this._checkIceBox(offer);\n    }).then(() => {\n      return this._queuedDescription\n        && this._updateDescription(this._queuedDescription);\n    }).then(() => {\n      this._queuedDescription = null;\n      return this._maybeReoffer(this._peerConnection.localDescription);\n    }).catch(error => {\n      const errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();\n      this._publishMediaWarning({\n        message: 'Failed to _answer',\n        code: errorToThrow.code,\n        error\n      });\n      throw errorToThrow;\n    });\n  }\n\n  /**\n   * Close the underlying RTCPeerConnection. Returns false if the\n   * RTCPeerConnection was already closed.\n   * @private\n   * @returns {boolean}\n   */\n  _close() {\n    this._iceConnectionMonitor.stop();\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.close();\n      this.preempt('closed');\n      this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a \"connectionstatechange\" event.\n   * @private\n   * @returns {void}\n   */\n  _handleConnectionStateChange() {\n    this.emit('connectionStateChanged');\n  }\n\n  /**\n   * Handle a \"datachannel\" event.\n   * @private\n   * @param {RTCDataChannelEvent} event\n   * @returns {void}\n   */\n  _handleDataChannelEvent(event) {\n    const dataChannel = event.channel;\n    const dataTrackReceiver = new DataTrackReceiver(dataChannel);\n    this._dataTrackReceivers.add(dataTrackReceiver);\n\n    dataChannel.addEventListener('close', () => {\n      this._dataTrackReceivers.delete(dataTrackReceiver);\n    });\n\n    this.emit('trackAdded', dataTrackReceiver);\n  }\n\n  /**\n   * Handle a glare scenario on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  _handleGlare(offer) {\n    this._log.debug('Glare detected; rolling back');\n    if (this._isRestartingIce) {\n      this._log.debug('An ICE restart was in progress; we\\'ll need to restart ICE again after rolling back');\n      this._isRestartingIce = false;\n      this._shouldRestartIce = true;\n    }\n    return Promise.resolve().then(() => {\n      this._trackIdsToAttributes = new Map(this._appliedTrackIdsToAttributes);\n      return this._setLocalDescription({ type: 'rollback' });\n    }).then(() => {\n      this._needsAnswer = false;\n      return this._answer(offer);\n    }).then(didReoffer => {\n      return didReoffer ? Promise.resolve() : this._offer();\n    });\n  }\n\n  _publishMediaWarning({ message, code, error, sdp }) {\n    this._eventObserver.emit('event', { level: 'warning', name: 'error', group: 'media', payload: {\n      message,\n      code,\n      context: JSON.stringify({ error: error.message, sdp })\n    } });\n  }\n\n  /**\n   * Handle an ICE candidate event.\n   * @private\n   * @param {Event} event\n   * @returns {void}\n   */\n  _handleIceCandidateEvent(event) {\n    if (event.candidate) {\n      this._log.debug('Clearing ICE gathering timeout');\n      this._didGenerateLocalCandidates = true;\n      this._iceGatheringTimeout.clear();\n      this._localCandidates.push(event.candidate);\n    }\n    const peerConnectionState = {\n      ice: {\n        candidates: this._isIceLite ? [] : this._localCandidates.slice(),\n        ufrag: this._localUfrag\n      },\n      id: this.id\n    };\n    if (!event.candidate) {\n      peerConnectionState.ice.complete = true;\n    }\n    if (!(this._isIceLite && event.candidate)) {\n      peerConnectionState.ice.revision = this._localCandidatesRevision++;\n      this.emit('candidates', peerConnectionState);\n    }\n  }\n\n  /**\n   * Handle an ICE connection state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleIceConnectionStateChange() {\n    const { iceConnectionState } = this._peerConnection;\n    const isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);\n    const log = this._log;\n\n    log.debug(`ICE connection state is \"${iceConnectionState}\"`);\n    if (isIceConnectedOrComplete) {\n      this._iceReconnectTimeout.clear();\n      this._iceRestartBackoff.reset();\n    }\n\n    if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {\n      // Case 1: Transition to \"failed\".\n      log.warn('ICE failed');\n      this._initiateIceRestartBackoff();\n    } else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {\n      // Case 2: Transition from \"disconnected\" or \"failed\".\n      log.debug('ICE reconnected');\n    }\n\n    // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.\n    if (iceConnectionState === 'connected') {\n      this._isIceConnectionInactive = false;\n      this._iceConnectionMonitor.start(() => {\n        // note: iceConnection monitor waits for iceConnectionState=disconnected for\n        // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange\n        this._iceConnectionMonitor.stop();\n        if (!this._shouldRestartIce && !this._isRestartingIce) {\n          log.warn('ICE Connection Monitor detected inactivity');\n          this._isIceConnectionInactive = true;\n          this._initiateIceRestartBackoff();\n          this.emit('iceConnectionStateChanged');\n          this.emit('connectionStateChanged');\n        }\n      });\n    } else if (!['disconnected', 'completed'].includes(iceConnectionState)) { // don't stop monitoring for disconnected or completed.\n      this._iceConnectionMonitor.stop();\n      this._isIceConnectionInactive = false;\n    }\n\n    this._lastIceConnectionState = iceConnectionState;\n    this.emit('iceConnectionStateChanged');\n  }\n\n  /**\n   * Handle ICE gathering timeout.\n   * @private\n   * @returns {void}\n   */\n  _handleIceGatheringTimeout() {\n    this._log.warn('ICE failed to gather any local candidates');\n    this._iceGatheringFailed = true;\n    this._initiateIceRestartBackoff();\n    this.emit('iceConnectionStateChanged');\n    this.emit('connectionStateChanged');\n  }\n\n  /**\n   * Handle an ICE gathering state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleIceGatheringStateChange() {\n    const { iceGatheringState } = this._peerConnection;\n    const log = this._log;\n    log.debug(`ICE gathering state is \"${iceGatheringState}\"`);\n\n    // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection\n    // has started gathering candidates for the first time since the initial offer/answer\n    // or an offer/answer with ICE restart.\n    const { delay, isSet } = this._iceGatheringTimeout;\n    if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {\n      log.debug(`Starting ICE gathering timeout: ${delay}`);\n      this._iceGatheringFailed = false;\n      this._iceGatheringTimeout.start();\n    }\n  }\n\n  /**\n   * Handle a signaling state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleSignalingStateChange() {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);\n    }\n  }\n\n  /**\n   * Handle a track event.\n   * @private\n   * @param {RTCTrackEvent} event\n   * @returns {void}\n   */\n  _handleTrackEvent(event) {\n    const sdp = this._peerConnection.remoteDescription\n      ? this._peerConnection.remoteDescription.sdp\n      : null;\n\n    this._trackMatcher = this._trackMatcher || new TrackMatcher();\n    this._trackMatcher.update(sdp);\n\n    const mediaStreamTrack = event.track;\n    const signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;\n    const mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack);\n\n    // NOTE(mmalavalli): \"ended\" is not fired on the remote MediaStreamTrack when\n    // the remote peer removes a track. So, when this MediaStreamTrack is re-used\n    // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),\n    // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack\n    // before adding the new MediaTrackReceiver.\n    this._mediaTrackReceivers.forEach(trackReceiver => {\n      if (trackReceiver.track.id === mediaTrackReceiver.track.id) {\n        this._mediaTrackReceivers.delete(trackReceiver);\n      }\n    });\n\n    this._mediaTrackReceivers.add(mediaTrackReceiver);\n    mediaStreamTrack.addEventListener('ended', () => this._mediaTrackReceivers.delete(mediaTrackReceiver));\n    this.emit('trackAdded', mediaTrackReceiver);\n  }\n\n  /**\n   * Initiate ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  _initiateIceRestart() {\n    if (this._peerConnection.signalingState === 'closed') {\n      return;\n    }\n    const log = this._log;\n    log.warn('Attempting to restart ICE');\n    this._didGenerateLocalCandidates = false;\n    this._isIceRestartBackoffInProgress = false;\n    this._shouldRestartIce = true;\n\n    const { delay, isSet } = this._iceReconnectTimeout;\n    if (!isSet) {\n      log.debug(`Starting ICE reconnect timeout: ${delay}`);\n      this._iceReconnectTimeout.start();\n    }\n    this.offer().catch(ex => {\n      log.error(`offer failed in _initiateIceRestart with: ${ex.message}`);\n    });\n  }\n\n  /**\n   * Schedule an ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  _initiateIceRestartBackoff() {\n    if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {\n      return;\n    }\n    this._log.warn('An ICE restart has been scheduled');\n    this._isIceRestartBackoffInProgress = true;\n    this._iceRestartBackoff.backoff(() => this._initiateIceRestart());\n  }\n\n  /**\n   * Conditionally re-offer.\n   * @private\n   * @param {?RTCSessionDescriptionInit} localDescription\n   * @returns {Promise<boolean>}\n   */\n  _maybeReoffer(localDescription) {\n    let shouldReoffer = this._shouldOffer;\n\n    if (localDescription && localDescription.sdp) {\n      // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or\n      // video send* m= lines than the corresponding RTCRtpSenders with non-null\n      // MediaStreamTracks, it means that the newly added RTCRtpSenders require\n      // renegotiation.\n      const senders = this._peerConnection.getSenders().filter(sender => sender.track);\n      shouldReoffer = ['audio', 'video'].reduce((shouldOffer, kind) => {\n        const mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');\n        const sendersOfKind = senders.filter(isSenderOfKind.bind(null, kind));\n        return shouldOffer || (mediaSections.length < sendersOfKind.length);\n      }, shouldReoffer);\n\n      // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share\n      // but no m= application section.\n      const hasDataTrack = this._dataChannels.size > 0;\n      const hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;\n      const needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;\n      shouldReoffer = shouldReoffer || needsApplicationMediaSection;\n    }\n\n    const promise = shouldReoffer ? this._offer() : Promise.resolve();\n    return promise.then(() => shouldReoffer);\n  }\n\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @returns {Promise<void>}\n   */\n  _offer() {\n    const offerOptions = Object.assign({}, this._offerOptions);\n    this._needsAnswer = true;\n    if (this._shouldRestartIce) {\n      this._shouldRestartIce = false;\n      this._isRestartingIce = true;\n      offerOptions.iceRestart = true;\n    }\n\n    return Promise.all(this._replaceTrackPromises.values()).then(() => {\n      return this._peerConnection.createOffer(offerOptions);\n    }).catch(error => {\n      const errorToThrow = new MediaClientLocalDescFailedError();\n      this._publishMediaWarning({\n        message: 'Failed to create offer',\n        code: errorToThrow.code,\n        error\n      });\n      throw errorToThrow;\n    }).then(offer => {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        offer = new this._RTCSessionDescription({\n          sdp: disableRtx(offer.sdp),\n          type: offer.type\n        });\n      } else {\n        offer = workaroundIssue8329(offer);\n      }\n\n      // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      let sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);\n      sdp = this._peerConnection.remoteDescription\n        ? filterLocalCodecs(sdp, this._peerConnection.remoteDescription.sdp)\n        : sdp;\n\n      let updatedSdp = this._setCodecPreferences(\n        sdp,\n        this._preferredAudioCodecs,\n        this._preferredVideoCodecs);\n\n      this._shouldOffer = false;\n      if (!this._negotiationRole) {\n        this._negotiationRole = 'offerer';\n      }\n\n      if (this._shouldApplySimulcast) {\n        this._localDescriptionWithoutSimulcast = {\n          type: 'offer',\n          sdp: updatedSdp\n        };\n        updatedSdp = this._setSimulcast(updatedSdp, this._trackIdsToAttributes);\n      }\n      return this._setLocalDescription({\n        type: 'offer',\n        sdp: updatedSdp\n      });\n    });\n  }\n\n  /**\n   * Get the MediaTrackSender ID of the given MediaStreamTrack ID.\n   * Since a MediaTrackSender's underlying MediaStreamTrack can be\n   * replaced, the corresponding IDs can mismatch.\n   * @private\n   * @param {Track.ID} id\n   * @returns {Track.ID}\n   */\n  _getMediaTrackSenderId(trackId) {\n    const mediaTrackSender = Array.from(this._rtpSenders.keys()).find(({ track: { id } }) => id === trackId);\n    return mediaTrackSender ? mediaTrackSender.id : trackId;\n  }\n\n  /**\n   * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.\n   * @private\n   * @param {RTCSessionDescription} description\n   * @return {RTCSessionDescription}\n   */\n  _addOrRewriteLocalTrackIds(description) {\n    const transceivers = this._peerConnection.getTransceivers();\n    const activeTransceivers = transceivers.filter(({ sender, stopped }) => !stopped && sender && sender.track);\n\n    // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in\n    // SDPs, and even if they are, there is no guarantee that they will be the same as the\n    // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs\n    // to the assigned m= sections here.\n    const assignedTransceivers = activeTransceivers.filter(({ mid }) => mid);\n    const midsToTrackIds = new Map(assignedTransceivers.map(({ mid, sender }) => [mid, this._getMediaTrackSenderId(sender.track.id)]));\n    const sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds);\n\n    // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.\n    // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.\n    const unassignedTransceivers = activeTransceivers.filter(({ mid }) => !mid);\n    const newTrackIdsByKind = new Map(['audio', 'video'].map(kind => [\n      kind,\n      unassignedTransceivers.filter(({ sender }) => sender.track.kind === kind).map(({ sender }) => this._getMediaTrackSenderId(sender.track.id))\n    ]));\n    const sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);\n\n    return new this._RTCSessionDescription({\n      sdp: sdp2,\n      type: description.type\n    });\n  }\n\n  /**\n   * Rollback and apply the given offer.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  _rollbackAndApplyOffer(offer) {\n    return this._setLocalDescription({ type: 'rollback' }).then(() => this._setLocalDescription(offer));\n  }\n\n  /**\n   * Set a local description on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescription|RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _setLocalDescription(description) {\n    if (description.type !== 'rollback' && this._shouldApplyDtx) {\n      description = new this._RTCSessionDescription({\n        sdp: enableDtxForOpus(description.sdp),\n        type: description.type\n      });\n    }\n    return this._peerConnection.setLocalDescription(description).catch(error => {\n      this._log.warn(`Calling setLocalDescription with an RTCSessionDescription of type \"${description.type}\" failed with the error \"${error.message}\".`, error);\n\n      const errorToThrow = new MediaClientLocalDescFailedError();\n      const publishWarning = {\n        message: `Calling setLocalDescription with an RTCSessionDescription of type \"${description.type}\" failed`,\n        code: errorToThrow.code,\n        error\n      };\n\n      if (description.sdp) {\n        this._log.warn(`The SDP was ${description.sdp}`);\n        publishWarning.sdp = description.sdp;\n      }\n      this._publishMediaWarning(publishWarning);\n      throw errorToThrow;\n    }).then(() => {\n      if (description.type !== 'rollback') {\n        this._localDescription = this._addOrRewriteLocalTrackIds(description);\n\n        // NOTE(mmalavalli): In order for this feature to be backward compatible with older\n        // SDK versions which to not support opus DTX, we append \"usedtx=1\" to the local SDP\n        // only while applying it. We will not send it over the wire to prevent inadvertent\n        // enabling of opus DTX in older SDKs. Newer SDKs will append \"usedtx=1\" by themselves\n        // if the developer has requested opus DTX to be enabled. (JSDK-3063)\n        if (this._shouldApplyDtx) {\n          this._localDescription = new this._RTCSessionDescription({\n            sdp: enableDtxForOpus(this._localDescription.sdp, []),\n            type: this._localDescription.type\n          });\n        }\n\n        this._localCandidates = [];\n        if (description.type === 'offer') {\n          this._descriptionRevision++;\n        } else if (description.type === 'answer') {\n          this._lastStableDescriptionRevision = this._descriptionRevision;\n          negotiationCompleted(this);\n        }\n        this._localUfrag = getUfrag(description);\n        this.emit('description', this.getState());\n      }\n    });\n  }\n\n  /**\n   * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _setRemoteDescription(description) {\n    if (description.sdp) {\n      description.sdp = this._setCodecPreferences(\n        description.sdp,\n        this._preferredAudioCodecs,\n        this._preferredVideoCodecs);\n\n      if (this._shouldApplyDtx) {\n        description.sdp = enableDtxForOpus(description.sdp);\n      } else {\n        // NOTE(mmalavalli): Remove \"usedtx=1\" from opus's fmtp line if present\n        // since DTX is disabled.\n        description.sdp = enableDtxForOpus(description.sdp, []);\n      }\n\n      if (isFirefox) {\n        // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By\n        // mapping MediaStream IDs in the SDP to \"-\", we ensure the \"track\" event\n        // doesn't include any new MediaStreams in Firefox. Its `streams` member\n        // will always be the empty Array.\n        description.sdp = filterOutMediaStreamIds(description.sdp);\n      }\n      if (!this._peerConnection.remoteDescription) {\n        this._isIceLite = /a=ice-lite/.test(description.sdp);\n      }\n    }\n    description = new this._RTCSessionDescription(description);\n    // eslint-disable-next-line consistent-return\n    return Promise.resolve().then(() => {\n      // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n      // unset simulcast for sections in local offer where corresponding\n      // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n      if (description.type === 'answer' && this._localDescriptionWithoutSimulcast) {\n        // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server\n        // revert simulcast even for vp8.\n        const adaptiveSimulcastEntry = this._preferredVideoCodecs.find(cs => 'adaptiveSimulcast' in cs);\n        const revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;\n        const sdpWithoutSimulcastForNonVP8MediaSections = this._revertSimulcast(\n          this._localDescription.sdp,\n          this._localDescriptionWithoutSimulcast.sdp,\n          description.sdp, revertForAll);\n        this._localDescriptionWithoutSimulcast = null;\n        if (sdpWithoutSimulcastForNonVP8MediaSections !== this._localDescription.sdp) {\n          return this._rollbackAndApplyOffer({\n            type: this._localDescription.type,\n            sdp: sdpWithoutSimulcastForNonVP8MediaSections\n          });\n        }\n      }\n    }).then(() => this._peerConnection.setRemoteDescription(description)).then(() => {\n      if (description.type === 'answer') {\n        if (this._isRestartingIce) {\n          this._log.debug('An ICE restart was in-progress and is now completed');\n          this._isRestartingIce = false;\n        }\n        negotiationCompleted(this);\n      }\n    }, error => {\n      this._log.warn(`Calling setRemoteDescription with an RTCSessionDescription of type \"${description.type}\" failed with the error \"${error.message}\".`, error);\n      if (description.sdp) {\n        this._log.warn(`The SDP was ${description.sdp}`);\n      }\n      throw error;\n    });\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}'s description.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _updateDescription(description) {\n    switch (description.type) {\n      case 'answer':\n      case 'pranswer':\n        if (description.revision !== this._descriptionRevision\n          || this._peerConnection.signalingState !== 'have-local-offer') {\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        break;\n      case 'close':\n        return this._close();\n      case 'create-offer':\n        if (description.revision <= this._lastStableDescriptionRevision) {\n          return Promise.resolve();\n        } else if (this._needsAnswer) {\n          this._queuedDescription = description;\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        return this._offer();\n      case 'offer':\n        if (description.revision <= this._lastStableDescriptionRevision\n          || this._peerConnection.signalingState === 'closed') {\n          return Promise.resolve();\n        }\n        if (this._peerConnection.signalingState === 'have-local-offer') {\n          // NOTE(mpatwardhan): For a peer connection\n          // 1) createOffer always generate SDP with `setup:actpass`\n          // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive\n          // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active\n          // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)\n          // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936\n          // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.\n          // we do not want that. lets wait for \"initial negotiation\" before attempting glare handling.\n          if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {\n            this._queuedDescription = description;\n            return Promise.resolve();\n          }\n          this._descriptionRevision = description.revision;\n          return this._handleGlare(description);\n        }\n        this._descriptionRevision = description.revision;\n        return this._answer(description).then(() => {});\n      default:\n        // Do nothing.\n    }\n\n    // Handle answer or pranswer.\n    const revision = description.revision;\n    return Promise.resolve().then(() => {\n      return this._setRemoteDescription(description);\n    }).catch(error => {\n      const errorToThrow = new MediaClientRemoteDescFailedError();\n      this._publishMediaWarning({\n        message: `Calling setRemoteDescription with an RTCSessionDescription of type \"${description.type}\" failed`,\n        code: errorToThrow.code,\n        error,\n        sdp: description.sdp\n      });\n      throw errorToThrow;\n    }).then(() => {\n      this._lastStableDescriptionRevision = revision;\n      this._needsAnswer = false;\n      return this._checkIceBox(description);\n    }).then(() => {\n      return this._queuedDescription\n        && this._updateDescription(this._queuedDescription);\n    }).then(() => {\n      this._queuedDescription = null;\n      return this._maybeReoffer(this._peerConnection.localDescription).then(() => {});\n    });\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}'s ICE candidates.\n   * @private\n   * @param {object} iceState\n   * @returns {Promise<void>}\n   */\n  _updateIce(iceState) {\n    const candidates = this._remoteCandidates.update(iceState);\n    return this._addIceCandidates(candidates);\n  }\n\n  /**\n   * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  addDataTrackSender(dataTrackSender) {\n    if (this._dataChannels.has(dataTrackSender)) {\n      return;\n    }\n    try {\n      const dataChannelDict = {\n        ordered: dataTrackSender.ordered\n      };\n      if (dataTrackSender.maxPacketLifeTime !== null) {\n        dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;\n      }\n      if (dataTrackSender.maxRetransmits !== null) {\n        dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;\n      }\n      const dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);\n      dataTrackSender.addDataChannel(dataChannel);\n      this._dataChannels.set(dataTrackSender, dataChannel);\n    } catch (error) {\n      this._log.warn(`Error creating an RTCDataChannel for DataTrack \"${dataTrackSender.id}\": ${error.message}`);\n    }\n  }\n\n  _handleQueuedPublisherHints() {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._mediaTrackSenderToPublisherHints.forEach(({ deferred, encodings }, mediaTrackSender) => {\n        this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n        this._setPublisherHint(mediaTrackSender, encodings)\n          .then(result => deferred.resolve(result))\n          .catch(error => deferred.reject(error));\n      });\n    }\n  }\n\n  /**\n   * updates encodings for simulcast layers of given sender.\n   * @param {RTCRtpSender} sender\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>} string indicating result of the operation. can be one of\n   *  \"OK\", \"INVALID_HINT\", \"COULD_NOT_APPLY_HINT\", \"UNKNOWN_TRACK\"\n   */\n  _setPublisherHint(mediaTrackSender, encodings) {\n    if (isFirefox) {\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      // skip any stale hint associated with the mediaTrackSender.\n      const queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('REQUEST_SKIPPED');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n\n    const sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');\n      return Promise.resolve('UNKNOWN_TRACK');\n    }\n\n    if (this._peerConnection.signalingState === 'closed') {\n      this._log.warn('Could not apply publisher hint because signalingState was \"closed\"');\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._peerConnection.signalingState !== 'stable') {\n      // enqueue this hint to be applied when pc becomes stable.\n      this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);\n      const deferred = defer();\n      this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, { deferred, encodings });\n      return deferred.promise;\n    }\n\n    const parameters = sender.getParameters();\n    if (encodings !== null) {\n      encodings.forEach(({ enabled, layer_index: layerIndex }) => {\n        if (parameters.encodings.length > layerIndex) {\n          this._log.debug(`layer:${layerIndex}, active:${parameters.encodings[layerIndex].active} => ${enabled}`);\n          parameters.encodings[layerIndex].active = enabled;\n        } else {\n          this._log.warn(`invalid layer:${layerIndex}, active:${enabled}`);\n        }\n      });\n    }\n\n    // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings\n    // to disable any encoding that shouldn't have been enabled by publisher_hints.\n    // When encodings===null (that is we are asked to reset encodings for replaceTrack)\n    // along with disabling encodings, clear active flag for encodings that should not be disabled\n    this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null /* trackReplaced */);\n\n    return sender.setParameters(parameters).then(() => 'OK').catch(error => {\n      this._log.error('Failed to apply publisher hints:', error);\n      return 'COULD_NOT_APPLY_HINT';\n    });\n  }\n\n  /**\n   * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  addMediaTrackSender(mediaTrackSender) {\n    if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {\n      return;\n    }\n    const transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);\n    const { sender } = transceiver;\n    mediaTrackSender.addSender(sender, encodings => this._setPublisherHint(mediaTrackSender, encodings));\n    this._rtpNewSenders.add(sender);\n    this._rtpSenders.set(mediaTrackSender, sender);\n  }\n\n  /**\n   * Close the {@link PeerConnectionV2}.\n   * @returns {void}\n   */\n  close() {\n    if (this._close()) {\n      this._descriptionRevision++;\n      this._localDescription = { type: 'close' };\n      this.emit('description', this.getState());\n    }\n  }\n\n  /**\n   * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the\n   * {@link PeerConnectionV2}.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  getTrackReceivers() {\n    return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));\n  }\n\n  /**\n   * Get the {@link PeerConnectionV2}'s state (specifically, its description).\n   * @returns {?object}\n   */\n  getState() {\n    if (!this._localDescription) {\n      return null;\n    }\n\n    // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an\n    // answer, and this method is called for sending a \"sync\" message while the next remote offer is being processed,\n    // we need to send the most recent stable description revision instead of the current description revision,\n    // which is supposed to be for the next local answer.\n    const localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;\n    const localDescription = {\n      type: this._localDescription.type,\n      revision: localDescriptionRevision\n    };\n    if (this._localDescription.sdp) {\n      localDescription.sdp = this._localDescription.sdp;\n    }\n    return {\n      description: localDescription,\n      id: this.id\n    };\n  }\n\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @returns {Promise<void>}\n   */\n  offer() {\n    if (this._needsAnswer || this._isRestartingIce) {\n      this._shouldOffer = true;\n      return Promise.resolve();\n    }\n\n    return this.bracket('offering', key => {\n      this.transition('updating', key);\n      const promise = this._needsAnswer || this._isRestartingIce ? Promise.resolve() : this._offer();\n      return promise.then(() => {\n        this.tryTransition('open', key);\n      }, error => {\n        this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  }\n\n  /**\n   * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  removeDataTrackSender(dataTrackSender) {\n    const dataChannel = this._dataChannels.get(dataTrackSender);\n    if (dataChannel) {\n      dataTrackSender.removeDataChannel(dataChannel);\n      this._dataChannels.delete(dataTrackSender);\n      dataChannel.close();\n    }\n  }\n\n  /**\n   * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  removeMediaTrackSender(mediaTrackSender) {\n    const sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      return;\n    }\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.removeTrack(sender);\n    }\n    mediaTrackSender.removeSender(sender);\n    // clean up any pending publisher hints associated with this mediaTrackSender.\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      const queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('UNKNOWN_TRACK');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n    this._rtpNewSenders.delete(sender);\n    this._rtpSenders.delete(mediaTrackSender);\n  }\n\n  /**\n   * Set the RTCConfiguration on the underlying RTCPeerConnection.\n   * @param {RTCConfiguration} configuration\n   * @returns {void}\n   */\n  setConfiguration(configuration) {\n    if (typeof this._peerConnection.setConfiguration === 'function') {\n      this._peerConnection.setConfiguration(getConfiguration(configuration));\n    }\n  }\n\n  /**\n   * Set the ICE reconnect timeout period.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  setIceReconnectTimeout(period) {\n    this._iceReconnectTimeout.setDelay(period);\n    this._log.debug('Updated ICE reconnection timeout period:',\n      this._iceReconnectTimeout.delay);\n    return this;\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}.\n   * @param {object} peerConnectionState\n   * @returns {Promise<void>}\n   */\n  update(peerConnectionState) {\n    return this.bracket('updating', key => {\n      if (this.state === 'closed') {\n        return Promise.resolve();\n      }\n\n      this.transition('updating', key);\n\n      const updates = [];\n\n      if (peerConnectionState.ice) {\n        updates.push(this._updateIce(peerConnectionState.ice));\n      }\n\n      if (peerConnectionState.description) {\n        updates.push(this._updateDescription(peerConnectionState.description));\n      }\n\n      return Promise.all(updates).then(() => {\n        this.tryTransition('open', key);\n      }, error => {\n        this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  }\n\n  /**\n   * Get the {@link PeerConnectionV2}'s media statistics.\n   * @returns {Promise<StandardizedStatsResponse>}\n   */\n  getStats() {\n    return getStatistics(this._peerConnection).then(response => rewriteTrackIds(this, response));\n  }\n}\n\nfunction rewriteLocalTrackId(pcv2, stats) {\n  const trackId = pcv2._getMediaTrackSenderId(stats.trackId);\n  return Object.assign(stats, { trackId });\n}\n\nfunction rewriteTrackId(pcv2, stats) {\n  const receiver = [...pcv2._mediaTrackReceivers]\n    .find(receiver => receiver.track.id === stats.trackId);\n  const trackId = receiver ? receiver.id : null;\n  return Object.assign(stats, { trackId });\n}\n\nfunction rewriteTrackIds(pcv2, response) {\n  return Object.assign(response, {\n    remoteAudioTrackStats: response.remoteAudioTrackStats.map(stats => rewriteTrackId(pcv2, stats)),\n    remoteVideoTrackStats: response.remoteVideoTrackStats.map(stats => rewriteTrackId(pcv2, stats)),\n    localAudioTrackStats: response.localAudioTrackStats.map(stats => rewriteLocalTrackId(pcv2, stats)),\n    localVideoTrackStats: response.localVideoTrackStats.map(stats => rewriteLocalTrackId(pcv2, stats)),\n  });\n}\n\n/**\n * @event PeerConnectionV2#candidates\n * @param {object} candidates\n */\n\n/**\n * @event PeerConnectionV2#connectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#description\n * @param {object} description\n */\n\n/**\n * @event PeerConnectionV2#iceConnectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#trackAdded\n * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver\n */\n\nfunction getUfrag(description) {\n  if (description.sdp) {\n    const match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);\n    if (match) {\n      return match[1];\n    }\n  }\n  return null;\n}\n\nfunction getConfiguration(configuration) {\n  return Object.assign({\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n  }, configuration);\n}\n\n/**\n * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended\n * MediaStreamTrack of a given kind.\n * @private\n * @param {string} kind\n * @param {RTCRtpSender} sender\n * @return {boolean}\n */\nfunction isSenderOfKind(kind, sender) {\n  const track = sender.track;\n  return track && track.kind === kind && track.readyState !== 'ended';\n}\n\n/**\n * Preferred codecs.\n * @typedef {object} PreferredCodecs\n * @property {Array<AudioCodec>} audio\n * @property {Array<VideoCodec>} video\n */\n\nfunction filterOutMediaStreamIds(sdp) {\n  return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');\n}\n\n/**\n * Whether an RTCRtpTransceiver can be recycled.\n * @param {RTCRtpTransceiver} transceiver\n * @returns {boolean}\n */\nfunction shouldRecycleTransceiver(transceiver, pcv2) {\n  return !transceiver.stopped\n    && !pcv2._replaceTrackPromises.has(transceiver)\n    && ['inactive', 'recvonly'].includes(transceiver.direction);\n}\n\n/**\n * Take a recycled RTCRtpTransceiver if available.\n * @param {PeerConnectionV2} pcv2\n * @param {Track.Kind} kind\n * @returns {?RTCRtpTransceiver}\n */\nfunction takeRecycledTransceiver(pcv2, kind) {\n  const preferredCodecs = {\n    audio: pcv2._preferredAudioCodecs.map(({ codec }) => codec.toLowerCase()),\n    video: pcv2._preferredVideoCodecs.map(({ codec }) => codec.toLowerCase())\n  }[kind];\n\n  const recycledTransceivers = pcv2._recycledTransceivers[kind];\n  const localCodec = preferredCodecs.find(codec => pcv2._localCodecs.has(codec));\n  if (!localCodec) {\n    return recycledTransceivers.shift();\n  }\n\n  const transceiver = recycledTransceivers.find(transceiver => {\n    const remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);\n    return remoteCodecMap && remoteCodecMap.has(localCodec);\n  });\n\n  if (transceiver) {\n    recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);\n  }\n  return transceiver;\n}\n\n/**\n * Update the set of locally supported {@link Codec}s.\n * @param pcv2\n * @returns {void}\n */\nfunction updateLocalCodecs(pcv2) {\n  const description = pcv2._peerConnection.localDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(section => {\n    const codecMap = createCodecMapForMediaSection(section);\n    codecMap.forEach((pts, codec) => pcv2._localCodecs.add(codec));\n  });\n}\n\n/**\n * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateRemoteCodecMaps(pcv2) {\n  const description = pcv2._peerConnection.remoteDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(section => {\n    const matched = section.match(/^a=mid:(.+)$/m);\n    if (!matched || !matched[1]) {\n      return;\n    }\n    const mid = matched[1];\n    const codecMap = createCodecMapForMediaSection(section);\n    pcv2._remoteCodecMaps.set(mid, codecMap);\n  });\n}\n\n/**\n * Update the list of recycled RTCRtpTransceivers.\n * @param {PeerConnectionV2} pcv2\n */\nfunction updateRecycledTransceivers(pcv2) {\n  pcv2._recycledTransceivers.audio = [];\n  pcv2._recycledTransceivers.video = [];\n  pcv2._peerConnection.getTransceivers().forEach(transceiver => {\n    if (shouldRecycleTransceiver(transceiver, pcv2)) {\n      const track = transceiver.receiver.track;\n      pcv2._recycledTransceivers[track.kind].push(transceiver);\n    }\n  });\n}\n\n/**\n * Perform certain updates after an SDP negotiation is completed.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction negotiationCompleted(pcv2) {\n  updateRecycledTransceivers(pcv2);\n  updateLocalCodecs(pcv2);\n  updateRemoteCodecMaps(pcv2);\n  updateEncodingParameters(pcv2).then(() => {\n    // if there any any publisher hints queued, apply them now.\n    pcv2._handleQueuedPublisherHints();\n  });\n}\n\n/**\n * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateEncodingParameters(pcv2) {\n  const { maxAudioBitrate, maxVideoBitrate } = pcv2._encodingParameters;\n\n  const maxBitrates = new Map([\n    ['audio', maxAudioBitrate],\n    ['video', maxVideoBitrate]\n  ]);\n\n  const promises = [];\n  pcv2._peerConnection.getSenders().filter(sender => sender.track).forEach(sender => {\n    const maxBitrate = maxBitrates.get(sender.track.kind);\n    const params = sender.getParameters();\n\n    if (maxBitrate === null || maxBitrate === 0) {\n      removeMaxBitrate(params);\n    } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n      // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,\n      // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome\n      pcv2._log.warn(`Not setting maxBitrate for ${sender.track.kind} Track ${sender.track.id} because it appears to be screen share track: ${sender.track.label}`);\n    } else {\n      setMaxBitrate(params, maxBitrate);\n    }\n\n    if (!isFirefox && pcv2._enableDscp && params.encodings.length > 0) {\n      // NOTE(mmalavalli): \"networkPriority\" is a per-sender property and not\n      // a per-encoding-layer property. So, we set the value only on the first\n      // encoding layer. Any attempt to set the value on subsequent encoding\n      // layers (in the case of simulcast) will result in the Promise returned\n      // by RTCRtpSender.setParameters() being rejected.\n      params.encodings[0].networkPriority = 'high';\n    }\n\n    // when a sender is reused, delete any active encodings set by server.\n    const trackReplaced = pcv2._rtpNewSenders.has(sender);\n    pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);\n    pcv2._rtpNewSenders.delete(sender);\n\n    const promise = sender.setParameters(params).catch(error => {\n      pcv2._log.warn(`Error while setting encodings parameters for ${sender.track.kind} Track ${sender.track.id}: ${error.message || error.name}`);\n    });\n    promises.push(promise);\n  });\n  return Promise.all(promises);\n}\n\n/**\n * Remove maxBitrate from the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @returns {void}\n */\nfunction removeMaxBitrate(params) {\n  if (Array.isArray(params.encodings)) {\n    params.encodings.forEach(encoding => delete encoding.maxBitrate);\n  }\n}\n\n/**\n * Set the given maxBitrate in the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @param {number} maxBitrate\n * @returns {void}\n */\nfunction setMaxBitrate(params, maxBitrate) {\n  if (isFirefox) {\n    params.encodings = [{ maxBitrate }];\n  } else {\n    params.encodings.forEach(encoding => {\n      encoding.maxBitrate = maxBitrate;\n    });\n  }\n}\nmodule.exports = PeerConnectionV2;\n"]},"metadata":{},"sourceType":"script"}