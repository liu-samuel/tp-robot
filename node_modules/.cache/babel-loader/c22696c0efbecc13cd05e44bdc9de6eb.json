{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar _a = require('../../webrtc/util'),\n    guessBrowser = _a.guessBrowser,\n    isIOSChrome = _a.isIOSChrome;\n\nvar MediaStream = require('../../webrtc').MediaStream;\n\nvar _b = require('../../util'),\n    waitForEvent = _b.waitForEvent,\n    waitForSometime = _b.waitForSometime;\n\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\n\nvar Track = require('./');\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\n\n\nvar MediaTrack =\n/** @class */\nfunction (_super) {\n  __extends(MediaTrack, _super);\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n\n\n  function MediaTrack(mediaTrackTransceiver, options) {\n    var _this = this;\n\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: (guessBrowser() === 'safari' || isIOSChrome()) && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string'\n    }, options);\n    _this = _super.call(this, mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options) || this;\n    var isStarted = false;\n    options = Object.assign({\n      MediaStream: MediaStream\n    }, options);\n    /* istanbul ignore next */\n\n    Object.defineProperties(_this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get: function get() {\n          return isStarted;\n        },\n        set: function set(_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780 || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      isStarted: {\n        enumerable: true,\n        get: function get() {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get: function get() {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    _this._initialize();\n\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._start = function () {\n    this._log.debug('Started');\n\n    this._isStarted = true;\n\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    } // eslint-disable-next-line no-use-before-define\n\n\n    this.emit('started', this);\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._initialize = function () {\n    var self = this;\n\n    this._log.debug('Initializing');\n\n    this._dummyEl = this._createElement();\n    this.mediaStreamTrack.addEventListener('ended', function onended() {\n      self._end();\n\n      self.mediaStreamTrack.removeEventListener('ended', onended);\n    });\n\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl); // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n\n      this._attachments.delete(this._dummyEl);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._end = function () {\n    this._log.debug('Ended');\n\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n\n      this._dummyEl.srcObject = null;\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  };\n\n  MediaTrack.prototype.attach = function (el) {\n    var _this = this;\n\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n\n    this._log.debug('Attempting to attach to element:', el);\n\n    el = this._attach(el);\n\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded ? function () {\n        return playIfPausedAndNotBackgrounded(el, _this._log);\n      } : null;\n\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n\n    return el;\n  };\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n\n\n  MediaTrack.prototype._attach = function (el, mediaStreamTrack) {\n    if (mediaStreamTrack === void 0) {\n      mediaStreamTrack = this.processedTrack || this.mediaStreamTrack;\n    }\n\n    var mediaStream = el.srcObject;\n\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n\n    var getTracks = mediaStreamTrack.kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';\n    mediaStream[getTracks]().forEach(function (track) {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack); // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    //\n\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._selectElement = function (selector) {\n    var el = document.querySelector(selector);\n\n    if (!el) {\n      throw new Error(\"Selector matched no element: \" + selector);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._updateElementsMediaStreamTrack = function () {\n    var _this = this;\n\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n\n    this._getAllAttachedElements().forEach(function (el) {\n      return _this._attach(el);\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._createElement = function () {\n    return typeof document !== 'undefined' ? document.createElement(this.kind) : null;\n  };\n\n  MediaTrack.prototype.detach = function (el) {\n    var els;\n\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n\n    this._log.debug('Attempting to detach from elements:', els);\n\n    this._detachElements(els);\n\n    return el ? els[0] : els;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._detachElements = function (elements) {\n    return elements.map(this._detachElement.bind(this));\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._detachElement = function (el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n\n    var mediaStream = el.srcObject;\n\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n\n    this._attachments.delete(el);\n\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      var shim = this._elShims.get(el);\n\n      shim.unShim();\n\n      this._elShims.delete(el);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._getAllAttachedElements = function () {\n    var els = [];\n\n    this._attachments.forEach(function (el) {\n      els.push(el);\n    });\n\n    return els;\n  };\n\n  return MediaTrack;\n}(Track);\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\n\n\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  var tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el); // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n\n  Promise.race([waitForEvent(document, 'visibilitychange'), waitForSometime(1000)]).then(function () {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(function () {\n        log.info(\"Playing unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n        return el.play();\n      }).then(function () {\n        log.info(\"Successfully played unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n      }).catch(function (error) {\n        log.warn(\"Error while playing unintentionally paused <\" + tag + \"> element:\", {\n          error: error,\n          el: el\n        });\n      });\n    }\n  });\n}\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\n\n\nfunction shimMediaElement(el, onUnintentionallyPaused) {\n  if (onUnintentionallyPaused === void 0) {\n    onUnintentionallyPaused = null;\n  }\n\n  var origPause = el.pause;\n  var origPlay = el.play;\n  var _pausedIntentionally = false;\n\n  el.pause = function () {\n    _pausedIntentionally = true;\n    return origPause.call(el);\n  };\n\n  el.play = function () {\n    _pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n\n  var onPause = onUnintentionallyPaused ? function () {\n    if (!_pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n\n  return {\n    pausedIntentionally: function pausedIntentionally() {\n      return _pausedIntentionally;\n    },\n    unShim: function unShim() {\n      el.pause = origPause;\n      el.play = origPlay;\n\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\n\nmodule.exports = MediaTrack;","map":{"version":3,"mappings":"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","names":["require","guessBrowser","isIOSChrome","MediaStream","waitForEvent","waitForSometime","localMediaRestartDeferreds","Track","__extends","mediaTrackTransceiver","options","Object","assign","playPausedElementsIfNotBackgrounded","document","addEventListener","visibilityState","_this","id","kind","isStarted","defineProperties","_attachments","value","Set","_dummyEl","writable","_elShims","WeakMap","_isStarted","get","set","_playPausedElementsIfNotBackgrounded","_shouldShimAttachedElements","workaroundWebKitBug212780","_unprocessedTrack","_MediaStream","enumerable","mediaStreamTrack","track","processedTrack","_initialize","MediaTrack","_log","debug","oncanplay","emit","self","_createElement","onended","_end","removeEventListener","muted","_start","bind","_attach","delete","remove","srcObject","el","_selectElement","has","onUnintentionallyPaused","shimMediaElement","mediaStream","getTracks","forEach","removeTrack","addTrack","autoplay","playsInline","add","selector","querySelector","Error","_getAllAttachedElements","createElement","els","_detachElements","elements","map","_detachElement","shim","unShim","push","playIfPausedAndNotBackgrounded","log","tag","tagName","toLowerCase","warn","Promise","race","then","whenResolved","info","play","catch","error","origPause","pause","origPlay","pausedIntentionally","call","onPause","module","exports"],"sources":["/home/samliu/repos/ieee/twilio-video-starter-kit/node_modules/twilio-video/lib/media/track/mediatrack.js"],"sourcesContent":["'use strict';\n\nconst { guessBrowser, isIOSChrome } = require('../../webrtc/util');\nconst { MediaStream } = require('../../webrtc');\n\nconst { waitForEvent, waitForSometime } = require('../../util');\nconst localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nconst Track = require('./');\n\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\nclass MediaTrack extends Track {\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  constructor(mediaTrackTransceiver, options) {\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: (guessBrowser() === 'safari' || isIOSChrome())\n        && typeof document === 'object'\n        && typeof document.addEventListener === 'function'\n        && typeof document.visibilityState === 'string'\n    }, options);\n\n    super(mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options);\n    let isStarted = false;\n\n    options = Object.assign({\n      MediaStream\n    }, options);\n\n    /* istanbul ignore next */\n    Object.defineProperties(this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get() {\n          return isStarted;\n        },\n        set(_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780\n          || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      isStarted: {\n        enumerable: true,\n        get() {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get() {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    this._initialize();\n  }\n\n  /**\n   * @private\n   */\n  _start() {\n    this._log.debug('Started');\n    this._isStarted = true;\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    }\n    // eslint-disable-next-line no-use-before-define\n    this.emit('started', this);\n  }\n\n  /**\n   * @private\n   */\n  _initialize() {\n    const self = this;\n\n    this._log.debug('Initializing');\n    this._dummyEl = this._createElement();\n\n    this.mediaStreamTrack.addEventListener('ended', function onended() {\n      self._end();\n      self.mediaStreamTrack.removeEventListener('ended', onended);\n    });\n\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);\n\n      // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n\n      this._attachments.delete(this._dummyEl);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _end() {\n    this._log.debug('Ended');\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n      this._dummyEl.srcObject = null;\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  }\n\n  attach(el) {\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n    this._log.debug('Attempting to attach to element:', el);\n    el = this._attach(el);\n\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      const onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded\n        ? () => playIfPausedAndNotBackgrounded(el, this._log)\n        : null;\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n    return el;\n  }\n\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n  _attach(el, mediaStreamTrack = this.processedTrack || this.mediaStreamTrack) {\n    let mediaStream = el.srcObject;\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n\n    const getTracks = mediaStreamTrack.kind === 'audio'\n      ? 'getAudioTracks'\n      : 'getVideoTracks';\n\n    mediaStream[getTracks]().forEach(track => {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack);\n\n    // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    //\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _selectElement(selector) {\n    const el = document.querySelector(selector);\n\n    if (!el) {\n      throw new Error(`Selector matched no element: ${selector}`);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _updateElementsMediaStreamTrack() {\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n    this._getAllAttachedElements().forEach(el => this._attach(el));\n  }\n\n  /**\n   * @private\n   */\n  _createElement() {\n    return typeof document !== 'undefined'\n      ? document.createElement(this.kind)\n      : null;\n  }\n\n  detach(el) {\n    let els;\n\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n\n    this._log.debug('Attempting to detach from elements:', els);\n    this._detachElements(els);\n    return el ? els[0] : els;\n  }\n\n  /**\n   * @private\n   */\n  _detachElements(elements) {\n    return elements.map(this._detachElement.bind(this));\n  }\n\n  /**\n   * @private\n   */\n  _detachElement(el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n    const mediaStream = el.srcObject;\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n    this._attachments.delete(el);\n\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      const shim = this._elShims.get(el);\n      shim.unShim();\n      this._elShims.delete(el);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _getAllAttachedElements() {\n    const els = [];\n\n    this._attachments.forEach(el => {\n      els.push(el);\n    });\n\n    return els;\n  }\n}\n\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  const tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el);\n\n  // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n  Promise.race([\n    waitForEvent(document, 'visibilitychange'),\n    waitForSometime(1000)\n  ]).then(() => {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(() => {\n        log.info(`Playing unintentionally paused <${tag}> element`);\n        log.debug('Element:', el);\n        return el.play();\n      }).then(() => {\n        log.info(`Successfully played unintentionally paused <${tag}> element`);\n        log.debug('Element:', el);\n      }).catch(error => {\n        log.warn(`Error while playing unintentionally paused <${tag}> element:`, { error, el });\n      });\n    }\n  });\n}\n\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\nfunction shimMediaElement(el, onUnintentionallyPaused = null) {\n  const origPause = el.pause;\n  const origPlay = el.play;\n\n  let pausedIntentionally = false;\n\n  el.pause = () => {\n    pausedIntentionally = true;\n    return origPause.call(el);\n  };\n\n  el.play = () => {\n    pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n\n  const onPause = onUnintentionallyPaused ? () => {\n    if (!pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n\n  return {\n    pausedIntentionally() {\n      return pausedIntentionally;\n    },\n    unShim() {\n      el.pause = origPause;\n      el.play = origPlay;\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\n\nmodule.exports = MediaTrack;\n"]},"metadata":{},"sourceType":"script"}