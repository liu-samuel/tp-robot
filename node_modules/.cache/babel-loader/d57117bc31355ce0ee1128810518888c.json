{"ast":null,"code":"/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\n\nvar inherits = require('../../vendor/inherits');\n\nvar Latch = require('../util/latch');\n\nvar sdpUtils = require('../util/sdp');\n\nvar util = require('../util');\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\nvar updateTrackIdsToSSRCs = isUnifiedPlan ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs : sdpUtils.updatePlanBTrackIdsToSSRCs;\n\nfunction SafariRTCPeerConnection(configuration) {\n  if (!(this instanceof SafariRTCPeerConnection)) {\n    return new SafariRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'iceconnectionstatechange');\n  util.interceptEvent(this, 'signalingstatechange');\n  util.interceptEvent(this, 'track');\n  var peerConnection = new RTCPeerConnection(configuration);\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _audioTransceiver: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _videoTransceiver: {\n      value: null,\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function get() {\n        return this._pendingLocalOffer || this._peerConnection.localDescription;\n      }\n    },\n    iceConnectionState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n      }\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function get() {\n        return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function get() {\n        if (this._isClosed) {\n          return 'closed';\n        } else if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n\n        return this._peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n  peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n\n    self.dispatchEvent.apply(self, arguments);\n  });\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  }); // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n  // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n  // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n  // even though a new remote RTCSessionDescription had already been applied.\n\n  peerConnection.addEventListener('track', function ontrack(event) {\n    self._pendingRemoteOffer = null;\n    self.dispatchEvent(event);\n  });\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(SafariRTCPeerConnection, EventTarget);\n\nSafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  }\n\n  return this._peerConnection.addIceCandidate(candidate);\n};\n\nSafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {\n  options = Object.assign({}, options);\n  var self = this; // NOTE(mroberts): In general, this is not the way to do this; however, it's\n  // good enough for our application.\n\n  if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n    delete options.offerToReceiveAudio;\n\n    try {\n      this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n        direction: 'recvonly'\n      }) : this.addTransceiver('audio');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n    delete options.offerToReceiveVideo;\n\n    try {\n      this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n        direction: 'recvonly'\n      }) : this.addTransceiver('video');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  return this._peerConnection.createOffer(options).then(function (offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new RTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n};\n\nSafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      self._signalingStateLatch.lower();\n\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null; // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n\n      self._rolledBackTracksToSSRCs.clear();\n\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  }\n\n  return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {\n    // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return isUnifiedPlan ? new RTCSessionDescription({\n      type: answer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n    }) : answer;\n  });\n};\n\nSafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nSafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n  sender.replaceTrack(null);\n\n  this._peerConnection.removeTrack(sender);\n};\n\nSafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {\n  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  return setDescription(this, true, description);\n};\n\nSafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {\n  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n  this._rolledBackTracksToSSRCs.clear();\n\n  return setDescription(this, false, description);\n};\n\nSafariRTCPeerConnection.prototype.close = function close() {\n  if (this._isClosed) {\n    return;\n  }\n\n  this._isClosed = true;\n\n  this._peerConnection.close();\n\n  var self = this;\n  setTimeout(function () {\n    self.dispatchEvent(new Event('iceconnectionstatechange'));\n    self.dispatchEvent(new Event('signalingstatechange'));\n  });\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, SafariRTCPeerConnection.prototype, '_peerConnection');\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') + ' offer in state ' + peerConnection.signalingState));\n    }\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description); // Only dispatch a signalingstatechange event if we transitioned.\n\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error('Cannot rollback ' + (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    }\n\n    clearPendingLocalOffer(); // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n    return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n      peerConnection.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\n\n\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\n\n\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535 ? null : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n    }\n  });\n}\n\nmodule.exports = SafariRTCPeerConnection;","map":{"version":3,"mappings":"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","names":["EventTarget","require","inherits","Latch","sdpUtils","util","isUnifiedPlan","getSdpFormat","updateTrackIdsToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","updatePlanBTrackIdsToSSRCs","SafariRTCPeerConnection","configuration","call","interceptEvent","peerConnection","RTCPeerConnection","Object","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_audioTransceiver","_isClosed","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_signalingStateLatch","_tracksToSSRCs","_videoTransceiver","localDescription","enumerable","get","iceConnectionState","iceGatheringState","remoteDescription","signalingState","self","addEventListener","ondatachannel","event","shimDataChannel","channel","dispatchEvent","oniceconnectionstatechange","apply","arguments","onsignalingstatechange","ontrack","proxyProperties","prototype","addIceCandidate","candidate","when","then","signalingStatesResolved","createOffer","options","assign","offerToReceiveVideo","hasReceiversForTracksOfKind","offerToReceiveAudio","addTransceiver","direction","e","Promise","reject","offer","clear","RTCSessionDescription","type","sdp","createAnswer","setRemoteDescription","setRemoteDescriptionSucceeded","lower","createAnswerSucceeded","answer","setRemoteDescriptionOrCreateAnswerFailed","error","createDataChannel","label","dataChannelDict","dataChannel","removeTrack","sender","replaceTrack","setLocalDescription","description","size","setDescription","close","setTimeout","Event","delegateMethods","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setRemoteAnswer","Error","state","raise","previousSignalingState","resolve","dispatchSignalingStateChangeEvent","setLocalOfferSucceeded","setRemoteAnswerSucceeded","kind","getTransceivers","find","transceiver","receiver","track","maxPacketLifeTime","maxRetransmits","module","exports"],"sources":["/home/samliu/repos/ieee/tp-robot/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/safari.js"],"sourcesContent":["/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\nvar inherits = require('../../vendor/inherits');\nvar Latch = require('../util/latch');\nvar sdpUtils = require('../util/sdp');\nvar util = require('../util');\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\n\nvar updateTrackIdsToSSRCs = isUnifiedPlan\n  ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs\n  : sdpUtils.updatePlanBTrackIdsToSSRCs;\n\nfunction SafariRTCPeerConnection(configuration) {\n  if (!(this instanceof SafariRTCPeerConnection)) {\n    return new SafariRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'iceconnectionstatechange');\n  util.interceptEvent(this, 'signalingstatechange');\n  util.interceptEvent(this, 'track');\n\n  var peerConnection = new RTCPeerConnection(configuration);\n\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _audioTransceiver: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _videoTransceiver: {\n      value: null,\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingLocalOffer || this._peerConnection.localDescription;\n      }\n    },\n    iceConnectionState: {\n      enumerable: true,\n      get: function() {\n        return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n      }\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function() {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function() {\n        if (this._isClosed) {\n          return 'closed';\n        } else if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n        return this._peerConnection.signalingState;\n      }\n    }\n  });\n\n  var self = this;\n\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n\n  peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n    self.dispatchEvent.apply(self, arguments);\n  });\n\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  });\n\n  // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n  // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n  // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n  // even though a new remote RTCSessionDescription had already been applied.\n  peerConnection.addEventListener('track', function ontrack(event) {\n    self._pendingRemoteOffer = null;\n    self.dispatchEvent(event);\n  });\n\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(SafariRTCPeerConnection, EventTarget);\n\nSafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var self = this;\n  if (this.signalingState === 'have-remote-offer') {\n    return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  }\n  return this._peerConnection.addIceCandidate(candidate);\n};\n\nSafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {\n  options = Object.assign({}, options);\n  var self = this;\n\n  // NOTE(mroberts): In general, this is not the way to do this; however, it's\n  // good enough for our application.\n  if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n    delete options.offerToReceiveAudio;\n    try {\n      this._audioTransceiver = isUnifiedPlan\n        ? this.addTransceiver('audio', { direction: 'recvonly' })\n        : this.addTransceiver('audio');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n    delete options.offerToReceiveVideo;\n    try {\n      this._videoTransceiver = isUnifiedPlan\n        ? this.addTransceiver('video', { direction: 'recvonly' })\n        : this.addTransceiver('video');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  return this._peerConnection.createOffer(options).then(function(offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new RTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n};\n\nSafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      self._signalingStateLatch.lower();\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null;\n\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  }\n\n  return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {\n    // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return isUnifiedPlan ? new RTCSessionDescription({\n      type: answer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n    }) : answer;\n  });\n};\n\nSafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nSafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n  sender.replaceTrack(null);\n  this._peerConnection.removeTrack(sender);\n};\n\nSafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {\n  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n    this._rolledBackTracksToSSRCs.clear();\n  }\n  return setDescription(this, true, description);\n};\n\nSafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {\n  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n  this._rolledBackTracksToSSRCs.clear();\n  return setDescription(this, false, description);\n};\n\nSafariRTCPeerConnection.prototype.close = function close() {\n  if (this._isClosed) {\n    return;\n  }\n  this._isClosed = true;\n  this._peerConnection.close();\n  var self = this;\n  setTimeout(function() {\n    self.dispatchEvent(new Event('iceconnectionstatechange'));\n    self.dispatchEvent(new Event('signalingstatechange'));\n  });\n};\n\nutil.delegateMethods(\n  RTCPeerConnection.prototype,\n  SafariRTCPeerConnection.prototype,\n  '_peerConnection');\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +\n        ' offer in state ' + peerConnection.signalingState));\n    }\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description);\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error('Cannot rollback ' +\n        (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    }\n    clearPendingLocalOffer();\n\n    // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n    return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n      peerConnection.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function(transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535\n        ? null\n        : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535\n        ? null\n        : dataChannel.maxRetransmits\n    }\n  });\n}\n\nmodule.exports = SafariRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script"}